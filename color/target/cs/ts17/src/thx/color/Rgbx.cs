// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx.color._Rgbx {
	public sealed class Rgbx_Impl_ {
		
		public static global::Array<double> create(double red, double green, double blue) {
			return ((global::Array<double>) (new global::Array<double>(new double[]{red, green, blue})) );
		}
		
		
		public static global::Array<double> fromFloats(global::Array<double> arr) {
			unchecked {
				global::thx.ArrayFloats.resize(arr, 3, default(global::haxe.lang.Null<double>));
				return ((global::Array<double>) (new global::Array<double>(new double[]{arr[0], arr[1], arr[2]})) );
			}
		}
		
		
		public static global::Array<double> fromInts(global::Array<int> arr) {
			unchecked {
				global::thx.ArrayInts.resize(arr, 3, default(global::haxe.lang.Null<int>));
				return ((global::Array<double>) (new global::Array<double>(new double[]{( arr[0] / 255.0 ), ( arr[1] / 255.0 ), ( arr[2] / 255.0 )})) );
			}
		}
		
		
		public static global::Array<double> fromInt(int @value) {
			unchecked {
				int rgb = @value;
				return ((global::Array<double>) (new global::Array<double>(new double[]{( ((double) (global::thx.color._Rgb.Rgb_Impl_.get_red(rgb)) ) / 255 ), ( ((double) (global::thx.color._Rgb.Rgb_Impl_.get_green(rgb)) ) / 255 ), ( ((double) (global::thx.color._Rgb.Rgb_Impl_.get_blue(rgb)) ) / 255 )})) );
			}
		}
		
		
		public static global::Array<double> fromString(string color) {
			unchecked {
				global::thx.color.parse.ColorInfo info = global::thx.color.parse.ColorParser.parseHex(color);
				if (( null == info )) {
					info = global::thx.color.parse.ColorParser.parseColor(color);
				}
				
				if (( null == info )) {
					return null;
				}
				
				try {
					if (string.Equals(info.name, "rgb")) {
						return global::thx.color._Rgbx.Rgbx_Impl_.fromFloats(global::thx.color.parse.ColorParser.getFloatChannels(info.channels, 3, true));
					}
					else {
						return null;
					}
					
				}
				catch (global::System.Exception __temp_catchallException1){
					global::haxe.lang.Exceptions.exception = __temp_catchallException1;
					object __temp_catchall2 = __temp_catchallException1;
					if (( __temp_catchall2 is global::haxe.lang.HaxeException )) {
						__temp_catchall2 = ((global::haxe.lang.HaxeException) (__temp_catchallException1) ).obj;
					}
					
					{
						object e = __temp_catchall2;
						return null;
					}
					
				}
				
				
			}
		}
		
		
		public static global::Array<double> _new(global::Array<double> channels) {
			return ((global::Array<double>) (channels) );
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		public static global::Array<double> darker(global::Array<double> this1, double t) {
			unchecked {
				return ((global::Array<double>) (new global::Array<double>(new double[]{global::thx.Floats.interpolate(t, ((global::Array<double>) (this1) )[0], ((double) (0) )), global::thx.Floats.interpolate(t, ((global::Array<double>) (this1) )[1], ((double) (0) )), global::thx.Floats.interpolate(t, ((global::Array<double>) (this1) )[2], ((double) (0) ))})) );
			}
		}
		
		
		public static global::Array<double> lighter(global::Array<double> this1, double t) {
			unchecked {
				return ((global::Array<double>) (new global::Array<double>(new double[]{global::thx.Floats.interpolate(t, ((global::Array<double>) (this1) )[0], ((double) (1) )), global::thx.Floats.interpolate(t, ((global::Array<double>) (this1) )[1], ((double) (1) )), global::thx.Floats.interpolate(t, ((global::Array<double>) (this1) )[2], ((double) (1) ))})) );
			}
		}
		
		
		public static global::Array<double> interpolate(global::Array<double> this1, global::Array<double> other, double t) {
			unchecked {
				return ((global::Array<double>) (new global::Array<double>(new double[]{global::thx.Floats.interpolate(t, ((global::Array<double>) (this1) )[0], ((global::Array<double>) (other) )[0]), global::thx.Floats.interpolate(t, ((global::Array<double>) (this1) )[1], ((global::Array<double>) (other) )[1]), global::thx.Floats.interpolate(t, ((global::Array<double>) (this1) )[2], ((global::Array<double>) (other) )[2])})) );
			}
		}
		
		
		public static global::Array<double> min(global::Array<double> this1, global::Array<double> other) {
			unchecked {
				return ((global::Array<double>) (new global::Array<double>(new double[]{global::System.Math.Min(((double) (((global::Array<double>) (this1) )[0]) ), ((double) (((global::Array<double>) (other) )[0]) )), global::System.Math.Min(((double) (((global::Array<double>) (this1) )[1]) ), ((double) (((global::Array<double>) (other) )[1]) )), global::System.Math.Min(((double) (((global::Array<double>) (this1) )[2]) ), ((double) (((global::Array<double>) (other) )[2]) ))})) );
			}
		}
		
		
		public static global::Array<double> max(global::Array<double> this1, global::Array<double> other) {
			unchecked {
				return ((global::Array<double>) (new global::Array<double>(new double[]{global::System.Math.Max(((double) (((global::Array<double>) (this1) )[0]) ), ((double) (((global::Array<double>) (other) )[0]) )), global::System.Math.Max(((double) (((global::Array<double>) (this1) )[1]) ), ((double) (((global::Array<double>) (other) )[1]) )), global::System.Math.Max(((double) (((global::Array<double>) (this1) )[2]) ), ((double) (((global::Array<double>) (other) )[2]) ))})) );
			}
		}
		
		
		public static global::Array<double> normalize(global::Array<double> this1) {
			unchecked {
				global::Array<double> this2 = null;
				double v = ((global::Array<double>) (this1) )[0];
				double tmp = ( (( v < 0 )) ? (((double) (0) )) : (( (( v > 1 )) ? (((double) (1) )) : (v) )) );
				double v1 = ((global::Array<double>) (this1) )[1];
				double tmp1 = ( (( v1 < 0 )) ? (((double) (0) )) : (( (( v1 > 1 )) ? (((double) (1) )) : (v1) )) );
				double v2 = ((global::Array<double>) (this1) )[2];
				this2 = new global::Array<double>(new double[]{tmp, tmp1, ( (( v2 < 0 )) ? (((double) (0) )) : (( (( v2 > 1 )) ? (((double) (1) )) : (v2) )) )});
				return ((global::Array<double>) (this2) );
			}
		}
		
		
		public static global::Array<double> roundTo(global::Array<double> this1, int decimals) {
			unchecked {
				return ((global::Array<double>) (new global::Array<double>(new double[]{global::thx.Floats.roundTo(((global::Array<double>) (this1) )[0], decimals), global::thx.Floats.roundTo(((global::Array<double>) (this1) )[1], decimals), global::thx.Floats.roundTo(((global::Array<double>) (this1) )[2], decimals)})) );
			}
		}
		
		
		public static string toCss3(global::Array<double> this1) {
			return global::thx.color._Rgbx.Rgbx_Impl_.toString(this1);
		}
		
		
		public static string toString(global::Array<double> this1) {
			unchecked {
				return global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("rgb(", global::haxe.lang.Runtime.toString(( ((global::Array<double>) (this1) )[0] * 100 ))), "%,"), global::haxe.lang.Runtime.toString(( ((global::Array<double>) (this1) )[1] * 100 ))), "%,"), global::haxe.lang.Runtime.toString(( ((global::Array<double>) (this1) )[2] * 100 ))), "%)");
			}
		}
		
		
		public static string toHex(global::Array<double> this1, string prefix) {
			unchecked {
				if (string.Equals(prefix, null)) {
					prefix = "#";
				}
				
				return global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("", prefix), global::StringTools.hex(global::thx.color._Rgbx.Rgbx_Impl_.get_red(this1), new global::haxe.lang.Null<int>(2, true))), global::StringTools.hex(global::thx.color._Rgbx.Rgbx_Impl_.get_green(this1), new global::haxe.lang.Null<int>(2, true))), global::StringTools.hex(global::thx.color._Rgbx.Rgbx_Impl_.get_blue(this1), new global::haxe.lang.Null<int>(2, true)));
			}
		}
		
		
		public static bool @equals(global::Array<double> this1, global::Array<double> other) {
			return global::thx.color._Rgbx.Rgbx_Impl_.nearEquals(this1, other, default(global::haxe.lang.Null<double>));
		}
		
		
		public static bool nearEquals(global::Array<double> this1, global::Array<double> other, global::haxe.lang.Null<double> tolerance) {
			unchecked {
				global::haxe.lang.Null<double> __temp_tolerance157 = ( ( ! (tolerance.hasValue) ) ? (new global::haxe.lang.Null<double>(1e-9, true)) : (tolerance) );
				if (( global::thx.Floats.nearEquals(((global::Array<double>) (this1) )[0], ((global::Array<double>) (other) )[0], __temp_tolerance157) && global::thx.Floats.nearEquals(((global::Array<double>) (this1) )[1], ((global::Array<double>) (other) )[1], __temp_tolerance157) )) {
					return global::thx.Floats.nearEquals(((global::Array<double>) (this1) )[2], ((global::Array<double>) (other) )[2], __temp_tolerance157);
				}
				else {
					return false;
				}
				
			}
		}
		
		
		public static global::Array<double> withAlpha(global::Array<double> this1, double alpha) {
			return ((global::Array<double>) (this1.concat(new global::Array<double>(new double[]{alpha}))) );
		}
		
		
		public static global::Array<double> withRed(global::Array<double> this1, int newred) {
			return ((global::Array<double>) (new global::Array<double>(new double[]{((double) (newred) ), ((double) (global::thx.color._Rgbx.Rgbx_Impl_.get_green(this1)) ), ((double) (global::thx.color._Rgbx.Rgbx_Impl_.get_blue(this1)) )})) );
		}
		
		
		public static global::Array<double> withGreen(global::Array<double> this1, int newgreen) {
			return ((global::Array<double>) (new global::Array<double>(new double[]{((double) (global::thx.color._Rgbx.Rgbx_Impl_.get_red(this1)) ), ((double) (newgreen) ), ((double) (global::thx.color._Rgbx.Rgbx_Impl_.get_blue(this1)) )})) );
		}
		
		
		public static global::Array<double> withBlue(global::Array<double> this1, int newblue) {
			return ((global::Array<double>) (new global::Array<double>(new double[]{((double) (global::thx.color._Rgbx.Rgbx_Impl_.get_red(this1)) ), ((double) (global::thx.color._Rgbx.Rgbx_Impl_.get_green(this1)) ), ((double) (newblue) )})) );
		}
		
		
		public static global::Array<double> toLab(global::Array<double> this1) {
			return global::thx.color._Xyz.Xyz_Impl_.toLab(global::thx.color._Rgbx.Rgbx_Impl_.toXyz(this1));
		}
		
		
		public static global::Array<double> toLCh(global::Array<double> this1) {
			return global::thx.color._Lab.Lab_Impl_.toLCh(global::thx.color._Rgbx.Rgbx_Impl_.toLab(this1));
		}
		
		
		public static global::Array<double> toLuv(global::Array<double> this1) {
			return global::thx.color._Xyz.Xyz_Impl_.toLuv(global::thx.color._Rgbx.Rgbx_Impl_.toXyz(this1));
		}
		
		
		public static global::Array<double> toCmy(global::Array<double> this1) {
			unchecked {
				return ((global::Array<double>) (new global::Array<double>(new double[]{( 1 - ((global::Array<double>) (this1) )[0] ), ( 1 - ((global::Array<double>) (this1) )[1] ), ( 1 - ((global::Array<double>) (this1) )[2] )})) );
			}
		}
		
		
		public static global::Array<double> toCmyk(global::Array<double> this1) {
			unchecked {
				double c = 0.0;
				double y = 0.0;
				double m = 0.0;
				double k = default(double);
				if (( ( ( ((global::Array<double>) (this1) )[0] + ((global::Array<double>) (this1) )[1] ) + ((global::Array<double>) (this1) )[2] ) == 0 )) {
					k = 1.0;
				}
				else {
					k = ( 1 - global::System.Math.Max(((double) (global::System.Math.Max(((double) (((global::Array<double>) (this1) )[0]) ), ((double) (((global::Array<double>) (this1) )[1]) ))) ), ((double) (((global::Array<double>) (this1) )[2]) )) );
					c = ( (( ( 1 - ((global::Array<double>) (this1) )[0] ) - k )) / (( 1 - k )) );
					m = ( (( ( 1 - ((global::Array<double>) (this1) )[1] ) - k )) / (( 1 - k )) );
					y = ( (( ( 1 - ((global::Array<double>) (this1) )[2] ) - k )) / (( 1 - k )) );
				}
				
				return ((global::Array<double>) (new global::Array<double>(new double[]{c, m, y, k})) );
			}
		}
		
		
		public static global::Array<double> toCubeHelix(global::Array<double> this1) {
			unchecked {
				return global::thx.color._Rgbx.Rgbx_Impl_.toCubeHelixWithGamma(this1, ((double) (1) ));
			}
		}
		
		
		public static global::Array<double> toCubeHelixWithGamma(global::Array<double> this1, double gamma) {
			unchecked {
				double l = ( (( ( ( -0.655763666799999867 * ((global::Array<double>) (this1) )[2] ) + ( -1.7884503806 * ((global::Array<double>) (this1) )[0] ) ) - ( 3.5172982438 * ((global::Array<double>) (this1) )[1] ) )) / -5.9615122912 );
				double bl = ( ((global::Array<double>) (this1) )[2] - l );
				double k = ( (( ( 1.97294 * (( ((global::Array<double>) (this1) )[1] - l )) ) - ( -0.29227 * bl ) )) / -0.90649 );
				double lgamma = global::System.Math.Pow(((double) (l) ), ((double) (gamma) ));
				double s = default(double);
				try {
					s = ( global::System.Math.Sqrt(((double) (( ( k * k ) + ( bl * bl ) )) )) / (( ( 1.97294 * lgamma ) * (( 1 - lgamma )) )) );
				}
				catch (global::System.Exception __temp_catchallException1){
					global::haxe.lang.Exceptions.exception = __temp_catchallException1;
					object __temp_catchall2 = __temp_catchallException1;
					if (( __temp_catchall2 is global::haxe.lang.HaxeException )) {
						__temp_catchall2 = ((global::haxe.lang.HaxeException) (__temp_catchallException1) ).obj;
					}
					
					{
						object e = __temp_catchall2;
						s = 0.0;
					}
					
				}
				
				
				double h = default(double);
				try {
					if (( s != 0 )) {
						h = ( ( ( global::System.Math.Atan2(((double) (k) ), ((double) (bl) )) / global::Math.PI ) * 180 ) - 120 );
					}
					else {
						h = global::Math.NaN;
					}
					
				}
				catch (global::System.Exception __temp_catchallException3){
					global::haxe.lang.Exceptions.exception = __temp_catchallException3;
					object __temp_catchall4 = __temp_catchallException3;
					if (( __temp_catchall4 is global::haxe.lang.HaxeException )) {
						__temp_catchall4 = ((global::haxe.lang.HaxeException) (__temp_catchallException3) ).obj;
					}
					
					{
						object e1 = __temp_catchall4;
						h = 0.0;
					}
					
				}
				
				
				if (global::System.Double.IsNaN(((double) (s) ))) {
					s = ((double) (0) );
				}
				
				if (global::System.Double.IsNaN(((double) (h) ))) {
					h = ((double) (0) );
				}
				
				if (( h < 0 )) {
					h += ((double) (360) );
				}
				
				return ((global::Array<double>) (new global::Array<double>(new double[]{h, s, l, ((double) (1) )})) );
			}
		}
		
		
		public static double toGrey(global::Array<double> this1) {
			unchecked {
				return ((double) (( ( ( ((global::Array<double>) (this1) )[0] * .2126 ) + ( ((global::Array<double>) (this1) )[1] * .7152 ) ) + ( ((global::Array<double>) (this1) )[2] * .0722 ) )) );
			}
		}
		
		
		public static double toPerceivedGrey(global::Array<double> this1) {
			unchecked {
				return ((double) (( ( ( ((global::Array<double>) (this1) )[0] * .299 ) + ( ((global::Array<double>) (this1) )[1] * .587 ) ) + ( ((global::Array<double>) (this1) )[2] * .114 ) )) );
			}
		}
		
		
		public static double toPerceivedAccurateGrey(global::Array<double> this1) {
			unchecked {
				return ((double) (( ( ( global::System.Math.Pow(((double) (((global::Array<double>) (this1) )[0]) ), ((double) (2) )) * .241 ) + ( global::System.Math.Pow(((double) (((global::Array<double>) (this1) )[1]) ), ((double) (2) )) * .691 ) ) + ( global::System.Math.Pow(((double) (((global::Array<double>) (this1) )[2]) ), ((double) (2) )) * .068 ) )) );
			}
		}
		
		
		public static global::Array<double> toHsl(global::Array<double> this1) {
			unchecked {
				double min = global::System.Math.Min(((double) (global::System.Math.Min(((double) (((global::Array<double>) (this1) )[0]) ), ((double) (((global::Array<double>) (this1) )[1]) ))) ), ((double) (((global::Array<double>) (this1) )[2]) ));
				double max = global::System.Math.Max(((double) (global::System.Math.Max(((double) (((global::Array<double>) (this1) )[0]) ), ((double) (((global::Array<double>) (this1) )[1]) ))) ), ((double) (((global::Array<double>) (this1) )[2]) ));
				double delta = ( max - min );
				double h = default(double);
				double s = default(double);
				double l = ( (( max + min )) / 2 );
				if (( delta == 0.0 )) {
					h = 0.0;
					s = 0.0;
				}
				else {
					if (( l < 0.5 )) {
						s = ( delta / (( max + min )) );
					}
					else {
						s = ( delta / (( ( 2 - max ) - min )) );
					}
					
					if (( ((global::Array<double>) (this1) )[0] == max )) {
						h = ( ( (( ((global::Array<double>) (this1) )[1] - ((global::Array<double>) (this1) )[2] )) / delta ) + (( (( ((global::Array<double>) (this1) )[1] < global::thx.color._Rgbx.Rgbx_Impl_.get_blue(this1) )) ? (6) : (0) )) );
					}
					else if (( ((global::Array<double>) (this1) )[1] == max )) {
						h = ( ( (( ((global::Array<double>) (this1) )[2] - ((global::Array<double>) (this1) )[0] )) / delta ) + 2 );
					}
					else {
						h = ( ( (( ((global::Array<double>) (this1) )[0] - ((global::Array<double>) (this1) )[1] )) / delta ) + 4 );
					}
					
					h *= ((double) (60) );
				}
				
				return ((global::Array<double>) (new global::Array<double>(new double[]{h, s, l})) );
			}
		}
		
		
		public static global::Array<double> toHsv(global::Array<double> this1) {
			unchecked {
				double min = global::System.Math.Min(((double) (global::System.Math.Min(((double) (((global::Array<double>) (this1) )[0]) ), ((double) (((global::Array<double>) (this1) )[1]) ))) ), ((double) (((global::Array<double>) (this1) )[2]) ));
				double max = global::System.Math.Max(((double) (global::System.Math.Max(((double) (((global::Array<double>) (this1) )[0]) ), ((double) (((global::Array<double>) (this1) )[1]) ))) ), ((double) (((global::Array<double>) (this1) )[2]) ));
				double delta = ( max - min );
				double h = default(double);
				double s = default(double);
				if (( delta != 0 )) {
					s = ( delta / max );
				}
				else {
					s = ((double) (0) );
					h = ((double) (-1) );
					return ((global::Array<double>) (new global::Array<double>(new double[]{h, s, max})) );
				}
				
				if (( ((global::Array<double>) (this1) )[0] == max )) {
					h = ( (( ((global::Array<double>) (this1) )[1] - ((global::Array<double>) (this1) )[2] )) / delta );
				}
				else if (( ((global::Array<double>) (this1) )[1] == max )) {
					h = ( 2 + ( (( ((global::Array<double>) (this1) )[2] - ((global::Array<double>) (this1) )[0] )) / delta ) );
				}
				else {
					h = ( 4 + ( (( ((global::Array<double>) (this1) )[0] - ((global::Array<double>) (this1) )[1] )) / delta ) );
				}
				
				h *= ((double) (60) );
				if (( h < 0 )) {
					h += ((double) (360) );
				}
				
				return ((global::Array<double>) (new global::Array<double>(new double[]{h, s, max})) );
			}
		}
		
		
		public static global::Array<double> toHunterLab(global::Array<double> this1) {
			return global::thx.color._Xyz.Xyz_Impl_.toHunterLab(global::thx.color._Rgbx.Rgbx_Impl_.toXyz(this1));
		}
		
		
		public static int toRgb(global::Array<double> this1) {
			unchecked {
				return ((int) (( ( ( (( global::Math.round(( ((global::Array<double>) (this1) )[0] * 255 )) & 255 )) << 16 ) | ( (( global::Math.round(( ((global::Array<double>) (this1) )[1] * 255 )) & 255 )) << 8 ) ) | ( global::Math.round(( ((global::Array<double>) (this1) )[2] * 255 )) & 255 ) )) );
			}
		}
		
		
		public static global::Array<double> toRgbxa(global::Array<double> this1) {
			return global::thx.color._Rgbx.Rgbx_Impl_.withAlpha(this1, 1.0);
		}
		
		
		public static double toTemperature(global::Array<double> this1) {
			unchecked {
				double t = ((double) (0) );
				global::Array<double> rgb = null;
				double minT = ((double) (1000) );
				double maxT = ((double) (40000) );
				while (( ( maxT - minT ) > 0.4 )) {
					t = ( (( maxT + minT )) / 2 );
					rgb = global::thx.color._Temperature.Temperature_Impl_.temperatureToRgbx(t);
					if (( ( ((global::Array<double>) (rgb) )[2] / ((global::Array<double>) (rgb) )[0] ) >= ( ((global::Array<double>) (this1) )[2] / ((global::Array<double>) (this1) )[0] ) )) {
						maxT = t;
					}
					else {
						minT = t;
					}
					
				}
				
				return ((double) (t) );
			}
		}
		
		
		public static global::Array<double> toXyz(global::Array<double> this1) {
			unchecked {
				double r = ((global::Array<double>) (this1) )[0];
				double g = ((global::Array<double>) (this1) )[1];
				double b = ((global::Array<double>) (this1) )[2];
				if (( r > 0.04045 )) {
					r = global::System.Math.Pow(((double) (( (( r + 0.055 )) / 1.055 )) ), ((double) (2.4) ));
				}
				else {
					r /= 12.92;
				}
				
				if (( g > 0.04045 )) {
					g = global::System.Math.Pow(((double) (( (( g + 0.055 )) / 1.055 )) ), ((double) (2.4) ));
				}
				else {
					g /= 12.92;
				}
				
				if (( b > 0.04045 )) {
					b = global::System.Math.Pow(((double) (( (( b + 0.055 )) / 1.055 )) ), ((double) (2.4) ));
				}
				else {
					b /= 12.92;
				}
				
				return ((global::Array<double>) (new global::Array<double>(new double[]{( ( ( r * 0.4124564 ) + ( g * 0.3575761 ) ) + ( b * 0.1804375 ) ), ( ( ( r * 0.2126729 ) + ( g * 0.7151522 ) ) + ( b * 0.0721750 ) ), ( ( ( r * 0.0193339 ) + ( g * 0.1191920 ) ) + ( b * 0.9503041 ) )})) );
			}
		}
		
		
		public static global::Array<double> toYuv(global::Array<double> this1) {
			unchecked {
				double r = ((global::Array<double>) (this1) )[0];
				double g = ((global::Array<double>) (this1) )[1];
				double b = ((global::Array<double>) (this1) )[2];
				return ((global::Array<double>) (new global::Array<double>(new double[]{( ( ( 0.299 * r ) + ( 0.587 * g ) ) + ( 0.114 * b ) ), ( ( ( -0.14713 * r ) - ( 0.28886 * g ) ) + ( 0.436 * b ) ), ( ( ( 0.615 * r ) - ( 0.51499 * g ) ) - ( 0.10001 * b ) )})) );
			}
		}
		
		
		public static global::Array<double> toYxy(global::Array<double> this1) {
			return global::thx.color._Xyz.Xyz_Impl_.toYxy(global::thx.color._Rgbx.Rgbx_Impl_.toXyz(this1));
		}
		
		
		public static int get_red(global::Array<double> this1) {
			unchecked {
				return global::Math.round(( ((global::Array<double>) (this1) )[0] * 255 ));
			}
		}
		
		
		public static int get_green(global::Array<double> this1) {
			unchecked {
				return global::Math.round(( ((global::Array<double>) (this1) )[1] * 255 ));
			}
		}
		
		
		public static int get_blue(global::Array<double> this1) {
			unchecked {
				return global::Math.round(( ((global::Array<double>) (this1) )[2] * 255 ));
			}
		}
		
		
		public static double get_redf(global::Array<double> this1) {
			return this1[0];
		}
		
		
		public static double get_greenf(global::Array<double> this1) {
			unchecked {
				return this1[1];
			}
		}
		
		
		public static double get_bluef(global::Array<double> this1) {
			unchecked {
				return this1[2];
			}
		}
		
		
		public static bool get_inSpace(global::Array<double> this1) {
			unchecked {
				if (( ( ( ( ( ((global::Array<double>) (this1) )[0] >= 0 ) && ( ((global::Array<double>) (this1) )[0] <= 1 ) ) && ( ((global::Array<double>) (this1) )[1] >= 0 ) ) && ( ((global::Array<double>) (this1) )[1] <= 1 ) ) && ( ((global::Array<double>) (this1) )[2] >= 0 ) )) {
					return ( ((global::Array<double>) (this1) )[2] <= 1 );
				}
				else {
					return false;
				}
				
			}
		}
		
		
	}
}


