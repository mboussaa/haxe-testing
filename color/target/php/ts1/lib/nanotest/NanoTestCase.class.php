<?php

// Generated by Haxe 3.3.0
class nanotest_NanoTestCase {
	public function __construct($posInfos = null) {
		if(!php_Boot::$skip_constructor) {
		$this->posInfos = $posInfos;
	}}
	public $currentResult;
	public $posInfos;
	public function globalTearDown() {}
	public function globalSetup() {}
	public function tearDown() {}
	public function setup() {}
	public function run($print) {
		$_gthis = $this;
		$results = (new _hx_array(array()));
		$cl = Type::getClass($this);
		$fields = Type::getInstanceFields($cl);
		$closeResult = array(new _hx_lambda(array(&$_gthis, &$print, &$results), "nanotest_NanoTestCase_0"), 'execute');
		call_user_func_array($print, array("Class: " . _hx_string_or_null(Type::getClassName($cl)) . " "));
		$this->globalSetup();
		if(_hx_field($this, "currentResult") !== null) {
			call_user_func($closeResult);
		}
		{
			$_g = 0;
			while($_g < $fields->length) {
				$fname = $fields[$_g];
				++$_g;
				$field = Reflect::field($this, $fname);
				$tmp2 = null;
				$tmp3 = StringTools::startsWith($fname, "test");
				if($tmp3) {
					$tmp2 = Reflect::isFunction($field);
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$this->currentResult = _hx_anonymous(array("className" => Type::getClassName($cl), "method" => $fname, "async" => false, "testCase" => $this, "error" => false, "failed" => false, "status" => (new _hx_array(array()))));
					$this->setup();
					try {
						Reflect::callMethod($this, $field, (new _hx_array(array())));
					}catch(Exception $__hx__e) {
						$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
						$e = $_ex_;
						{
							$this->error($e);
						}
					}
					$this->tearDown();
					call_user_func($closeResult);
					unset($e);
				}
				unset($tmp3,$tmp2,$fname,$field);
			}
		}
		$this->globalTearDown();
		call_user_func_array($print, array("\x0A"));
		return $results;
	}
	public function assertTrue($b, $p = null) {
		if($b === false) {
			return $this->fail("expected true but was false", $p);
		} else {
			return $this->success($p);
		}
	}
	public function assertFalse($b, $p = null) {
		if($b === true) {
			return $this->fail("expected false but was true", $p);
		} else {
			return $this->success($p);
		}
	}
	public function assertEquals($expected, $actual, $p = null) {
		$tmp = Reflect::isEnumValue($expected);
		if($tmp) {
			$tmp1 = !Type::enumEq($actual, $expected);
			if($tmp1) {
				$tmp2 = nanotest_NanoTestCase::format($expected);
				$tmp3 = "expected " . _hx_string_or_null($tmp2) . " but was ";
				$tmp4 = nanotest_NanoTestCase::format($actual);
				return $this->fail(_hx_string_or_null($tmp3) . _hx_string_or_null($tmp4), $p);
			} else {
				return $this->success($p);
			}
		} else {
			if((is_object($_t = $actual) && ($_t instanceof Enum) ? $_t != $expected : !_hx_equal($_t, $expected))) {
				$tmp5 = nanotest_NanoTestCase::format($expected);
				$tmp6 = "expected " . _hx_string_or_null($tmp5) . " but was ";
				$tmp7 = nanotest_NanoTestCase::format($actual);
				return $this->fail(_hx_string_or_null($tmp6) . _hx_string_or_null($tmp7), $p);
			} else {
				return $this->success($p);
			}
		}
	}
	public function assertNotEquals($notExpected, $actual, $p = null) {
		$tmp = Reflect::isEnumValue($notExpected);
		if($tmp) {
			$tmp1 = Type::enumEq($actual, $notExpected);
			if($tmp1) {
				$tmp2 = nanotest_NanoTestCase::format($notExpected);
				$tmp3 = "expected not " . _hx_string_or_null($tmp2) . " but was ";
				$tmp4 = nanotest_NanoTestCase::format($actual);
				return $this->fail(_hx_string_or_null($tmp3) . _hx_string_or_null($tmp4), $p);
			} else {
				return $this->success($p);
			}
		} else {
			if((is_object($_t = $actual) && ($_t instanceof Enum) ? $_t == $notExpected : _hx_equal($_t, $notExpected))) {
				$tmp5 = nanotest_NanoTestCase::format($notExpected);
				$tmp6 = "expected not " . _hx_string_or_null($tmp5) . " but was ";
				$tmp7 = nanotest_NanoTestCase::format($actual);
				return $this->fail(_hx_string_or_null($tmp6) . _hx_string_or_null($tmp7), $p);
			} else {
				return $this->success($p);
			}
		}
	}
	public function assertThrows($func, $isSuccess = null, $p = null) {
		try {
			call_user_func($func);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$d = $_ex_;
			{
				$tmp = null;
				if($isSuccess !== null) {
					$tmp = call_user_func_array($isSuccess, array($d));
				} else {
					$tmp = true;
				}
				if($tmp) {
					return $this->success($p);
				} else {
					$tmp1 = nanotest_NanoTestCase::format($d);
					$f = $this->fail("catched illeagal exception " . _hx_string_or_null($tmp1), $p);
					$this->error($d);
					return $f;
				}
			}
		}
		return $this->fail("expected to throw exception but didn't", $p);
	}
	public function fail($message, $p = null) {
		if(_hx_field($this, "currentResult") === null) {
			$this->_openPreprocessResult();
		}
		$this->currentResult->failed = true;
		$i = $this->currentResult->status->length;
		$status = nanotest_NanoTestStatus::FAIL($message, $p);
		$this->currentResult->status->push($status);
		return new nanotest_NanoTestAssertResult($this->currentResult, $i);
	}
	public function success($p = null) {
		if(_hx_field($this, "currentResult") === null) {
			$this->_openPreprocessResult();
		}
		$i = $this->currentResult->status->length;
		$status = nanotest_NanoTestStatus::SUCCESS($p);
		$this->currentResult->status->push($status);
		return new nanotest_NanoTestAssertResult($this->currentResult, $i);
	}
	public function error($e) {
		if(_hx_field($this, "currentResult") === null) {
			$this->_openPreprocessResult();
		}
		$this->currentResult->failed = true;
		$this->currentResult->error = true;
		$message = Std::string($e);
		$i = $this->currentResult->status->length;
		$tmp = haxe_CallStack::exceptionStack();
		$status = nanotest_NanoTestStatus::ERROR($message, $tmp);
		$this->currentResult->status->push($status);
		return new nanotest_NanoTestAssertResult($this->currentResult, $i);
	}
	public function _openPreprocessResult() {
		$tmp = Type::getClass($this);
		$this->currentResult = _hx_anonymous(array("className" => Type::getClassName($tmp), "method" => null, "async" => true, "testCase" => $this, "error" => false, "failed" => false, "status" => (new _hx_array(array()))));
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $ASSERT_TRUE_ERROR = "expected true but was false";
	static $ASSERT_FALSE_ERROR = "expected false but was true";
	static $ASSERT_THROWS_ERROR = "expected to throw exception but didn't";
	static function ASSERT_THROWS_ILLEGAL_EXCEPTION($actual) {
		$tmp = nanotest_NanoTestCase::format($actual);
		return "catched illeagal exception " . _hx_string_or_null($tmp);
	}
	static function ASSERT_EQUALS_ERROR($expected, $actual) {
		$tmp = nanotest_NanoTestCase::format($expected);
		$tmp1 = "expected " . _hx_string_or_null($tmp) . " but was ";
		$tmp2 = nanotest_NanoTestCase::format($actual);
		return _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
	}
	static function ASSERT_NOT_EQUALS_ERROR($expected, $actual) {
		$tmp = nanotest_NanoTestCase::format($expected);
		$tmp1 = "expected not " . _hx_string_or_null($tmp) . " but was ";
		$tmp2 = nanotest_NanoTestCase::format($actual);
		return _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
	}
	static function format($d) {
		$tmp = Std::is($d, _hx_qtype("String"));
		if($tmp) {
			$tmp1 = Std::string($d);
			return "\"" . _hx_string_or_null($tmp1) . "\"";
		} else {
			$tmp2 = Std::string($d);
			return "" . _hx_string_or_null($tmp2);
		}
	}
	function __toString() { return 'nanotest.NanoTestCase'; }
}
function nanotest_NanoTestCase_0(&$_gthis, &$print, &$results) {
	{
		$tmp = $_gthis->currentResult->error;
		if($tmp) {
			call_user_func_array($print, array("E"));
		} else {
			$tmp1 = $_gthis->currentResult->failed;
			if($tmp1) {
				call_user_func_array($print, array("F"));
			} else {
				call_user_func_array($print, array("."));
			}
		}
		$results->push($_gthis->currentResult);
		$_gthis->currentResult = null;
	}
}
