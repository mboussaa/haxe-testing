<?php

// Generated by Haxe 3.3.0
class thx_color_parse_ColorParser {
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$this->pattern_color = new EReg("^\\s*([^(]+)\\s*\\(([^)]*)\\)\\s*\$", "i");
		$this->pattern_channel = new EReg("^\\s*(-?\\d*.\\d+|-?\\d+)(%|deg|rad)?\\s*\$", "i");
	}}
	public $pattern_color;
	public $pattern_channel;
	public function processHex($s) {
		$tmp = !thx_color_parse_ColorParser::$isPureHex->match($s);
		if($tmp) {
			$tmp1 = _hx_substr($s, 0, 1);
			if($tmp1 === "#") {
				$tmp2 = strlen($s) === 4;
				if($tmp2) {
					$tmp3 = _hx_char_at($s, 1);
					$tmp4 = _hx_char_at($s, 1);
					$tmp5 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
					$tmp6 = _hx_char_at($s, 2);
					$tmp7 = _hx_string_or_null($tmp5) . _hx_string_or_null($tmp6);
					$tmp8 = _hx_char_at($s, 2);
					$tmp9 = _hx_string_or_null($tmp7) . _hx_string_or_null($tmp8);
					$tmp10 = _hx_char_at($s, 3);
					$tmp11 = _hx_string_or_null($tmp9) . _hx_string_or_null($tmp10);
					$tmp12 = _hx_char_at($s, 3);
					$s = _hx_string_or_null($tmp11) . _hx_string_or_null($tmp12);
				} else {
					$tmp13 = strlen($s) === 5;
					if($tmp13) {
						$tmp14 = _hx_char_at($s, 1);
						$tmp15 = _hx_char_at($s, 1);
						$tmp16 = _hx_string_or_null($tmp14) . _hx_string_or_null($tmp15);
						$tmp17 = _hx_char_at($s, 2);
						$tmp18 = _hx_string_or_null($tmp16) . _hx_string_or_null($tmp17);
						$tmp19 = _hx_char_at($s, 2);
						$tmp20 = _hx_string_or_null($tmp18) . _hx_string_or_null($tmp19);
						$tmp21 = _hx_char_at($s, 3);
						$tmp22 = _hx_string_or_null($tmp20) . _hx_string_or_null($tmp21);
						$tmp23 = _hx_char_at($s, 3);
						$tmp24 = _hx_string_or_null($tmp22) . _hx_string_or_null($tmp23);
						$tmp25 = _hx_char_at($s, 4);
						$tmp26 = _hx_string_or_null($tmp24) . _hx_string_or_null($tmp25);
						$tmp27 = _hx_char_at($s, 4);
						$s = _hx_string_or_null($tmp26) . _hx_string_or_null($tmp27);
					} else {
						$s = _hx_substr($s, 1, null);
					}
				}
			} else {
				$tmp28 = _hx_substr($s, 0, 2);
				if($tmp28 === "0x") {
					$s = _hx_substr($s, 2, null);
				} else {
					return null;
				}
			}
		}
		$channels = (new _hx_array(array()));
		while(strlen($s) > 0) {
			$tmp29 = _hx_substr($s, 0, 2);
			$tmp30 = Std::parseInt("0x" . _hx_string_or_null($tmp29));
			$tmp31 = thx_color_parse_ChannelInfo::CIInt8($tmp30);
			$channels->push($tmp31);
			$s = _hx_substr($s, 2, null);
			unset($tmp31,$tmp30,$tmp29);
		}
		$tmp32 = $channels->length === 4;
		if($tmp32) {
			$tmp33 = $channels->slice(1, null)->concat((new _hx_array(array($channels[0]))));
			return new thx_color_parse_ColorInfo("rgba", $tmp33);
		} else {
			return new thx_color_parse_ColorInfo("rgb", $channels);
		}
	}
	public function processColor($s) {
		$tmp = !$this->pattern_color->match($s);
		if($tmp) {
			return null;
		}
		$name = $this->pattern_color->matched(1);
		if(null === $name) {
			return null;
		}
		$name = strtolower($name);
		$m2 = $this->pattern_color->matched(2);
		$s_channels = null;
		if(null === $m2) {
			$s_channels = (new _hx_array(array()));
		} else {
			$s_channels = _hx_explode(",", $m2);
		}
		$channels = (new _hx_array(array()));
		$channel = null;
		{
			$_g = 0;
			while($_g < $s_channels->length) {
				$s_channel = $s_channels[$_g];
				++$_g;
				$channel = $this->processChannel($s_channel);
				if(null === $channel) {
					return null;
				}
				$channels->push($channel);
				unset($s_channel);
			}
		}
		return new thx_color_parse_ColorInfo($name, $channels);
	}
	public function processChannel($s) {
		$tmp = !$this->pattern_channel->match($s);
		if($tmp) {
			return null;
		}
		$value = $this->pattern_channel->matched(1);
		$unit = $this->pattern_channel->matched(2);
		$tmp1 = $unit === null;
		if($tmp1) {
			$unit = "";
		}
		try {
			switch($unit) {
			case "":{
				$tmp2 = thx_Ints::parse($value, null);
				if($value === "" . _hx_string_rec($tmp2, "")) {
					$i = thx_Ints::parse($value, null);
					if($i === 0) {
						return thx_color_parse_ChannelInfo::CIBool(false);
					} else {
						if($i === 1) {
							return thx_color_parse_ChannelInfo::CIBool(true);
						} else {
							if($i < 256) {
								return thx_color_parse_ChannelInfo::CIInt8($i);
							} else {
								return thx_color_parse_ChannelInfo::CIInt($i);
							}
						}
					}
				} else {
					$tmp3 = thx_Floats::canParse($value);
					if($tmp3) {
						$tmp4 = thx_Floats::parse($value);
						return thx_color_parse_ChannelInfo::CIFloat($tmp4);
					} else {
						return null;
					}
				}
			}break;
			case "%":{
				$tmp5 = thx_Floats::canParse($value);
				if($tmp5) {
					$tmp6 = thx_Floats::parse($value);
					return thx_color_parse_ChannelInfo::CIPercent($tmp6);
				} else {
					return null;
				}
			}break;
			case "DEG":case "deg":{
				$tmp7 = thx_Floats::canParse($value);
				if($tmp7) {
					$tmp8 = thx_Floats::parse($value);
					return thx_color_parse_ChannelInfo::CIDegree($tmp8);
				} else {
					return null;
				}
			}break;
			case "RAD":case "rad":{
				$tmp9 = thx_Floats::canParse($value);
				if($tmp9) {
					$tmp10 = thx_Floats::parse($value);
					$tmp11 = $tmp10 * 180 / Math::$PI;
					return thx_color_parse_ChannelInfo::CIDegree($tmp11);
				} else {
					return null;
				}
			}break;
			default:{
				return null;
			}break;
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{
				return null;
			}
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $parser;
	static function parseColor($s) {
		return thx_color_parse_ColorParser::$parser->processColor($s);
	}
	static function parseHex($s) {
		return thx_color_parse_ColorParser::$parser->processHex($s);
	}
	static function parseChannel($s) {
		return thx_color_parse_ColorParser::$parser->processChannel($s);
	}
	static $isPureHex;
	static function getFloatChannels($channels, $length, $useInt8) {
		if($length !== $channels->length) {
			throw new HException("invalid number of channels, expected " . _hx_string_rec($length, "") . " but it is " . _hx_string_rec($channels->length, ""));
		}
		$a2 = $useInt8;
		return $channels->map(array(new _hx_lambda(array(&$a2), "thx_color_parse_ColorParser_0"), 'execute'));
	}
	static function getInt8Channels($channels, $length) {
		if($length !== $channels->length) {
			throw new HException("invalid number of channels, expected " . _hx_string_rec($length, "") . " but it is " . _hx_string_rec($channels->length, ""));
		}
		return $channels->map((isset(thx_color_parse_ColorParser::$getInt8Channel) ? thx_color_parse_ColorParser::$getInt8Channel: array("thx_color_parse_ColorParser", "getInt8Channel")));
	}
	static function getFloatChannel($channel, $useInt8 = null) {
		if($useInt8 === null) {
			$useInt8 = true;
		}
		switch($channel->index) {
		case 0:{
			return _hx_deref($channel)->params[0] / 100;
		}break;
		case 1:{
			return _hx_deref($channel)->params[0];
		}break;
		case 2:{
			return _hx_deref($channel)->params[0];
		}break;
		case 3:{
			$v = _hx_deref($channel)->params[0];
			if($useInt8) {
				return $v / 255;
			} else {
				return _hx_deref($channel)->params[0];
			}
		}break;
		case 4:{
			return _hx_deref($channel)->params[0];
		}break;
		case 5:{
			if(_hx_deref($channel)->params[0]) {
				return 1;
			} else {
				return 0;
			}
		}break;
		}
	}
	static function getInt8Channel($channel) {
		$tmp = $channel->index;
		switch($tmp) {
		case 0:{
			return Math::round(255 * _hx_deref($channel)->params[0] / 100);
		}break;
		case 3:{
			return _hx_deref($channel)->params[0];
		}break;
		case 5:{
			if(_hx_deref($channel)->params[0]) {
				return 1;
			} else {
				return 0;
			}
		}break;
		default:{
			throw new HException("unable to extract a valid int8 value");
		}break;
		}
	}
	function __toString() { return 'thx.color.parse.ColorParser'; }
}
thx_color_parse_ColorParser::$parser = new thx_color_parse_ColorParser();
thx_color_parse_ColorParser::$isPureHex = new EReg("^([0-9a-f]{2}){3,4}\$", "i");
function thx_color_parse_ColorParser_0(&$a2, $a1) {
	{
		return thx_color_parse_ColorParser::getFloatChannel($a1, $a2);
	}
}
