<?php

// Generated by Haxe 3.3.0
class utest_ui_text_HtmlReport implements utest_ui_common_IReport{
	public function __construct($runner, $outputHandler = null, $traceRedirected = null) {
		if(!php_Boot::$skip_constructor) {
		if($traceRedirected === null) {
			$traceRedirected = true;
		}
		$this->aggregator = new utest_ui_common_ResultAggregator($runner, true);
		$runner->onStart->add((isset($this->start) ? $this->start: array($this, "start")));
		$this->aggregator->onComplete->add((isset($this->complete) ? $this->complete: array($this, "complete")));
		if(null === $outputHandler) {
			$this->setHandler((isset($this->_handler) ? $this->_handler: array($this, "_handler")));
		} else {
			$this->setHandler($outputHandler);
		}
		if($traceRedirected) {
			$this->redirectTrace();
		}
		$this->displaySuccessResults = utest_ui_common_SuccessResultsDisplayMode::$AlwaysShowSuccessResults;
		$this->displayHeader = utest_ui_common_HeaderDisplayMode::$AlwaysShowHeader;
	}}
	public $traceRedirected;
	public $displaySuccessResults;
	public $displayHeader;
	public $handler;
	public $aggregator;
	public $oldTrace;
	public $_traces;
	public function setHandler($handler) {
		$this->handler = $handler;
	}
	public function redirectTrace() {
		if($this->traceRedirected) {
			return;
		}
		$this->_traces = (new _hx_array(array()));
		$this->oldTrace = (isset(haxe_Log::$trace) ? haxe_Log::$trace: array("haxe_Log", "trace"));
		haxe_Log::$trace = (isset($this->_trace) ? $this->_trace: array($this, "_trace"));
	}
	public function restoreTrace() {
		if(!$this->traceRedirected) {
			return;
		}
		haxe_Log::$trace = $this->oldTrace;
	}
	public $_traceTime;
	public function _trace($v, $infos = null) {
		$time = haxe_Timer::stamp();
		$delta = null;
		if($this->_traceTime === null) {
			$delta = 0;
		} else {
			$delta = $time - $this->_traceTime;
		}
		$tmp = Std::string($v);
		$tmp1 = StringTools::htmlEscape($tmp, null);
		$tmp2 = $time - $this->startTime;
		$tmp3 = haxe_CallStack::callStack();
		$this->_traces->push(_hx_anonymous(array("msg" => $tmp1, "infos" => $infos, "time" => $tmp2, "delta" => $delta, "stack" => $tmp3)));
		$this->_traceTime = haxe_Timer::stamp();
	}
	public $startTime;
	public function start($e) {
		$this->startTime = haxe_Timer::stamp();
	}
	public function cls($stats) {
		if($stats->hasErrors) {
			return "error";
		} else {
			if($stats->hasFailures) {
				return "failure";
			} else {
				if($stats->hasWarnings) {
					return "warn";
				} else {
					return "ok";
				}
			}
		}
	}
	public function resultNumbers($buf, $stats) {
		$numbers = (new _hx_array(array()));
		$tmp = $stats->assertations === 1;
		if($tmp) {
			$numbers->push("<strong>1</strong> test");
		} else {
			$tmp1 = "<strong>" . _hx_string_rec($stats->assertations, "") . "</strong> tests";
			$numbers->push($tmp1);
		}
		$tmp2 = $stats->successes !== $stats->assertations;
		if($tmp2) {
			$tmp3 = $stats->successes === 1;
			if($tmp3) {
				$numbers->push("<strong>1</strong> pass");
			} else {
				$tmp4 = $stats->successes > 0;
				if($tmp4) {
					$tmp5 = "<strong>" . _hx_string_rec($stats->successes, "") . "</strong> passes";
					$numbers->push($tmp5);
				}
			}
		}
		$tmp6 = $stats->errors === 1;
		if($tmp6) {
			$numbers->push("<strong>1</strong> error");
		} else {
			$tmp7 = $stats->errors > 0;
			if($tmp7) {
				$tmp8 = "<strong>" . _hx_string_rec($stats->errors, "") . "</strong> errors";
				$numbers->push($tmp8);
			}
		}
		$tmp9 = $stats->failures === 1;
		if($tmp9) {
			$numbers->push("<strong>1</strong> failure");
		} else {
			$tmp10 = $stats->failures > 0;
			if($tmp10) {
				$tmp11 = "<strong>" . _hx_string_rec($stats->failures, "") . "</strong> failures";
				$numbers->push($tmp11);
			}
		}
		$tmp12 = $stats->warnings === 1;
		if($tmp12) {
			$numbers->push("<strong>1</strong> warning");
		} else {
			$tmp13 = $stats->warnings > 0;
			if($tmp13) {
				$tmp14 = "<strong>" . _hx_string_rec($stats->warnings, "") . "</strong> warnings";
				$numbers->push($tmp14);
			}
		}
		$tmp15 = $numbers->join(", ");
		$buf->add($tmp15);
	}
	public function blockNumbers($buf, $stats) {
		$tmp = $this->cls($stats);
		$buf->add("<div class=\"" . _hx_string_or_null($tmp) . "bg statnumbers\">");
		$this->resultNumbers($buf, $stats);
		$buf->add("</div>");
	}
	public function formatStack($stack, $addNL = null) {
		if($addNL === null) {
			$addNL = true;
		}
		$parts = (new _hx_array(array()));
		$nl = null;
		if($addNL) {
			$nl = "\x0A";
		} else {
			$nl = "";
		}
		$last = null;
		$count = 1;
		{
			$_g = 0;
			$_g1 = _hx_explode("\x0A", haxe_CallStack::toString($stack));
			while($_g < $_g1->length) {
				$part = $_g1[$_g];
				++$_g;
				$tmp = trim($part);
				if($tmp === "") {
					continue;
				}
				$tmp1 = _hx_index_of($part, "Called from utest.", null);
				if(-1 < $tmp1) {
					continue;
				}
				if($part === $last) {
					$tmp2 = $parts->length - 1;
					$tmp3 = _hx_string_or_null($part) . " (#";
					$tmp4 = ++$count;
					$parts[$tmp2] = _hx_string_or_null($tmp3) . _hx_string_rec($tmp4, "") . ")";
					unset($tmp4,$tmp3,$tmp2);
				} else {
					$count = 1;
					$last = $part;
					$parts->push($last);
				}
				unset($tmp1,$tmp,$part);
			}
		}
		$tmp5 = $parts->join("</li>" . _hx_string_or_null($nl) . "<li>");
		return "<div>" . _hx_string_or_null(("<ul><li>" . _hx_string_or_null($tmp5) . "</li></ul>" . _hx_string_or_null($nl))) . "</div>" . _hx_string_or_null($nl);
	}
	public function addFixture($buf, $result, $name, $isOk) {
		if(utest_ui_common_ReportTools::skipResult($this, $result->stats, $isOk)) {
			return;
		}
		$buf->add("<li class=\"fixture\"><div class=\"li\">");
		$tmp = $this->cls($result->stats);
		$buf->add("<span class=\"" . _hx_string_or_null($tmp) . "bg fixtureresult\">");
		$tmp1 = $result->stats->isOk;
		if($tmp1) {
			$buf->add("OK ");
		} else {
			$tmp2 = $result->stats->hasErrors;
			if($tmp2) {
				$buf->add("ERROR ");
			} else {
				$tmp3 = $result->stats->hasFailures;
				if($tmp3) {
					$buf->add("FAILURE ");
				} else {
					$tmp4 = $result->stats->hasWarnings;
					if($tmp4) {
						$buf->add("WARNING ");
					}
				}
			}
		}
		$buf->add("</span>");
		$buf->add("<div class=\"fixturedetails\">");
		$buf->add("<strong>" . _hx_string_or_null($name) . "</strong>");
		$buf->add(": ");
		$this->resultNumbers($buf, $result->stats);
		$messages = (new _hx_array(array()));
		{
			$tmp5 = $result->iterator();
			while(true) {
				$tmp6 = !$tmp5->hasNext();
				if($tmp6) {
					break;
				}
				$assertation = $tmp5->next();
				$tmp7 = $assertation->index;
				switch($tmp7) {
				case 0:{}break;
				case 1:{
					$pos = _hx_deref($assertation)->params[1];
					$msg = _hx_deref($assertation)->params[0];
					$tmp8 = "<strong>line " . _hx_string_rec($pos->lineNumber, "") . "</strong>: <em>";
					$tmp9 = StringTools::htmlEscape($msg, null);
					$messages->push(_hx_string_or_null($tmp8) . _hx_string_or_null($tmp9) . "</em>");
				}break;
				case 2:{
					$s = _hx_deref($assertation)->params[1];
					$e = _hx_deref($assertation)->params[0];
					$tmp10 = $this->getErrorDescription($e);
					$tmp11 = "<strong>error</strong>: <em>" . _hx_string_or_null($tmp10) . "</em>\x0A<br/><strong>stack</strong>:";
					$tmp12 = $this->getErrorStack($s, $e);
					$messages->push(_hx_string_or_null($tmp11) . _hx_string_or_null($tmp12));
				}break;
				case 3:{
					$s1 = _hx_deref($assertation)->params[1];
					$e1 = _hx_deref($assertation)->params[0];
					$tmp13 = $this->getErrorDescription($e1);
					$tmp14 = "<strong>setup error</strong>: " . _hx_string_or_null($tmp13) . "\x0A<br/><strong>stack</strong>:";
					$tmp15 = $this->getErrorStack($s1, $e1);
					$messages->push(_hx_string_or_null($tmp14) . _hx_string_or_null($tmp15));
				}break;
				case 4:{
					$s2 = _hx_deref($assertation)->params[1];
					$e2 = _hx_deref($assertation)->params[0];
					$tmp16 = $this->getErrorDescription($e2);
					$tmp17 = "<strong>tear-down error</strong>: " . _hx_string_or_null($tmp16) . "\x0A<br/><strong>stack</strong>:";
					$tmp18 = $this->getErrorStack($s2, $e2);
					$messages->push(_hx_string_or_null($tmp17) . _hx_string_or_null($tmp18));
				}break;
				case 5:{
					$messages->push("<strong>missed async call(s)</strong>: " . _hx_string_rec(_hx_deref($assertation)->params[0], ""));
				}break;
				case 6:{
					$s3 = _hx_deref($assertation)->params[1];
					$e3 = _hx_deref($assertation)->params[0];
					$tmp19 = $this->getErrorDescription($e3);
					$tmp20 = "<strong>async error</strong>: " . _hx_string_or_null($tmp19) . "\x0A<br/><strong>stack</strong>:";
					$tmp21 = $this->getErrorStack($s3, $e3);
					$messages->push(_hx_string_or_null($tmp20) . _hx_string_or_null($tmp21));
				}break;
				case 7:{
					$tmp22 = StringTools::htmlEscape(_hx_deref($assertation)->params[0], null);
					$messages->push($tmp22);
				}break;
				}
				unset($tmp7,$tmp6,$assertation);
			}
		}
		$tmp23 = $messages->length > 0;
		if($tmp23) {
			$buf->add("<div class=\"testoutput\">");
			$tmp24 = $messages->join("<br/>");
			$buf->add($tmp24);
			$buf->add("</div>\x0A");
		}
		$buf->add("</div>\x0A");
		$buf->add("</div></li>\x0A");
	}
	public function getErrorDescription($e) {
		return Std::string($e);
	}
	public function getErrorStack($s, $e) {
		return $this->formatStack($s, null);
	}
	public function addClass($buf, $result, $name, $isOk) {
		if(utest_ui_common_ReportTools::skipResult($this, $result->stats, $isOk)) {
			return;
		}
		$buf->add("<li>");
		$buf->add("<h2 class=\"classname\">" . _hx_string_or_null($name) . "</h2>");
		$this->blockNumbers($buf, $result->stats);
		$buf->add("<ul>\x0A");
		{
			$_g = 0;
			$_g1 = $result->methodNames(null);
			while($_g < $_g1->length) {
				$mname = $_g1[$_g];
				++$_g;
				$tmp = $result->get($mname);
				$this->addFixture($buf, $tmp, $mname, $isOk);
				unset($tmp,$mname);
			}
		}
		$buf->add("</ul>\x0A");
		$buf->add("</li>\x0A");
	}
	public function addPackages($buf, $result, $isOk) {
		if(utest_ui_common_ReportTools::skipResult($this, $result->stats, $isOk)) {
			return;
		}
		$buf->add("<ul id=\"utest-results-packages\">\x0A");
		{
			$_g = 0;
			$_g1 = $result->packageNames(false);
			while($_g < $_g1->length) {
				$name = $_g1[$_g];
				++$_g;
				$tmp = $result->getPackage($name);
				$this->addPackage($buf, $tmp, $name, $isOk);
				unset($tmp,$name);
			}
		}
		$buf->add("</ul>\x0A");
	}
	public function addPackage($buf, $result, $name, $isOk) {
		if(utest_ui_common_ReportTools::skipResult($this, $result->stats, $isOk)) {
			return;
		}
		$tmp = null;
		if($name === "") {
			$tmp = $result->classNames(null)->length === 0;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return;
		}
		$buf->add("<li>");
		$buf->add("<h2>" . _hx_string_or_null($name) . "</h2>");
		$this->blockNumbers($buf, $result->stats);
		$buf->add("<ul>\x0A");
		{
			$_g = 0;
			$_g1 = $result->classNames(null);
			while($_g < $_g1->length) {
				$cname = $_g1[$_g];
				++$_g;
				$tmp1 = $result->getClass($cname);
				$this->addClass($buf, $tmp1, $cname, $isOk);
				unset($tmp1,$cname);
			}
		}
		$buf->add("</ul>\x0A");
		$buf->add("</li>\x0A");
	}
	public function getTextResults() {
		$newline = "\x0A";
		$indents = array(new _hx_lambda(array(), "utest_ui_text_HtmlReport_0"), 'execute');
		$dumpStack = array(new _hx_lambda(array(&$newline), "utest_ui_text_HtmlReport_1"), 'execute');
		$buf = new StringBuf();
		{
			$_g3 = 0;
			$_g11 = $this->result->packageNames(null);
			while($_g3 < $_g11->length) {
				$pname = $_g11[$_g3];
				++$_g3;
				$pack = $this->result->getPackage($pname);
				if(utest_ui_common_ReportTools::skipResult($this, $pack->stats, $this->result->stats->isOk)) {
					continue;
				}
				{
					$_g21 = 0;
					$_g31 = $pack->classNames(null);
					while($_g21 < $_g31->length) {
						$cname = $_g31[$_g21];
						++$_g21;
						$cls = $pack->getClass($cname);
						if(utest_ui_common_ReportTools::skipResult($this, $cls->stats, $this->result->stats->isOk)) {
							continue;
						}
						$tmp1 = null;
						if($pname === "") {
							$tmp1 = "";
						} else {
							$tmp1 = _hx_string_or_null($pname) . ".";
						}
						$buf->add(_hx_string_or_null($tmp1) . _hx_string_or_null($cname) . _hx_string_or_null($newline));
						{
							$_g4 = 0;
							$_g5 = $cls->methodNames(null);
							while($_g4 < $_g5->length) {
								$mname = $_g5[$_g4];
								++$_g4;
								$fix = $cls->get($mname);
								if(utest_ui_common_ReportTools::skipResult($this, $fix->stats, $this->result->stats->isOk)) {
									continue;
								}
								$tmp2 = call_user_func_array($indents, array(1));
								$buf->add(_hx_string_or_null($tmp2) . _hx_string_or_null($mname) . ": ");
								$tmp3 = $fix->stats->isOk;
								if($tmp3) {
									$buf->add("OK ");
								} else {
									$tmp4 = $fix->stats->hasErrors;
									if($tmp4) {
										$buf->add("ERROR ");
									} else {
										$tmp5 = $fix->stats->hasFailures;
										if($tmp5) {
											$buf->add("FAILURE ");
										} else {
											$tmp6 = $fix->stats->hasWarnings;
											if($tmp6) {
												$buf->add("WARNING ");
											}
											unset($tmp6);
										}
										unset($tmp5);
									}
									unset($tmp4);
								}
								$messages = "";
								{
									$tmp7 = $fix->iterator();
									while(true) {
										$tmp8 = !$tmp7->hasNext();
										if($tmp8) {
											break;
										}
										$assertation = $tmp7->next();
										$tmp9 = $assertation->index;
										switch($tmp9) {
										case 0:{
											$buf->add(".");
										}break;
										case 1:{
											$buf->add("F");
											$tmp10 = call_user_func_array($indents, array(2));
											$messages .= _hx_string_or_null($tmp10) . "line: " . _hx_string_rec(_hx_deref($assertation)->params[1]->lineNumber, "") . ", " . _hx_string_or_null(_hx_deref($assertation)->params[0]) . _hx_string_or_null($newline);
										}break;
										case 2:{
											$buf->add("E");
											$tmp11 = call_user_func_array($indents, array(2));
											$tmp12 = Std::string(_hx_deref($assertation)->params[0]);
											$tmp13 = _hx_string_or_null($tmp11) . _hx_string_or_null($tmp12);
											$tmp14 = call_user_func_array($dumpStack, array(_hx_deref($assertation)->params[1]));
											$messages .= _hx_string_or_null($tmp13) . _hx_string_or_null($tmp14) . _hx_string_or_null($newline);
										}break;
										case 3:{
											$buf->add("S");
											$tmp15 = call_user_func_array($indents, array(2));
											$tmp16 = Std::string(_hx_deref($assertation)->params[0]);
											$tmp17 = _hx_string_or_null($tmp15) . _hx_string_or_null($tmp16);
											$tmp18 = call_user_func_array($dumpStack, array(_hx_deref($assertation)->params[1]));
											$messages .= _hx_string_or_null($tmp17) . _hx_string_or_null($tmp18) . _hx_string_or_null($newline);
										}break;
										case 4:{
											$buf->add("T");
											$tmp19 = call_user_func_array($indents, array(2));
											$tmp20 = Std::string(_hx_deref($assertation)->params[0]);
											$tmp21 = _hx_string_or_null($tmp19) . _hx_string_or_null($tmp20);
											$tmp22 = call_user_func_array($dumpStack, array(_hx_deref($assertation)->params[1]));
											$messages .= _hx_string_or_null($tmp21) . _hx_string_or_null($tmp22) . _hx_string_or_null($newline);
										}break;
										case 5:{
											$buf->add("O");
											$tmp23 = call_user_func_array($indents, array(2));
											$tmp24 = _hx_string_or_null($tmp23) . "missed async calls: " . _hx_string_rec(_hx_deref($assertation)->params[0], "");
											$tmp25 = call_user_func_array($dumpStack, array(_hx_deref($assertation)->params[1]));
											$messages .= _hx_string_or_null($tmp24) . _hx_string_or_null($tmp25) . _hx_string_or_null($newline);
										}break;
										case 6:{
											$buf->add("A");
											$tmp26 = call_user_func_array($indents, array(2));
											$tmp27 = Std::string(_hx_deref($assertation)->params[0]);
											$tmp28 = _hx_string_or_null($tmp26) . _hx_string_or_null($tmp27);
											$tmp29 = call_user_func_array($dumpStack, array(_hx_deref($assertation)->params[1]));
											$messages .= _hx_string_or_null($tmp28) . _hx_string_or_null($tmp29) . _hx_string_or_null($newline);
										}break;
										case 7:{
											$buf->add("W");
											$tmp30 = call_user_func_array($indents, array(2));
											$messages .= _hx_string_or_null($tmp30) . _hx_string_or_null(_hx_deref($assertation)->params[0]) . _hx_string_or_null($newline);
										}break;
										}
										unset($tmp9,$tmp8,$assertation);
									}
									unset($tmp7);
								}
								$buf->add($newline);
								$buf->add($messages);
								unset($tmp3,$tmp2,$mname,$messages,$fix);
							}
							unset($_g5,$_g4);
						}
						unset($tmp1,$cname,$cls);
					}
					unset($_g31,$_g21);
				}
				unset($pname,$pack);
			}
		}
		return $buf->b;
	}
	public function getHeader() {
		$buf = new StringBuf();
		if(!utest_ui_common_ReportTools::hasHeader($this, $this->result->stats)) {
			return "";
		}
		$end = haxe_Timer::stamp();
		$tmp = ($end - $this->startTime) * 1000;
		$tmp1 = Std::int($tmp);
		$time = $tmp1 / 1000;
		$msg = "TEST OK";
		if($this->result->stats->hasErrors) {
			$msg = "TEST ERRORS";
		} else {
			if($this->result->stats->hasFailures) {
				$msg = "TEST FAILED";
			} else {
				if($this->result->stats->hasWarnings) {
					$msg = "WARNING REPORTED";
				}
			}
		}
		$tmp2 = $this->cls($this->result->stats);
		$buf->add("<h1 class=\"" . _hx_string_or_null($tmp2) . "bg header\">" . _hx_string_or_null($msg) . "</h1>\x0A");
		$buf->add("<div class=\"headerinfo\">");
		$this->resultNumbers($buf, $this->result->stats);
		$buf->add(" performed on <strong>" . _hx_string_or_null(utest_ui_text_HtmlReport::$platform) . "</strong>, executed in <strong> " . _hx_string_rec($time, "") . " sec. </strong></div >\x0A ");
		return $buf->b;
	}
	public function getTrace() {
		$buf = new StringBuf();
		$tmp = null;
		if($this->_traces !== null) {
			$tmp = $this->_traces->length === 0;
		} else {
			$tmp = true;
		}
		if($tmp) {
			return "";
		}
		$buf->add("<div class=\"trace\"><h2>traces</h2><ol>");
		{
			$_g = 0;
			$_g1 = $this->_traces;
			while($_g < $_g1->length) {
				$t = $_g1[$_g];
				++$_g;
				$buf->add("<li><div class=\"li\">");
				$s = $this->formatStack($t->stack, false);
				$stack = str_replace("'", "\\'", $s);
				$method = "<span class=\"tracepackage\">" . _hx_string_or_null($t->infos->className) . "</span><br/>" . _hx_string_or_null($t->infos->methodName) . "(" . _hx_string_rec($t->infos->lineNumber, "") . ")";
				$buf->add("<span class=\"tracepos\" onmouseover=\"utestTooltip(this.parentNode, '" . _hx_string_or_null($stack) . "')\" onmouseout=\"utestRemoveTooltip()\">");
				$buf->add($method);
				$buf->add("</span><span class=\"tracetime\">");
				$tmp1 = $this->formatTime($t->time);
				$buf->add("@ " . _hx_string_or_null($tmp1));
				$tmp2 = $t->delta * 1000;
				$tmp3 = Math::round($tmp2);
				if($tmp3 > 0) {
					$tmp4 = $this->formatTime($t->delta);
					$buf->add(", ~" . _hx_string_or_null($tmp4));
					unset($tmp4);
				}
				$buf->add("</span><span class=\"tracemsg\">");
				$s1 = trim($t->msg);
				$tmp5 = str_replace("\x0A", "<br/>\x0A", $s1);
				$buf->add($tmp5);
				$buf->add("</span><div class=\"clr\"></div></div></li>");
				unset($tmp5,$tmp3,$tmp2,$tmp1,$t,$stack,$s1,$s,$method);
			}
		}
		$buf->add("</ol></div>");
		return $buf->b;
	}
	public function getResults() {
		$buf = new StringBuf();
		$this->addPackages($buf, $this->result, $this->result->stats->isOk);
		return $buf->b;
	}
	public function getAll() {
		if(!utest_ui_common_ReportTools::hasOutput($this, $this->result->stats)) {
			return "";
		} else {
			$tmp = $this->getHeader();
			$tmp1 = $this->getTrace();
			$tmp2 = _hx_string_or_null($tmp) . _hx_string_or_null($tmp1);
			$tmp3 = $this->getResults();
			return _hx_string_or_null($tmp2) . _hx_string_or_null($tmp3);
		}
	}
	public function getHtml($title = null) {
		$tmp = null === $title;
		if($tmp) {
			$title = "utest: " . _hx_string_or_null(utest_ui_text_HtmlReport::$platform);
		}
		$s = $this->getAll();
		if("" === $s) {
			return "";
		} else {
			return $this->wrapHtml($title, $s);
		}
	}
	public $result;
	public function complete($result) {
		$this->result = $result;
		$this->handler($this);
		$this->restoreTrace();
		$this->getTextResults();
	}
	public function formatTime($t) {
		$tmp = Math::round($t * 1000);
		return _hx_string_rec($tmp, "") . " ms";
	}
	public function cssStyle() {
		return "body, dd, dt {\x0A  font-family: Verdana, Arial, Sans-serif;\x0A  font-size: 12px;\x0A}\x0Adl {\x0A  width: 180px;\x0A}\x0Add, dt {\x0A  margin : 0;\x0A  padding : 2px 5px;\x0A  border-top: 1px solid #f0f0f0;\x0A  border-left: 1px solid #f0f0f0;\x0A  border-right: 1px solid #CCCCCC;\x0A  border-bottom: 1px solid #CCCCCC;\x0A}\x0Add.value {\x0A  text-align: center;\x0A  background-color: #eeeeee;\x0A}\x0Adt {\x0A  text-align: left;\x0A  background-color: #e6e6e6;\x0A  float: left;\x0A  width: 100px;\x0A}\x0A\x0Ah1, h2, h3, h4, h5, h6 {\x0A  margin: 0;\x0A  padding: 0;\x0A}\x0A\x0Ah1 {\x0A  text-align: center;\x0A  font-weight: bold;\x0A  padding: 5px 0 4px 0;\x0A  font-family: Arial, Sans-serif;\x0A  font-size: 18px;\x0A  border-top: 1px solid #f0f0f0;\x0A  border-left: 1px solid #f0f0f0;\x0A  border-right: 1px solid #CCCCCC;\x0A  border-bottom: 1px solid #CCCCCC;\x0A  margin: 0 2px 0px 2px;\x0A}\x0A\x0Ah2 {\x0A  font-weight: bold;\x0A  padding: 2px 0 2px 8px;\x0A  font-family: Arial, Sans-serif;\x0A  font-size: 13px;\x0A  border-top: 1px solid #f0f0f0;\x0A  border-left: 1px solid #f0f0f0;\x0A  border-right: 1px solid #CCCCCC;\x0A  border-bottom: 1px solid #CCCCCC;\x0A  margin: 0 0 0px 0;\x0A  background-color: #FFFFFF;\x0A  color: #777777;\x0A}\x0A\x0Ah2.classname {\x0A  color: #000000;\x0A}\x0A\x0A.okbg {\x0A  background-color: #66FF55;\x0A}\x0A.errorbg {\x0A  background-color: #CC1100;\x0A}\x0A.failurebg {\x0A  background-color: #EE3322;\x0A}\x0A.warnbg {\x0A  background-color: #FFCC99;\x0A}\x0A.headerinfo {\x0A  text-align: right;\x0A  font-size: 11px;\x0A  font - color: 0xCCCCCC;\x0A  margin: 0 2px 5px 2px;\x0A  border-left: 1px solid #f0f0f0;\x0A  border-right: 1px solid #CCCCCC;\x0A  border-bottom: 1px solid #CCCCCC;\x0A  padding: 2px;\x0A}\x0A\x0Ali {\x0A  padding: 4px;\x0A  margin: 2px;\x0A  border-top: 1px solid #f0f0f0;\x0A  border-left: 1px solid #f0f0f0;\x0A  border-right: 1px solid #CCCCCC;\x0A  border-bottom: 1px solid #CCCCCC;\x0A  background-color: #e6e6e6;\x0A}\x0A\x0Ali.fixture {\x0A  background-color: #f6f6f6;\x0A  padding-bottom: 6px;\x0A}\x0A\x0Adiv.fixturedetails {\x0A  padding-left: 108px;\x0A}\x0A\x0Aul {\x0A  padding: 0;\x0A  margin: 6px 0 0 0;\x0A  list-style-type: none;\x0A}\x0A\x0Aol {\x0A  padding: 0 0 0 28px;\x0A  margin: 0px 0 0 0;\x0A}\x0A\x0A.statnumbers {\x0A  padding: 2px 8px;\x0A}\x0A\x0A.fixtureresult {\x0A  width: 100px;\x0A  text-align: center;\x0A  display: block;\x0A  float: left;\x0A  font-weight: bold;\x0A  padding: 1px;\x0A  margin: 0 0 0 0;\x0A}\x0A\x0A.testoutput {\x0A  border: 1px dashed #CCCCCC;\x0A  margin: 4px 0 0 0;\x0A  padding: 4px 8px;\x0A  background-color: #eeeeee;\x0A}\x0A\x0Aspan.tracepos, span.traceposempty {\x0A  display: block;\x0A  float: left;\x0A  font-weight: bold;\x0A  font-size: 9px;\x0A  width: 170px;\x0A  margin: 2px 0 0 2px;\x0A}\x0A\x0Aspan.tracepos:hover {\x0A  cursor : pointer;\x0A  background-color: #ffff99;\x0A}\x0A\x0Aspan.tracemsg {\x0A  display: block;\x0A  margin-left: 180px;\x0A  background-color: #eeeeee;\x0A  padding: 7px;\x0A}\x0A\x0Aspan.tracetime {\x0A  display: block;\x0A  float: right;\x0A  margin: 2px;\x0A  font-size: 9px;\x0A  color: #777777;\x0A}\x0A\x0A\x0Adiv.trace ol {\x0A  padding: 0 0 0 40px;\x0A  color: #777777;\x0A}\x0A\x0Adiv.trace li {\x0A  padding: 0;\x0A}\x0A\x0Adiv.trace li div.li {\x0A  color: #000000;\x0A}\x0A\x0Adiv.trace h2 {\x0A  margin: 0 2px 0px 2px;\x0A  padding-left: 4px;\x0A}\x0A\x0A.tracepackage {\x0A  color: #777777;\x0A  font-weight: normal;\x0A}\x0A\x0A.clr {\x0A  clear: both;\x0A}\x0A\x0A#utesttip {\x0A  margin-top: -3px;\x0A  margin-left: 170px;\x0A  font-size: 9px;\x0A}\x0A\x0A#utesttip li {\x0A  margin: 0;\x0A  background-color: #ffff99;\x0A  padding: 2px 4px;\x0A  border: 0;\x0A  border-bottom: 1px dashed #ffff33;\x0A}";
	}
	public function jsScript() {
		return "function utestTooltip(ref, text) {\x0A  var el = document.getElementById(\"utesttip\");\x0A  if(!el) {\x0A    var el = document.createElement(\"div\")\x0A    el.id = \"utesttip\";\x0A    el.style.position = \"absolute\";\x0A    document.body.appendChild(el)\x0A  }\x0A  var p = utestFindPos(ref);\x0A  el.style.left = (4 + p[0]) + \"px\";\x0A  el.style.top = (p[1] - 1) + \"px\";\x0A  el.innerHTML =  text;\x0A}\x0A\x0Afunction utestFindPos(el) {\x0A  var left = 0;\x0A  var top = 0;\x0A  do {\x0A    left += el.offsetLeft;\x0A    top += el.offsetTop;\x0A  } while(el = el.offsetParent)\x0A  return [left, top];\x0A}\x0A\x0Afunction utestRemoveTooltip() {\x0A  var el = document.getElementById(\"utesttip\")\x0A  if(el)\x0A    document.body.removeChild(el)\x0A}";
	}
	public function wrapHtml($title, $s) {
		$tmp = "<head>\x0A<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />\x0A<title>" . _hx_string_or_null($title) . "</title>\x0A      <style type=\"text/css\">";
		$tmp1 = $this->cssStyle();
		$tmp2 = _hx_string_or_null($tmp) . _hx_string_or_null($tmp1) . "</style>\x0A      <script type=\"text/javascript\">\x0A";
		$tmp3 = $this->jsScript();
		return _hx_string_or_null($tmp2) . _hx_string_or_null($tmp3) . "\x0A</" . "script>\x0A</head>\x0A      <body>\x0A" . _hx_string_or_null($s) . "\x0A</body>\x0A</html>";
	}
	public function _handler($report) {
		$tmp = $report->getHtml(null);
		php_Lib::hprint($tmp);
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $platform = "php";
	function __toString() { return 'utest.ui.text.HtmlReport'; }
}
function utest_ui_text_HtmlReport_0($count) {
	{
		$_g = (new _hx_array(array()));
		{
			$_g2 = 0;
			while($_g2 < $count) {
				++$_g2;
				$_g->push("  ");
			}
		}
		return $_g->join("");
	}
}
function utest_ui_text_HtmlReport_1(&$newline, $stack) {
	{
		if($stack->length === 0) {
			return "";
		}
		$parts = _hx_explode("\x0A", haxe_CallStack::toString($stack));
		$r = (new _hx_array(array()));
		{
			$_g1 = 0;
			while($_g1 < $parts->length) {
				$part = $parts[$_g1];
				++$_g1;
				$tmp = _hx_index_of($part, " utest.", null);
				if($tmp >= 0) {
					continue;
				}
				$r->push($part);
				unset($tmp,$part);
			}
		}
		return $r->join($newline);
	}
}
