<?php

// Generated by Haxe 3.3.0
class thx_Strings {
	public function __construct(){}
	static function after($value, $searchFor) {
		$pos = _hx_index_of($value, $searchFor, null);
		if($pos < 0) {
			return "";
		} else {
			$tmp = $pos + strlen($searchFor);
			return _hx_substring($value, $tmp, null);
		}
	}
	static function afterLast($value, $searchFor) {
		$pos = _hx_last_index_of($value, $searchFor, null);
		if($pos < 0) {
			return "";
		} else {
			$tmp = $pos + strlen($searchFor);
			return _hx_substring($value, $tmp, null);
		}
	}
	static function capitalize($s) {
		$tmp = strtoupper(haxe_Utf8::sub($s, 0, 1));
		$tmp1 = haxe_Utf8::length($s);
		$tmp2 = haxe_Utf8::sub($s, 1, $tmp1 - 1);
		return _hx_string_or_null($tmp) . _hx_string_or_null($tmp2);
	}
	static function capitalizeWords($value, $whiteSpaceOnly = null) {
		if($whiteSpaceOnly === null) {
			$whiteSpaceOnly = false;
		}
		if($whiteSpaceOnly) {
			return ucwords($value);
		} else {
			$tmp = strtoupper(haxe_Utf8::sub($value, 0, 1));
			$tmp1 = haxe_Utf8::length($value);
			$tmp2 = haxe_Utf8::sub($value, 1, $tmp1 - 1);
			return thx_Strings::$UCWORDS->map(_hx_string_or_null($tmp) . _hx_string_or_null($tmp2), (isset(thx_Strings::$upperMatch) ? thx_Strings::$upperMatch: array("thx_Strings", "upperMatch")));
		}
	}
	static function canonicalizeNewlines($value) {
		return thx_Strings::$CANONICALIZE_LINES->replace($value, "\x0A");
	}
	static function caseInsensitiveCompare($a, $b) {
		$tmp = null;
		if(null === $a) {
			$tmp = null === $b;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return 0;
		}
		if(null === $a) {
			return -1;
		} else {
			if(null === $b) {
				return 1;
			}
		}
		$a1 = strtolower($a);
		$b1 = strtolower($b);
		return haxe_Utf8::compare($a1, $b1);
	}
	static function caseInsensitiveEndsWith($s, $end) {
		$tmp = strtolower($s);
		$tmp1 = strtolower($end);
		return StringTools::endsWith($tmp, $tmp1);
	}
	static function caseInsensitiveEndsWithAny($s, $values) {
		$tmp = strtolower($s);
		$tmp1 = $values->map(array(new _hx_lambda(array(), "thx_Strings_0"), 'execute'));
		return thx_Strings::endsWithAny($tmp, $tmp1);
	}
	static function caseInsensitiveStartsWith($s, $start) {
		$tmp = strtolower($s);
		$tmp1 = strtolower($start);
		return StringTools::startsWith($tmp, $tmp1);
	}
	static function caseInsensitiveStartsWithAny($s, $values) {
		$tmp = strtolower($s);
		$tmp1 = $values->map(array(new _hx_lambda(array(), "thx_Strings_1"), 'execute'));
		return thx_Strings::startsWithAny($tmp, $tmp1);
	}
	static function collapse($value) {
		$tmp = trim($value);
		return thx_Strings::$WSG->replace($tmp, " ");
	}
	static function compare($a, $b) {
		return haxe_Utf8::compare($a, $b);
	}
	static function order() { $args = func_get_args(); return call_user_func_array(self::$order, $args); }
	static $order;
	static function caseInsensitiveContains($s, $test) {
		if($test !== "") {
			$tmp = strtolower($s);
			$tmp1 = strtolower($test);
			$tmp2 = _hx_index_of($tmp, $tmp1, null);
			return $tmp2 >= 0;
		} else {
			return true;
		}
	}
	static function contains($s, $test) {
		if($test !== "") {
			$tmp = _hx_index_of($s, $test, null);
			return $tmp >= 0;
		} else {
			return true;
		}
	}
	static function count($s, $test) {
		return _hx_explode($test, $s)->length - 1;
	}
	static function caseInsensitiveContainsAny($s, $tests) {
		$s1 = $s;
		$tmp = array(new _hx_lambda(array(&$s1), "thx_Strings_2"), 'execute');
		return thx_Arrays::any($tests, $tmp);
	}
	static function containsAny($s, $tests) {
		$s1 = $s;
		$tmp = array(new _hx_lambda(array(&$s1), "thx_Strings_3"), 'execute');
		return thx_Arrays::any($tests, $tmp);
	}
	static function dasherize($s) {
		return str_replace("_", "-", $s);
	}
	static function diffAt($a, $b) {
		$a1 = strlen($a);
		$b1 = strlen($b);
		$min = null;
		if($a1 < $b1) {
			$min = $a1;
		} else {
			$min = $b1;
		}
		{
			$_g1 = 0;
			$_g = $min;
			while($_g1 < $_g) {
				$i = $_g1++;
				$tmp = _hx_substring($a, $i, $i + 1);
				$tmp1 = _hx_substring($b, $i, $i + 1);
				if($tmp !== $tmp1) {
					return $i;
				}
				unset($tmp1,$tmp,$i);
			}
		}
		return $min;
	}
	static function ellipsis($s, $maxlen = null, $symbol = null) {
		if($symbol === null) {
			$symbol = "…";
		}
		if($maxlen === null) {
			$maxlen = 20;
		}
		$sl = haxe_Utf8::length($s);
		$symboll = haxe_Utf8::length($symbol);
		if($sl > $maxlen) {
			if($maxlen < $symboll) {
				return haxe_Utf8::sub($symbol, $symboll - $maxlen, $maxlen);
			} else {
				$tmp = haxe_Utf8::sub($s, 0, $maxlen - $symboll);
				return _hx_string_or_null($tmp) . _hx_string_or_null($symbol);
			}
		} else {
			return $s;
		}
	}
	static function ellipsisMiddle($s, $maxlen = null, $symbol = null) {
		if($symbol === null) {
			$symbol = "…";
		}
		if($maxlen === null) {
			$maxlen = 20;
		}
		$sl = haxe_Utf8::length($s);
		$symboll = haxe_Utf8::length($symbol);
		if($sl > $maxlen) {
			if($maxlen <= $symboll) {
				return thx_Strings::ellipsis($s, $maxlen, $symbol);
			}
			$hll = Math::ceil(($maxlen - $symboll) / 2);
			$hlr = Math::floor(($maxlen - $symboll) / 2);
			$tmp = haxe_Utf8::sub($s, 0, $hll);
			$tmp1 = _hx_string_or_null($tmp) . _hx_string_or_null($symbol);
			$tmp2 = haxe_Utf8::sub($s, $sl - $hlr, $hlr);
			return _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
		} else {
			return $s;
		}
	}
	static function endsWithAny($s, $values) {
		return thx_Iterables::any($values, array(new _hx_lambda(array(&$s), "thx_Strings_4"), 'execute'));
	}
	static function filter($s, $predicate) {
		return thx_Strings::toArray($s)->filter($predicate)->join("");
	}
	static function filterCharcode($s, $predicate) {
		$codes = thx_Strings::map($s, array(new _hx_lambda(array(), "thx_Strings_5"), 'execute'))->filter($predicate);
		return $codes->map(array(new _hx_lambda(array(), "thx_Strings_6"), 'execute'))->join("");
	}
	static function from($value, $searchFor) {
		$pos = _hx_index_of($value, $searchFor, null);
		if($pos < 0) {
			return "";
		} else {
			return _hx_substring($value, $pos, null);
		}
	}
	static $HASCODE_MAX;
	static $HASCODE_MUL;
	static function hashCode($value) {
		$code = 0;
		{
			$_g1 = 0;
			$_g = strlen($value);
			while($_g1 < $_g) {
				$i = $_g1++;
				$c = _hx_char_code_at($value, $i);
				$tmp = haxe__Int32_Int32_Impl_::mul(thx_Strings::$HASCODE_MUL, $code) + $c << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$code = _hx_mod($tmp, thx_Strings::$HASCODE_MAX);
				unset($tmp,$i,$c);
			}
		}
		return $code;
	}
	static function hasContent($value) {
		if($value !== null) {
			return strlen($value) > 0;
		} else {
			return false;
		}
	}
	static function humanize($s) {
		$s1 = thx_Strings::underscore($s);
		return str_replace("_", " ", $s1);
	}
	static function isAlpha($s) {
		$tmp = strlen($s) > 0;
		if($tmp) {
			return !thx_Strings::$IS_ALPHA->match($s);
		} else {
			return false;
		}
	}
	static function isAlphaNum($value) {
		return ctype_alnum($value);
	}
	static function isBreakingWhitespace($value) {
		return !thx_Strings::$IS_BREAKINGWHITESPACE->match($value);
	}
	static function isLowerCase($value) {
		$tmp = strtolower($value);
		return $tmp === $value;
	}
	static function isUpperCase($value) {
		$tmp = strtoupper($value);
		return $tmp === $value;
	}
	static function ifEmpty($value, $alt) {
		$tmp = null;
		if(null !== $value) {
			$tmp = "" !== $value;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return $value;
		} else {
			return $alt;
		}
	}
	static function isDigitsOnly($value) {
		return ctype_digit($value);
	}
	static function isEmpty($value) {
		if($value !== null) {
			return $value === "";
		} else {
			return true;
		}
	}
	static function lowerCaseFirst($value) {
		$tmp = strtolower(_hx_substring($value, 0, 1));
		$tmp1 = _hx_substring($value, 1, null);
		return _hx_string_or_null($tmp) . _hx_string_or_null($tmp1);
	}
	static function random($value, $length = null) {
		if($length === null) {
			$length = 1;
		}
		$tmp = haxe_Utf8::length($value);
		$tmp1 = $tmp - $length + 1;
		$tmp2 = Math::random();
		$tmp3 = Math::floor($tmp1 * $tmp2);
		return haxe_Utf8::sub($value, $tmp3, $length);
	}
	static function randomSequence($seed, $length) {
		return thx_Ints::range(0, $length, null)->map(array(new _hx_lambda(array(&$seed), "thx_Strings_7"), 'execute'))->join("");
	}
	static function randomSequence64($length) {
		return thx_Strings::randomSequence(haxe_crypto_Base64::$CHARS, $length);
	}
	static function iterator($s) {
		return thx_Strings::toArray($s)->iterator();
	}
	static function map($value, $callback) {
		return thx_Strings::toArray($value)->map($callback);
	}
	static function remove($value, $toremove) {
		if($toremove === "") {
			return implode(str_split ($value), "");
		} else {
			return str_replace($toremove, "", $value);
		}
	}
	static function removeAfter($value, $toremove) {
		$tmp = StringTools::endsWith($value, $toremove);
		if($tmp) {
			$tmp1 = strlen($value) - strlen($toremove);
			return _hx_substring($value, 0, $tmp1);
		} else {
			return $value;
		}
	}
	static function removeAt($value, $index, $length) {
		$tmp = _hx_substring($value, 0, $index);
		$tmp1 = _hx_substring($value, $index + $length, null);
		return _hx_string_or_null($tmp) . _hx_string_or_null($tmp1);
	}
	static function removeBefore($value, $toremove) {
		$tmp = StringTools::startsWith($value, $toremove);
		if($tmp) {
			return _hx_substring($value, strlen($toremove), null);
		} else {
			return $value;
		}
	}
	static function removeOne($value, $toremove) {
		$pos = _hx_index_of($value, $toremove, null);
		if($pos < 0) {
			return $value;
		}
		$tmp = _hx_substring($value, 0, $pos);
		$tmp1 = $pos + strlen($toremove);
		$tmp2 = _hx_substring($value, $tmp1, null);
		return _hx_string_or_null($tmp) . _hx_string_or_null($tmp2);
	}
	static function repeat($s, $times) {
		$_g = (new _hx_array(array()));
		{
			$_g2 = 0;
			while($_g2 < $times) {
				++$_g2;
				$_g->push($s);
			}
		}
		return $_g->join("");
	}
	static function reverse($s) {
		$arr = thx_Strings::toArray($s);
		$arr->reverse();
		return $arr->join("");
	}
	static function quote($s) {
		$tmp = _hx_index_of($s, "\"", null);
		if($tmp < 0) {
			return "\"" . _hx_string_or_null($s) . "\"";
		} else {
			$tmp1 = _hx_index_of($s, "'", null);
			if($tmp1 < 0) {
				return "'" . _hx_string_or_null($s) . "'";
			} else {
				$tmp2 = str_replace("\"", "\\\"", $s);
				return "\"" . _hx_string_or_null($tmp2) . "\"";
			}
		}
	}
	static function splitOnce($s, $separator) {
		$pos = _hx_index_of($s, $separator, null);
		if($pos < 0) {
			return (new _hx_array(array($s)));
		}
		$tmp = _hx_substring($s, 0, $pos);
		$tmp1 = $pos + strlen($separator);
		$tmp2 = _hx_substring($s, $tmp1, null);
		return (new _hx_array(array($tmp, $tmp2)));
	}
	static function startsWithAny($s, $values) {
		return thx_Iterables::any($values, array(new _hx_lambda(array(&$s), "thx_Strings_8"), 'execute'));
	}
	static function stripTags($s) {
		return strip_tags($s);
	}
	static function surround($s, $left, $right = null) {
		$tmp = "" . _hx_string_or_null($left) . _hx_string_or_null($s);
		$tmp1 = null;
		if(null === $right) {
			$tmp1 = $left;
		} else {
			$tmp1 = $right;
		}
		return _hx_string_or_null($tmp) . _hx_string_or_null($tmp1);
	}
	static function toArray($s) {
		$arr = (new _hx_array(array()));
		{
			$_g1 = 0;
			$_g = haxe_Utf8::length($s);
			while($_g1 < $_g) {
				$i = $_g1++;
				$tmp = haxe_Utf8::sub($s, $i, 1);
				$arr->push($tmp);
				unset($tmp,$i);
			}
		}
		return $arr;
	}
	static function toCharcodes($s) {
		return thx_Strings::map($s, array(new _hx_lambda(array(), "thx_Strings_9"), 'execute'));
	}
	static function toChunks($s, $len) {
		$chunks = (new _hx_array(array()));
		while(true) {
			$tmp = haxe_Utf8::length($s);
			if(!($tmp > 0)) {
				break;
			}
			$tmp1 = haxe_Utf8::sub($s, 0, $len);
			$chunks->push($tmp1);
			$tmp2 = haxe_Utf8::length($s);
			$s = haxe_Utf8::sub($s, $len, $tmp2 - $len);
			unset($tmp2,$tmp1,$tmp);
		}
		return $chunks;
	}
	static function toLines($s) {
		return thx_Strings::$SPLIT_LINES->split($s);
	}
	static function trimChars($value, $charlist) {
		return trim($value, $charlist);
	}
	static function trimCharsLeft($value, $charlist) {
		return ltrim($value, $charlist);
	}
	static function trimCharsRight($value, $charlist) {
		return rtrim($value, $charlist);
	}
	static function underscore($s) {
		$s = _hx_deref(new EReg("::", "g"))->replace($s, "/");
		$s = _hx_deref(new EReg("([A-Z]+)([A-Z][a-z])", "g"))->replace($s, "\$1_\$2");
		$s = _hx_deref(new EReg("([a-z\\d])([A-Z])", "g"))->replace($s, "\$1_\$2");
		$s = _hx_deref(new EReg("-", "g"))->replace($s, "_");
		return strtolower($s);
	}
	static function upperCaseFirst($value) {
		$tmp = strtoupper(_hx_substring($value, 0, 1));
		$tmp1 = _hx_substring($value, 1, null);
		return _hx_string_or_null($tmp) . _hx_string_or_null($tmp1);
	}
	static function upTo($value, $searchFor) {
		$pos = _hx_index_of($value, $searchFor, null);
		if($pos < 0) {
			return $value;
		} else {
			return _hx_substring($value, 0, $pos);
		}
	}
	static function wrapColumns($s, $columns = null, $indent = null, $newline = null) {
		if($newline === null) {
			$newline = "\x0A";
		}
		if($indent === null) {
			$indent = "";
		}
		if($columns === null) {
			$columns = 78;
		}
		return thx_Strings::$SPLIT_LINES->split($s)->map(array(new _hx_lambda(array(&$columns, &$indent, &$newline), "thx_Strings_10"), 'execute'))->join($newline);
	}
	static function upperMatch($re) {
		return strtoupper($re->matched(0));
	}
	static function wrapLine($s, $columns, $indent, $newline) {
		$parts = (new _hx_array(array()));
		$pos = 0;
		$len = strlen($s);
		$ilen = strlen($indent);
		$columns -= $ilen;
		while(true) {
			if($pos + $columns >= $len - $ilen) {
				$tmp = _hx_substring($s, $pos, null);
				$parts->push($tmp);
				break;
				unset($tmp);
			}
			$i = 0;
			while(true) {
				$tmp1 = null;
				$tmp2 = !StringTools::isSpace($s, $pos + $columns - $i);
				if($tmp2) {
					$tmp1 = $i < $columns;
				} else {
					$tmp1 = false;
				}
				if(!$tmp1) {
					break;
				}
				++$i;
				unset($tmp2,$tmp1);
			}
			if($i === $columns) {
				$i = 0;
				while(true) {
					$tmp3 = null;
					$tmp4 = !StringTools::isSpace($s, $pos + $columns + $i);
					if($tmp4) {
						$tmp3 = $pos + $columns + $i < $len;
					} else {
						$tmp3 = false;
					}
					if(!$tmp3) {
						break;
					}
					++$i;
					unset($tmp4,$tmp3);
				}
				$tmp5 = _hx_substring($s, $pos, $pos + $columns + $i);
				$parts->push($tmp5);
				$pos += $columns + $i + 1;
				unset($tmp5);
			} else {
				$tmp6 = _hx_substring($s, $pos, $pos + $columns - $i);
				$parts->push($tmp6);
				$pos += $columns - $i + 1;
				unset($tmp6);
			}
			unset($i);
		}
		$tmp7 = $parts->join(_hx_string_or_null($newline) . _hx_string_or_null($indent));
		return _hx_string_or_null($indent) . _hx_string_or_null($tmp7);
	}
	static function lpad($s, $char, $length) {
		$tmp = haxe_Utf8::length($s);
		$diff = $length - $tmp;
		if($diff > 0) {
			$tmp1 = thx_Strings::repeat($char, $diff);
			return _hx_string_or_null($tmp1) . _hx_string_or_null($s);
		} else {
			return $s;
		}
	}
	static function rpad($s, $char, $length) {
		$tmp = haxe_Utf8::length($s);
		$diff = $length - $tmp;
		if($diff > 0) {
			$tmp1 = thx_Strings::repeat($char, $diff);
			return _hx_string_or_null($s) . _hx_string_or_null($tmp1);
		} else {
			return $s;
		}
	}
	static $monoid;
	static $UCWORDS;
	static $IS_BREAKINGWHITESPACE;
	static $IS_ALPHA;
	static $WSG;
	static $SPLIT_LINES;
	static $CANONICALIZE_LINES;
	function __toString() { return 'thx.Strings'; }
}
thx_Strings::$order = thx__Ord_Ord_Impl_::fromIntComparison((isset(thx_Strings::$compare) ? thx_Strings::$compare: array("thx_Strings", "compare")));
thx_Strings::$HASCODE_MAX = 2147483647;
thx_Strings::$HASCODE_MUL = 31;
thx_Strings::$monoid = _hx_anonymous(array("zero" => "", "append" => array(new _hx_lambda(array(), "thx_Strings_11"), 'execute')));
thx_Strings::$UCWORDS = new EReg("[^a-zA-Z]([a-z])", "g");
thx_Strings::$IS_BREAKINGWHITESPACE = new EReg("[^\x09\x0A\x0D ]", "");
thx_Strings::$IS_ALPHA = new EReg("[^a-zA-Z]", "");
thx_Strings::$WSG = new EReg("[ \x09\x0D\x0A]+", "g");
thx_Strings::$SPLIT_LINES = new EReg("\x0D\x0A|\x0A\x0D|\x0A|\x0D", "g");
thx_Strings::$CANONICALIZE_LINES = new EReg("\x0D\x0A|\x0A\x0D|\x0D", "g");
function thx_Strings_0($v) {
	{
		return strtolower($v);
	}
}
function thx_Strings_1($v) {
	{
		return strtolower($v);
	}
}
function thx_Strings_2(&$s1, $a1) {
	{
		return thx_Strings::caseInsensitiveContains($s1, $a1);
	}
}
function thx_Strings_3(&$s1, $a1) {
	{
		return thx_Strings::contains($s1, $a1);
	}
}
function thx_Strings_4(&$s, $end) {
	{
		return StringTools::endsWith($s, $end);
	}
}
function thx_Strings_5($s1) {
	{
		return haxe_Utf8::charCodeAt($s1, 0);
	}
}
function thx_Strings_6($i) {
	{
		return chr($i);
	}
}
function thx_Strings_7(&$seed, $_) {
	{
		return thx_Strings::random($seed, null);
	}
}
function thx_Strings_8(&$s, $start) {
	{
		return StringTools::startsWith($s, $start);
	}
}
function thx_Strings_9($s1) {
	{
		return haxe_Utf8::charCodeAt($s1, 0);
	}
}
function thx_Strings_10(&$columns, &$indent, &$newline, $part) {
	{
		$s1 = thx_Strings::$WSG->replace($part, " ");
		$tmp = trim($s1);
		return thx_Strings::wrapLine($tmp, $columns, $indent, $newline);
	}
}
function thx_Strings_11($a, $b) {
	{
		return _hx_string_or_null($a) . _hx_string_or_null($b);
	}
}
