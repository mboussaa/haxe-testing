// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_thx_Floats
#include <thx/Floats.h>
#endif
#ifndef INCLUDED_thx_Ints
#include <thx/Ints.h>
#endif
#ifndef INCLUDED_thx_color_parse_ChannelInfo
#include <thx/color/parse/ChannelInfo.h>
#endif
#ifndef INCLUDED_thx_color_parse_ColorInfo
#include <thx/color/parse/ColorInfo.h>
#endif
#ifndef INCLUDED_thx_color_parse_ColorParser
#include <thx/color/parse/ColorParser.h>
#endif

namespace thx{
namespace color{
namespace parse{

void ColorParser_obj::__construct(){
            	HX_STACK_FRAME("thx.color.parse.ColorParser","new",0x0354a004,"thx.color.parse.ColorParser.new","thx/color/parse/ColorParser.hx",19,0x24e60f6f)
            	HX_STACK_THIS(this)
HXLINE(  20)		this->pattern_color =  ::EReg_obj::__new(HX_("^\\s*([^(]+)\\s*\\(([^)]*)\\)\\s*$",86,a1,f0,70),HX_("i",69,00,00,00));
HXLINE(  21)		this->pattern_channel =  ::EReg_obj::__new(HX_("^\\s*(-?\\d*.\\d+|-?\\d+)(%|deg|rad)?\\s*$",29,b4,28,28),HX_("i",69,00,00,00));
            	}

Dynamic ColorParser_obj::__CreateEmpty() { return new ColorParser_obj; }

hx::ObjectPtr< ColorParser_obj > ColorParser_obj::__new()
{
	hx::ObjectPtr< ColorParser_obj > _hx_result = new ColorParser_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic ColorParser_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< ColorParser_obj > _hx_result = new ColorParser_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::thx::color::parse::ColorInfo ColorParser_obj::processHex(::String s){
            	HX_STACK_FRAME("thx.color.parse.ColorParser","processHex",0xa2b47488,"thx.color.parse.ColorParser.processHex","thx/color/parse/ColorParser.hx",25,0x24e60f6f)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(s,"s")
HXLINE(  26)		Bool _hx_tmp = !(::thx::color::parse::ColorParser_obj::isPureHex->match(s));
HXDLIN(  26)		if (_hx_tmp) {
HXLINE(  27)			::String _hx_tmp1 = s.substr((int)0,(int)1);
HXDLIN(  27)			if ((_hx_tmp1 == HX_("#",23,00,00,00))) {
HXLINE(  28)				Bool _hx_tmp2 = (s.length == (int)4);
HXDLIN(  28)				if (_hx_tmp2) {
HXLINE(  29)					::String _hx_tmp3 = s.charAt((int)1);
HXDLIN(  29)					::String _hx_tmp4 = s.charAt((int)1);
HXDLIN(  29)					::String _hx_tmp5 = (_hx_tmp3 + _hx_tmp4);
HXDLIN(  29)					::String _hx_tmp6 = s.charAt((int)2);
HXDLIN(  29)					::String _hx_tmp7 = (_hx_tmp5 + _hx_tmp6);
HXDLIN(  29)					::String _hx_tmp8 = s.charAt((int)2);
HXDLIN(  29)					::String _hx_tmp9 = (_hx_tmp7 + _hx_tmp8);
HXDLIN(  29)					::String _hx_tmp10 = s.charAt((int)3);
HXDLIN(  29)					::String _hx_tmp11 = (_hx_tmp9 + _hx_tmp10);
HXDLIN(  29)					::String _hx_tmp12 = s.charAt((int)3);
HXDLIN(  29)					s = (_hx_tmp11 + _hx_tmp12);
            				}
            				else {
HXLINE(  30)					Bool _hx_tmp13 = (s.length == (int)5);
HXDLIN(  30)					if (_hx_tmp13) {
HXLINE(  31)						::String _hx_tmp14 = s.charAt((int)1);
HXDLIN(  31)						::String _hx_tmp15 = s.charAt((int)1);
HXDLIN(  31)						::String _hx_tmp16 = (_hx_tmp14 + _hx_tmp15);
HXDLIN(  31)						::String _hx_tmp17 = s.charAt((int)2);
HXDLIN(  31)						::String _hx_tmp18 = (_hx_tmp16 + _hx_tmp17);
HXDLIN(  31)						::String _hx_tmp19 = s.charAt((int)2);
HXDLIN(  31)						::String _hx_tmp20 = (_hx_tmp18 + _hx_tmp19);
HXDLIN(  31)						::String _hx_tmp21 = s.charAt((int)3);
HXDLIN(  31)						::String _hx_tmp22 = (_hx_tmp20 + _hx_tmp21);
HXDLIN(  31)						::String _hx_tmp23 = s.charAt((int)3);
HXDLIN(  31)						::String _hx_tmp24 = (_hx_tmp22 + _hx_tmp23);
HXDLIN(  31)						::String _hx_tmp25 = s.charAt((int)4);
HXDLIN(  31)						::String _hx_tmp26 = (_hx_tmp24 + _hx_tmp25);
HXDLIN(  31)						::String _hx_tmp27 = s.charAt((int)4);
HXDLIN(  31)						s = (_hx_tmp26 + _hx_tmp27);
            					}
            					else {
HXLINE(  33)						s = s.substr((int)1,null());
            					}
            				}
            			}
            			else {
HXLINE(  34)				::String _hx_tmp28 = s.substr((int)0,(int)2);
HXDLIN(  34)				if ((_hx_tmp28 == HX_("0x",48,2a,00,00))) {
HXLINE(  35)					s = s.substr((int)2,null());
            				}
            				else {
HXLINE(  37)					return null();
            				}
            			}
            		}
HXLINE(  40)		HX_VARI( ::Array< ::Dynamic>,channels) = ::Array_obj< ::Dynamic>::__new(0);
HXLINE(  41)		while((s.length > (int)0)){
HXLINE(  42)			::String _hx_tmp29 = s.substr((int)0,(int)2);
HXDLIN(  42)			 ::Dynamic _hx_tmp30 = ::Std_obj::parseInt((HX_("0x",48,2a,00,00) + _hx_tmp29));
HXDLIN(  42)			::hx::EnumBase _hx_tmp31 = ::thx::color::parse::ChannelInfo_obj::CIInt8(_hx_tmp30);
HXDLIN(  42)			channels->push(_hx_tmp31);
HXLINE(  43)			s = s.substr((int)2,null());
            		}
HXLINE(  45)		Bool _hx_tmp32 = (channels->length == (int)4);
HXDLIN(  45)		if (_hx_tmp32) {
HXLINE(  46)			::Array< ::Dynamic> _hx_tmp33 = channels->slice((int)1,null())->concat(::Array_obj< ::Dynamic>::__new(1)->init(0,channels->__get((int)0).StaticCast< ::hx::EnumBase >()));
HXDLIN(  46)			return  ::thx::color::parse::ColorInfo_obj::__new(HX_("rgba",b4,d0,a8,4b),_hx_tmp33);
            		}
            		else {
HXLINE(  48)			return  ::thx::color::parse::ColorInfo_obj::__new(HX_("rgb",0d,db,56,00),channels);
            		}
HXLINE(  45)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorParser_obj,processHex,return )

 ::thx::color::parse::ColorInfo ColorParser_obj::processColor(::String s){
            	HX_STACK_FRAME("thx.color.parse.ColorParser","processColor",0x35b32850,"thx.color.parse.ColorParser.processColor","thx/color/parse/ColorParser.hx",51,0x24e60f6f)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(s,"s")
HXLINE(  52)		Bool _hx_tmp = !(this->pattern_color->match(s));
HXDLIN(  52)		if (_hx_tmp) {
HXLINE(  53)			return null();
            		}
HXLINE(  55)		HX_VARI( ::String,name) = this->pattern_color->matched((int)1);
HXLINE(  56)		if (hx::IsNull( name )) {
HXLINE(  56)			return null();
            		}
HXLINE(  58)		name = name.toLowerCase();
HXLINE(  60)		HX_VARI( ::String,m2) = this->pattern_color->matched((int)2);
HXDLIN(  60)		HX_VAR( ::Array< ::String >,s_channels);
HXLINE(  61)		if (hx::IsNull( m2 )) {
HXLINE(  60)			s_channels = ::Array_obj< ::String >::__new(0);
            		}
            		else {
HXLINE(  60)			s_channels = m2.split(HX_(",",2c,00,00,00));
            		}
HXDLIN(  60)		HX_VARI( ::Array< ::Dynamic>,channels) = ::Array_obj< ::Dynamic>::__new(0);
HXDLIN(  60)		HX_VAR( ::hx::EnumBase,channel);
HXLINE(  64)		{
HXLINE(  64)			HX_VARI( Int,_g) = (int)0;
HXDLIN(  64)			while((_g < s_channels->length)){
HXLINE(  64)				HX_VARI( ::String,s_channel) = s_channels->__get(_g);
HXDLIN(  64)				++_g;
HXLINE(  65)				channel = this->processChannel(s_channel);
HXLINE(  66)				if (hx::IsNull( channel )) {
HXLINE(  66)					return null();
            				}
HXLINE(  67)				channels->push(channel);
            			}
            		}
HXLINE(  69)		return  ::thx::color::parse::ColorInfo_obj::__new(name,channels);
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorParser_obj,processColor,return )

::hx::EnumBase ColorParser_obj::processChannel(::String s){
            	HX_STACK_FRAME("thx.color.parse.ColorParser","processChannel",0x44760cf0,"thx.color.parse.ColorParser.processChannel","thx/color/parse/ColorParser.hx",72,0x24e60f6f)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(s,"s")
HXLINE(  73)		Bool _hx_tmp = !(this->pattern_channel->match(s));
HXDLIN(  73)		if (_hx_tmp) {
HXLINE(  73)			return null();
            		}
HXLINE(  74)		HX_VARI( ::String,value) = this->pattern_channel->matched((int)1);
HXDLIN(  74)		HX_VARI( ::String,unit) = this->pattern_channel->matched((int)2);
HXLINE(  76)		Bool _hx_tmp1 = hx::IsNull( unit );
HXDLIN(  76)		if (_hx_tmp1) {
HXLINE(  76)			unit = HX_("",00,00,00,00);
            		}
HXLINE(  77)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  77)			::String _hx_switch_0 = unit;
            			if (  (_hx_switch_0==HX_("",00,00,00,00)) ){
HXLINE(  84)				 ::Dynamic _hx_tmp2 = ::thx::Ints_obj::parse(value,null());
HXDLIN(  84)				if ((value == (HX_("",00,00,00,00) + _hx_tmp2))) {
HXLINE(  85)					HX_VARI(  ::Dynamic,i) = ::thx::Ints_obj::parse(value,null());
HXLINE(  86)					if (hx::IsEq( i,(int)0 )) {
HXLINE(  77)						return ::thx::color::parse::ChannelInfo_obj::CIBool(false);
            					}
            					else {
HXLINE(  88)						if (hx::IsEq( i,(int)1 )) {
HXLINE(  77)							return ::thx::color::parse::ChannelInfo_obj::CIBool(true);
            						}
            						else {
HXLINE(  90)							if (hx::IsLess( i,(int)256 )) {
HXLINE(  77)								return ::thx::color::parse::ChannelInfo_obj::CIInt8(i);
            							}
            							else {
HXLINE(  77)								return ::thx::color::parse::ChannelInfo_obj::CIInt(i);
            							}
            						}
            					}
            				}
            				else {
HXLINE(  93)					Bool _hx_tmp3 = ::thx::Floats_obj::canParse(value);
HXDLIN(  93)					if (_hx_tmp3) {
HXLINE(  94)						Float _hx_tmp4 = ::thx::Floats_obj::parse(value);
HXLINE(  77)						return ::thx::color::parse::ChannelInfo_obj::CIFloat(_hx_tmp4);
            					}
            					else {
HXLINE(  77)						return null();
            					}
            				}
HXLINE(  84)				goto _hx_goto_2;
            			}
            			if (  (_hx_switch_0==HX_("%",25,00,00,00)) ){
HXLINE(  78)				Bool _hx_tmp5 = ::thx::Floats_obj::canParse(value);
HXDLIN(  78)				if (_hx_tmp5) {
HXLINE(  79)					Float _hx_tmp6 = ::thx::Floats_obj::parse(value);
HXLINE(  77)					return ::thx::color::parse::ChannelInfo_obj::CIPercent(_hx_tmp6);
            				}
            				else {
HXLINE(  77)					return null();
            				}
HXLINE(  78)				goto _hx_goto_2;
            			}
            			if (  (_hx_switch_0==HX_("DEG",a6,d5,33,00)) ||  (_hx_switch_0==HX_("deg",c6,39,4c,00)) ){
HXLINE(  80)				Bool _hx_tmp7 = ::thx::Floats_obj::canParse(value);
HXDLIN(  80)				if (_hx_tmp7) {
HXLINE(  81)					Float _hx_tmp8 = ::thx::Floats_obj::parse(value);
HXLINE(  77)					return ::thx::color::parse::ChannelInfo_obj::CIDegree(_hx_tmp8);
            				}
            				else {
HXLINE(  77)					return null();
            				}
HXLINE(  80)				goto _hx_goto_2;
            			}
            			if (  (_hx_switch_0==HX_("RAD",b5,71,3e,00)) ||  (_hx_switch_0==HX_("rad",d5,d5,56,00)) ){
HXLINE(  82)				Bool _hx_tmp9 = ::thx::Floats_obj::canParse(value);
HXDLIN(  82)				if (_hx_tmp9) {
HXLINE(  83)					Float _hx_tmp10 = ::thx::Floats_obj::parse(value);
HXDLIN(  83)					Float _hx_tmp11 = ((Float)(_hx_tmp10 * (int)180) / (Float)::Math_obj::PI);
HXLINE(  77)					return ::thx::color::parse::ChannelInfo_obj::CIDegree(_hx_tmp11);
            				}
            				else {
HXLINE(  77)					return null();
            				}
HXLINE(  82)				goto _hx_goto_2;
            			}
            			/* default */{
HXLINE(  77)				return null();
            			}
            			_hx_goto_2:;
            		}
            		catch( ::Dynamic _hx_e){
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic e = _hx_e;
HXLINE(  96)				return null();
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE(  77)		return null();
            	}


HX_DEFINE_DYNAMIC_FUNC1(ColorParser_obj,processChannel,return )

 ::thx::color::parse::ColorParser ColorParser_obj::parser;

 ::thx::color::parse::ColorInfo ColorParser_obj::parseColor(::String s){
            	HX_STACK_FRAME("thx.color.parse.ColorParser","parseColor",0x3fd5e50c,"thx.color.parse.ColorParser.parseColor","thx/color/parse/ColorParser.hx",9,0x24e60f6f)
            	HX_STACK_ARG(s,"s")
HXLINE(   9)		return ::thx::color::parse::ColorParser_obj::parser->processColor(s);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ColorParser_obj,parseColor,return )

 ::thx::color::parse::ColorInfo ColorParser_obj::parseHex(::String s){
            	HX_STACK_FRAME("thx.color.parse.ColorParser","parseHex",0x65a94a44,"thx.color.parse.ColorParser.parseHex","thx/color/parse/ColorParser.hx",12,0x24e60f6f)
            	HX_STACK_ARG(s,"s")
HXLINE(  12)		return ::thx::color::parse::ColorParser_obj::parser->processHex(s);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ColorParser_obj,parseHex,return )

::hx::EnumBase ColorParser_obj::parseChannel(::String s){
            	HX_STACK_FRAME("thx.color.parse.ColorParser","parseChannel",0x2a4e70ac,"thx.color.parse.ColorParser.parseChannel","thx/color/parse/ColorParser.hx",15,0x24e60f6f)
            	HX_STACK_ARG(s,"s")
HXLINE(  15)		return ::thx::color::parse::ColorParser_obj::parser->processChannel(s);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ColorParser_obj,parseChannel,return )

 ::EReg ColorParser_obj::isPureHex;

::Array< Float > ColorParser_obj::getFloatChannels(::Array< ::Dynamic> channels,Int length,Bool useInt8){
            		HX_BEGIN_LOCAL_FUNC_S1(hx::LocalFunc,_hx_Closure_0,Bool,a2) HXARGC(1)
            		Float _hx_run(::hx::EnumBase a1){
            			HX_STACK_FRAME("thx.color.parse.ColorParser","getFloatChannels",0x82b40b72,"thx.color.parse.ColorParser.getFloatChannels","thx/color/parse/ColorParser.hx",102,0x24e60f6f)
            			HX_STACK_ARG(a1,"a1")
HXLINE( 102)			return ::thx::color::parse::ColorParser_obj::getFloatChannel(a1,a2);
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACK_FRAME("thx.color.parse.ColorParser","getFloatChannels",0x82b40b72,"thx.color.parse.ColorParser.getFloatChannels","thx/color/parse/ColorParser.hx",99,0x24e60f6f)
            	HX_STACK_ARG(channels,"channels")
            	HX_STACK_ARG(length,"length")
            	HX_STACK_ARG(useInt8,"useInt8")
HXLINE( 100)		if ((length != channels->length)) {
HXLINE( 101)			HX_STACK_DO_THROW((((HX_("invalid number of channels, expected ",69,79,0b,9c) + length) + HX_(" but it is ",60,e9,99,19)) + channels->length));
            		}
HXLINE( 102)		HX_VARI( Bool,a2) = useInt8;
HXDLIN( 102)		 ::Dynamic _hx_tmp =  ::Dynamic(new _hx_Closure_0(a2));
HXDLIN( 102)		return channels->map(_hx_tmp);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(ColorParser_obj,getFloatChannels,return )

::Array< Int > ColorParser_obj::getInt8Channels(::Array< ::Dynamic> channels,Int length){
            	HX_STACK_FRAME("thx.color.parse.ColorParser","getInt8Channels",0xdcf9c733,"thx.color.parse.ColorParser.getInt8Channels","thx/color/parse/ColorParser.hx",105,0x24e60f6f)
            	HX_STACK_ARG(channels,"channels")
            	HX_STACK_ARG(length,"length")
HXLINE( 106)		if ((length != channels->length)) {
HXLINE( 107)			HX_STACK_DO_THROW((((HX_("invalid number of channels, expected ",69,79,0b,9c) + length) + HX_(" but it is ",60,e9,99,19)) + channels->length));
            		}
HXLINE( 108)		return channels->map(::thx::color::parse::ColorParser_obj::getInt8Channel_dyn());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(ColorParser_obj,getInt8Channels,return )

Float ColorParser_obj::getFloatChannel(::hx::EnumBase channel,hx::Null< Bool >  __o_useInt8){
Bool useInt8 = __o_useInt8.Default(true);
            	HX_STACK_FRAME("thx.color.parse.ColorParser","getFloatChannel",0x5d9299e1,"thx.color.parse.ColorParser.getFloatChannel","thx/color/parse/ColorParser.hx",112,0x24e60f6f)
            	HX_STACK_ARG(channel,"channel")
            	HX_STACK_ARG(useInt8,"useInt8")
HXLINE( 112)		Int _hx_tmp = ( ( ::hx::EnumBase)(channel) )->_hx_getIndex();
HXDLIN( 112)		switch((int)(_hx_tmp)){
            			case (int)0: {
HXLINE( 112)				return ((Float)channel->_hx_getFloat(0) / (Float)(int)100);
            			}
            			break;
            			case (int)1: {
HXLINE( 112)				return channel->_hx_getFloat(0);
            			}
            			break;
            			case (int)2: {
HXLINE( 112)				return channel->_hx_getFloat(0);
            			}
            			break;
            			case (int)3: {
HXLINE( 117)				HX_VARI( Int,v) = channel->_hx_getInt(0);
HXDLIN( 117)				if (useInt8) {
HXLINE( 112)					return ((Float)v / (Float)(int)255);
            				}
            				else {
HXLINE( 112)					return channel->_hx_getInt(0);
            				}
            			}
            			break;
            			case (int)4: {
HXLINE( 112)				return channel->_hx_getInt(0);
            			}
            			break;
            			case (int)5: {
HXLINE( 113)				if (channel->_hx_getBool(0)) {
HXLINE( 112)					return (int)1;
            				}
            				else {
HXLINE( 112)					return (int)0;
            				}
            			}
            			break;
            		}
HXDLIN( 112)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(ColorParser_obj,getFloatChannel,return )

Int ColorParser_obj::getInt8Channel(::hx::EnumBase channel){
            	HX_STACK_FRAME("thx.color.parse.ColorParser","getInt8Channel",0x7aad5140,"thx.color.parse.ColorParser.getInt8Channel","thx/color/parse/ColorParser.hx",124,0x24e60f6f)
            	HX_STACK_ARG(channel,"channel")
HXLINE( 124)		Int _hx_tmp = ( ( ::hx::EnumBase)(channel) )->_hx_getIndex();
HXDLIN( 124)		switch((int)(_hx_tmp)){
            			case (int)0: {
HXLINE( 124)				return ::Math_obj::round(((Float)((int)255 * channel->_hx_getFloat(0)) / (Float)(int)100));
            			}
            			break;
            			case (int)3: {
HXLINE( 124)				return channel->_hx_getInt(0);
            			}
            			break;
            			case (int)5: {
HXLINE( 125)				if (channel->_hx_getBool(0)) {
HXLINE( 124)					return (int)1;
            				}
            				else {
HXLINE( 124)					return (int)0;
            				}
            			}
            			break;
            			default:{
HXLINE( 128)				HX_STACK_DO_THROW(HX_("unable to extract a valid int8 value",54,05,e6,0c));
            			}
            		}
HXLINE( 124)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(ColorParser_obj,getInt8Channel,return )


ColorParser_obj::ColorParser_obj()
{
}

void ColorParser_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(ColorParser);
	HX_MARK_MEMBER_NAME(pattern_color,"pattern_color");
	HX_MARK_MEMBER_NAME(pattern_channel,"pattern_channel");
	HX_MARK_END_CLASS();
}

void ColorParser_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(pattern_color,"pattern_color");
	HX_VISIT_MEMBER_NAME(pattern_channel,"pattern_channel");
}

hx::Val ColorParser_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"processHex") ) { return hx::Val( processHex_dyn()); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"processColor") ) { return hx::Val( processColor_dyn()); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"pattern_color") ) { return hx::Val( pattern_color); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"processChannel") ) { return hx::Val( processChannel_dyn()); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"pattern_channel") ) { return hx::Val( pattern_channel); }
	}
	return super::__Field(inName,inCallProp);
}

bool ColorParser_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"parser") ) { outValue = parser; return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"parseHex") ) { outValue = parseHex_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isPureHex") ) { outValue = isPureHex; return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"parseColor") ) { outValue = parseColor_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"parseChannel") ) { outValue = parseChannel_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"getInt8Channel") ) { outValue = getInt8Channel_dyn(); return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"getInt8Channels") ) { outValue = getInt8Channels_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"getFloatChannel") ) { outValue = getFloatChannel_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"getFloatChannels") ) { outValue = getFloatChannels_dyn(); return true; }
	}
	return false;
}

hx::Val ColorParser_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"pattern_color") ) { pattern_color=inValue.Cast<  ::EReg >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"pattern_channel") ) { pattern_channel=inValue.Cast<  ::EReg >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

bool ColorParser_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"parser") ) { parser=ioValue.Cast<  ::thx::color::parse::ColorParser >(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isPureHex") ) { isPureHex=ioValue.Cast<  ::EReg >(); return true; }
	}
	return false;
}

void ColorParser_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("pattern_color","\xf4","\x5a","\x78","\xca"));
	outFields->push(HX_HCSTRING("pattern_channel","\x94","\x30","\xe8","\x7a"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo ColorParser_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::EReg*/ ,(int)offsetof(ColorParser_obj,pattern_color),HX_HCSTRING("pattern_color","\xf4","\x5a","\x78","\xca")},
	{hx::fsObject /*::EReg*/ ,(int)offsetof(ColorParser_obj,pattern_channel),HX_HCSTRING("pattern_channel","\x94","\x30","\xe8","\x7a")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo ColorParser_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::thx::color::parse::ColorParser*/ ,(void *) &ColorParser_obj::parser,HX_HCSTRING("parser","\xdf","\x9c","\x88","\xed")},
	{hx::fsObject /*::EReg*/ ,(void *) &ColorParser_obj::isPureHex,HX_HCSTRING("isPureHex","\xf9","\x51","\xcb","\xe3")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static ::String ColorParser_obj_sMemberFields[] = {
	HX_HCSTRING("pattern_color","\xf4","\x5a","\x78","\xca"),
	HX_HCSTRING("pattern_channel","\x94","\x30","\xe8","\x7a"),
	HX_HCSTRING("processHex","\xac","\x47","\x1c","\xd7"),
	HX_HCSTRING("processColor","\x74","\x0c","\x11","\x32"),
	HX_HCSTRING("processChannel","\x14","\x42","\x30","\x7f"),
	::String(null()) };

static void ColorParser_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ColorParser_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(ColorParser_obj::parser,"parser");
	HX_MARK_MEMBER_NAME(ColorParser_obj::isPureHex,"isPureHex");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ColorParser_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ColorParser_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(ColorParser_obj::parser,"parser");
	HX_VISIT_MEMBER_NAME(ColorParser_obj::isPureHex,"isPureHex");
};

#endif

hx::Class ColorParser_obj::__mClass;

static ::String ColorParser_obj_sStaticFields[] = {
	HX_HCSTRING("parser","\xdf","\x9c","\x88","\xed"),
	HX_HCSTRING("parseColor","\x30","\xb8","\x3d","\x74"),
	HX_HCSTRING("parseHex","\x68","\x4c","\x71","\xd6"),
	HX_HCSTRING("parseChannel","\xd0","\x54","\xac","\x26"),
	HX_HCSTRING("isPureHex","\xf9","\x51","\xcb","\xe3"),
	HX_HCSTRING("getFloatChannels","\x96","\xd1","\x40","\x88"),
	HX_HCSTRING("getInt8Channels","\x8f","\x11","\x2e","\x05"),
	HX_HCSTRING("getFloatChannel","\x3d","\xe4","\xc6","\x85"),
	HX_HCSTRING("getInt8Channel","\x64","\x86","\x67","\xb5"),
	::String(null())
};

void ColorParser_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("thx.color.parse.ColorParser","\x12","\x8e","\x83","\x23");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ColorParser_obj::__GetStatic;
	__mClass->mSetStaticField = &ColorParser_obj::__SetStatic;
	__mClass->mMarkFunc = ColorParser_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(ColorParser_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(ColorParser_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< ColorParser_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ColorParser_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ColorParser_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ColorParser_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ColorParser_obj::__boot()
{
{
            	HX_STACK_FRAME("thx.color.parse.ColorParser","boot",0xded0640e,"thx.color.parse.ColorParser.boot","thx/color/parse/ColorParser.hx",7,0x24e60f6f)
HXLINE(   7)		parser =  ::thx::color::parse::ColorParser_obj::__new();
            	}
{
            	HX_STACK_FRAME("thx.color.parse.ColorParser","boot",0xded0640e,"thx.color.parse.ColorParser.boot","thx/color/parse/ColorParser.hx",24,0x24e60f6f)
HXLINE(  24)		isPureHex =  ::EReg_obj::__new(HX_("^([0-9a-f]{2}){3,4}$",58,12,62,89),HX_("i",69,00,00,00));
            	}
}

} // end namespace thx
} // end namespace color
} // end namespace parse
