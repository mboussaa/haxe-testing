// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx {
	public class Floats : global::haxe.lang.HxObject {
		
		static Floats() {
			global::thx.Floats.TOLERANCE = 10e-5;
			global::thx.Floats.EPSILON = 1e-9;
			global::thx.Floats.pattern_parse = new global::EReg("^(\\+|-)?\\d+(\\.\\d+)?(e-?\\d+)?$", "");
			global::thx.Floats.order = global::thx._Ord.Ord_Impl_.fromIntComparison<double>(((global::haxe.lang.Function) (new global::haxe.lang.Closure(typeof(global::thx.Floats), "compare", 57219237)) ));
			object __temp_stmt2 = null;
			{
				global::haxe.lang.Function __temp_odecl1 = ( (( global::thx.Floats_Anon_248__Fun.__hx_current != null )) ? (global::thx.Floats_Anon_248__Fun.__hx_current) : (global::thx.Floats_Anon_248__Fun.__hx_current = ((global::thx.Floats_Anon_248__Fun) (new global::thx.Floats_Anon_248__Fun()) )) );
				__temp_stmt2 = new global::haxe.lang.DynamicObject(new int[]{265544154}, new object[]{__temp_odecl1}, new int[]{1357975336}, new double[]{0.0});
			}
			
			global::thx.Floats.monoid = ((object) (__temp_stmt2) );
		}
		
		
		public Floats(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Floats() {
			global::thx.Floats.__hx_ctor_thx_Floats(this);
		}
		
		
		public static void __hx_ctor_thx_Floats(global::thx.Floats __temp_me107) {
		}
		
		
		public static double TOLERANCE;
		
		public static double EPSILON;
		
		public static global::EReg pattern_parse;
		
		public static double angleDifference(double a, double b, global::haxe.lang.Null<double> turn) {
			unchecked {
				global::haxe.lang.Null<double> __temp_turn98 = ( ( ! (turn.hasValue) ) ? (new global::haxe.lang.Null<double>(360.0, true)) : (turn) );
				double r = ( (( b - a )) % (__temp_turn98).@value );
				if (( r < 0 )) {
					r += (__temp_turn98).@value;
				}
				
				if (( r > ( (__temp_turn98).@value / 2 ) )) {
					r -= (__temp_turn98).@value;
				}
				
				return r;
			}
		}
		
		
		public static double ceilTo(double f, int decimals) {
			unchecked {
				double p = global::System.Math.Pow(((double) (10) ), ((double) (decimals) ));
				return ( global::System.Math.Ceiling(((double) (( f * p )) )) / p );
			}
		}
		
		
		public static bool canParse(string s) {
			return global::thx.Floats.pattern_parse.match(s);
		}
		
		
		public static double clamp(double v, double min, double max) {
			if (( v < min )) {
				return min;
			}
			else if (( v > max )) {
				return max;
			}
			else {
				return v;
			}
			
		}
		
		
		public static double clampSym(double v, double max) {
			double min =  - (max) ;
			if (( v < min )) {
				return min;
			}
			else if (( v > max )) {
				return max;
			}
			else {
				return v;
			}
			
		}
		
		
		public static int compare(double a, double b) {
			unchecked {
				if (( a < b )) {
					return -1;
				}
				else if (( a > b )) {
					return 1;
				}
				else {
					return 0;
				}
				
			}
		}
		
		
		public static double floorTo(double f, int decimals) {
			unchecked {
				double p = global::System.Math.Pow(((double) (10) ), ((double) (decimals) ));
				return ( global::System.Math.Floor(((double) (( f * p )) )) / p );
			}
		}
		
		
		public static double interpolate(double f, double a, double b) {
			return ( ( (( b - a )) * f ) + a );
		}
		
		
		public static double interpolateAngle(double f, double a, double b, global::haxe.lang.Null<double> turn) {
			unchecked {
				double __temp_turn99 = ( ( ! (turn.hasValue) ) ? (((double) (360) )) : ((turn).@value) );
				return global::thx.Floats.wrapCircular(global::thx.Floats.interpolate(f, a, ( a + global::thx.Floats.angleDifference(a, b, new global::haxe.lang.Null<double>(__temp_turn99, true)) )), __temp_turn99);
			}
		}
		
		
		public static double interpolateAngleWidest(double f, double a, double b, global::haxe.lang.Null<double> turn) {
			unchecked {
				double __temp_turn100 = ( ( ! (turn.hasValue) ) ? (((double) (360) )) : ((turn).@value) );
				return global::thx.Floats.wrapCircular(( global::thx.Floats.interpolateAngle(f, a, b, new global::haxe.lang.Null<double>(__temp_turn100, true)) - ( __temp_turn100 / 2 ) ), __temp_turn100);
			}
		}
		
		
		public static double interpolateAngleCW(double f, double a, double b, global::haxe.lang.Null<double> turn) {
			unchecked {
				double __temp_turn101 = ( ( ! (turn.hasValue) ) ? (((double) (360) )) : ((turn).@value) );
				a = global::thx.Floats.wrapCircular(a, __temp_turn101);
				b = global::thx.Floats.wrapCircular(b, __temp_turn101);
				if (( b < a )) {
					b += __temp_turn101;
				}
				
				return global::thx.Floats.wrapCircular(global::thx.Floats.interpolate(f, a, b), __temp_turn101);
			}
		}
		
		
		public static double interpolateAngleCCW(double f, double a, double b, global::haxe.lang.Null<double> turn) {
			unchecked {
				double __temp_turn102 = ( ( ! (turn.hasValue) ) ? (((double) (360) )) : ((turn).@value) );
				a = global::thx.Floats.wrapCircular(a, __temp_turn102);
				b = global::thx.Floats.wrapCircular(b, __temp_turn102);
				if (( b > a )) {
					b -= __temp_turn102;
				}
				
				return global::thx.Floats.wrapCircular(global::thx.Floats.interpolate(f, a, b), __temp_turn102);
			}
		}
		
		
		public static T max<T>(T a, T b) {
			if (( global::haxe.lang.Runtime.compare(a, b) > 0 )) {
				return a;
			}
			else {
				return b;
			}
			
		}
		
		
		public static T min<T>(T a, T b) {
			if (( global::haxe.lang.Runtime.compare(a, b) < 0 )) {
				return a;
			}
			else {
				return b;
			}
			
		}
		
		
		public static bool nearEquals(double a, double b, global::haxe.lang.Null<double> tollerance) {
			global::haxe.lang.Null<double> __temp_tollerance103 = ( ( ! (tollerance.hasValue) ) ? (new global::haxe.lang.Null<double>(1e-9, true)) : (tollerance) );
			if ((  ! (global::System.Double.IsInfinity(((double) (a) )))  &&  ! (global::System.Double.IsNaN(((double) (a) )))  )) {
				return ( global::System.Math.Abs(((double) (( a - b )) )) <= (__temp_tollerance103).@value );
			}
			
			if (global::System.Double.IsNaN(((double) (a) ))) {
				return global::System.Double.IsNaN(((double) (b) ));
			}
			
			if (global::System.Double.IsNaN(((double) (b) ))) {
				return false;
			}
			
			if ( ! (((  ! (global::System.Double.IsInfinity(((double) (b) )))  &&  ! (global::System.Double.IsNaN(((double) (b) )))  ))) ) {
				return ( ( a > 0 ) == ( b > 0 ) );
			}
			
			return false;
		}
		
		
		public static bool nearEqualAngles(double a, double b, global::haxe.lang.Null<double> turn, global::haxe.lang.Null<double> tollerance) {
			global::haxe.lang.Null<double> __temp_tollerance105 = ( ( ! (tollerance.hasValue) ) ? (new global::haxe.lang.Null<double>(1e-9, true)) : (tollerance) );
			global::haxe.lang.Null<double> __temp_turn104 = ( ( ! (turn.hasValue) ) ? (new global::haxe.lang.Null<double>(360.0, true)) : (turn) );
			return ( global::System.Math.Abs(((double) (global::thx.Floats.angleDifference(a, b, __temp_turn104)) )) <= (__temp_tollerance105).@value );
		}
		
		
		public static bool nearZero(double n, global::haxe.lang.Null<double> tollerance) {
			global::haxe.lang.Null<double> __temp_tollerance106 = ( ( ! (tollerance.hasValue) ) ? (new global::haxe.lang.Null<double>(1e-9, true)) : (tollerance) );
			return ( global::System.Math.Abs(((double) (n) )) <= (__temp_tollerance106).@value );
		}
		
		
		public static double normalize(double v) {
			unchecked {
				if (( v < 0 )) {
					return ((double) (0) );
				}
				else if (( v > 1 )) {
					return ((double) (1) );
				}
				else {
					return v;
				}
				
			}
		}
		
		
		public static double parse(string s) {
			unchecked {
				if (string.Equals(global::haxe.lang.StringExt.substring(s, 0, new global::haxe.lang.Null<int>(1, true)), "+")) {
					s = global::haxe.lang.StringExt.substring(s, 1, default(global::haxe.lang.Null<int>));
				}
				
				return global::Std.parseFloat(s);
			}
		}
		
		
		public static double root(double @base, double index) {
			unchecked {
				return global::System.Math.Pow(((double) (@base) ), ((double) (( 1 / index )) ));
			}
		}
		
		
		public static double roundTo(double f, int decimals) {
			unchecked {
				double p = global::System.Math.Pow(((double) (10) ), ((double) (decimals) ));
				return ( global::System.Math.Floor(((double) (( ( f * p ) + 0.5 )) )) / p );
			}
		}
		
		
		public static int sign<T>(T @value) {
			unchecked {
				if (( global::haxe.lang.Runtime.compare(@value, 0) < 0 )) {
					return -1;
				}
				else {
					return 1;
				}
				
			}
		}
		
		
		public static string toString(double v) {
			return global::haxe.lang.Runtime.concat("", global::haxe.lang.Runtime.toString(v));
		}
		
		
		public static double toFloat(string s) {
			return global::thx.Floats.parse(s);
		}
		
		
		public static int trunc(double @value) {
			if (( @value < 0.0 )) {
				return ((int) (global::System.Math.Ceiling(((double) (@value) ))) );
			}
			else {
				return ((int) (global::System.Math.Floor(((double) (@value) ))) );
			}
			
		}
		
		
		public static double ftrunc(double @value) {
			if (( @value < 0.0 )) {
				return global::System.Math.Ceiling(((double) (@value) ));
			}
			else {
				return global::System.Math.Floor(((double) (@value) ));
			}
			
		}
		
		
		public static double wrap(double v, double min, double max) {
			unchecked {
				double range = ( ( max - min ) + 1 );
				if (( v < min )) {
					v += ( range * (( ( (( min - v )) / range ) + 1 )) );
				}
				
				return ( min + ( (( v - min )) % range ) );
			}
		}
		
		
		public static double wrapCircular(double v, double max) {
			v %= max;
			if (( v < 0 )) {
				v += max;
			}
			
			return v;
		}
		
		
		public static global::haxe.lang.Function order;
		
		public static object monoid;
		
		public static new object __hx_createEmpty() {
			return new global::thx.Floats(global::haxe.lang.EmptyObject.EMPTY);
		}
		
		
		public static new object __hx_create(global::Array arr) {
			return new global::thx.Floats();
		}
		
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx {
	public class Floats_Anon_248__Fun : global::haxe.lang.Function {
		
		public Floats_Anon_248__Fun() : base(2, 1) {
		}
		
		
		public static global::thx.Floats_Anon_248__Fun __hx_current;
		
		public override double __hx_invoke2_f(double __fn_float1, object __fn_dyn1, double __fn_float2, object __fn_dyn2) {
			double b = ( (( __fn_dyn2 == global::haxe.lang.Runtime.undefined )) ? (((double) (__fn_float2) )) : (((double) (global::haxe.lang.Runtime.toDouble(__fn_dyn2)) )) );
			double a = ( (( __fn_dyn1 == global::haxe.lang.Runtime.undefined )) ? (((double) (__fn_float1) )) : (((double) (global::haxe.lang.Runtime.toDouble(__fn_dyn1)) )) );
			return ( a + b );
		}
		
		
	}
}


