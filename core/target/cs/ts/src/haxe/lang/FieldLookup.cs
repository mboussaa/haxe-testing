// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::haxe.lang.FieldLookup.length = ( global::haxe.lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{97, 98, 99, 100, 101, 102, 104, 105, 107, 108, 109, 111, 113, 114, 115, 116, 118, 120, 121, 21233, 21234, 21235, 21236, 21237, 21238, 21747, 22196, 24357, 24867, 886708, 1821933, 4745537, 4845666, 4845682, 4846113, 4846783, 4848343, 4849249, 4895187, 4895195, 4896960, 4899635, 4945367, 4947370, 4949376, 4995533, 4996433, 5049501, 5097222, 5144726, 5193562, 5343647, 5393365, 5442204, 5442212, 5443986, 5495059, 5496390, 5545393, 5594513, 5594516, 5594520, 5691744, 5695307, 5741474, 5744356, 5744817, 5745024, 5745035, 5992347, 6510168, 7139236, 10917646, 24046298, 26061316, 30608302, 30975864, 36499888, 39622016, 40169174, 41828595, 42398688, 42740551, 43962972, 45386550, 46559126, 48259563, 51064624, 52644165, 55643531, 56139449, 57219237, 57816526, 63559312, 67425664, 67859554, 67859999, 69718249, 72452854, 74822897, 76061764, 78447857, 81234936, 82357170, 87367608, 89388435, 96903864, 97620427, 98472815, 99632527, 103479213, 106417793, 109574339, 116192081, 118663790, 122427940, 125111323, 126738834, 130476146, 142301684, 142895325, 143865495, 150376119, 156956385, 159136996, 160217260, 161606507, 165931470, 166502087, 168524941, 177377426, 185317413, 199688327, 200302604, 208459108, 212244564, 219115881, 219116105, 222029606, 222838177, 223532317, 227805334, 227901409, 240155668, 244830897, 246799147, 256208061, 261917267, 265544154, 266147462, 270118404, 285196505, 286437776, 288025444, 288368849, 291156297, 291852715, 295045109, 302437830, 302979532, 307312293, 313194419, 314003042, 318832932, 325004611, 325419805, 328878574, 331828948, 334695532, 336707124, 338723834, 345466806, 347825987, 348375923, 352562414, 353017924, 356580639, 359333139, 375240980, 375442795, 395211672, 399800560, 399964207, 401985360, 404153790, 407283053, 409771252, 409871691, 414504008, 418482770, 422635611, 432950325, 437335495, 437701574, 440905673, 440996547, 445440548, 451001976, 452737314, 457610094, 458405978, 461760340, 468296958, 468751485, 473924783, 478746067, 480756972, 482248426, 484018937, 484160680, 493894576, 494723638, 498246993, 501039929, 506461556, 509857466, 515606669, 519817503, 520590566, 526954423, 527406035, 527490381, 528448451, 528646289, 530261339, 532777525, 534349308, 543288878, 548797560, 552155691, 561678025, 563316893, 567295091, 567376937, 574242431, 580268314, 580268315, 580268316, 591388427, 593501699, 596483356, 596496232, 598146609, 602388920, 605794921, 612078321, 614073432, 623100778, 625308696, 635585484, 635698545, 641357653, 641535602, 652994848, 668032171, 668559967, 669455771, 669777183, 672521557, 674203586, 691754853, 695779780, 701410669, 707030723, 713395287, 724060212, 729151262, 735026061, 735461151, 739961796, 743881640, 749390196, 756124597, 756648534, 756772439, 757195787, 767112783, 770356263, 774351884, 779631889, 784433846, 786212844, 786627854, 791442325, 809821035, 812768068, 815911746, 817595090, 817646368, 820248982, 824807522, 827703867, 829159484, 833169059, 834174833, 843587180, 845179051, 845339077, 858834168, 864122889, 872071561, 873828157, 878103594, 887574448, 891567758, 891724542, 897372503, 897845290, 900064139, 900325406, 901545040, 904319558, 905300514, 910198946, 912799388, 913729232, 916255977, 922163277, 922671056, 927738905, 930255216, 932127235, 934297389, 935687251, 936862869, 938785383, 942032222, 944645571, 946786476, 949813391, 950411186, 952497064, 953972955, 959399230, 959828132, 961866285, 968096930, 971992536, 974474010, 977120855, 983881407, 985194240, 989248790, 992442663, 993950564, 995006396, 999967216, 1002257126, 1002304485, 1009618522, 1014900378, 1018962181, 1033706018, 1034633683, 1035493184, 1035493615, 1035495845, 1035643931, 1035697007, 1035893693, 1036089706, 1036091488, 1036140334, 1036142564, 1036192513, 1036242015, 1036388972, 1036388976, 1036639849, 1046660463, 1050589840, 1056766449, 1058156409, 1058559650, 1067098605, 1067353468, 1071652316, 1072490607, 1072885311, 1076899448, 1077020275, 1078287196, 1080516578, 1081532264, 1084792286, 1087583414, 1091627025, 1095941093, 1099121107, 1102421591, 1103409453, 1103412149, 1111933837, 1113806382, 1114501250, 1119001952, 1126920507, 1135983070, 1136065450, 1136683204, 1145269635, 1145652951, 1145964956, 1148579289, 1152408707, 1154932936, 1155848147, 1156703304, 1157054759, 1158164430, 1158359328, 1160063696, 1162641820, 1167016303, 1170141094, 1170195731, 1171614398, 1171632074, 1171998432, 1172057283, 1177119554, 1178534771, 1181037546, 1189625680, 1190024619, 1190472412, 1191633330, 1191633331, 1191633332, 1191633333, 1191633334, 1191633335, 1191633396, 1202718727, 1202920542, 1204816148, 1204921660, 1211773292, 1213952397, 1214913502, 1217168287, 1223543318, 1223769091, 1224700491, 1224901875, 1225098545, 1225397154, 1227603512, 1232990044, 1234680156, 1234833487, 1236634561, 1245800482, 1246877401, 1246881189, 1247576961, 1247723251, 1247875320, 1247875546, 1248930088, 1253218098, 1255123065, 1255711457, 1266639612, 1267254207, 1267652702, 1268319210, 1269755426, 1271070480, 1273207865, 1274099839, 1275922997, 1277661686, 1280544829, 1280549057, 1280844532, 1280845662, 1281091404, 1281093634, 1282943179, 1285493813, 1290076915, 1291299698, 1291438162, 1292082402, 1292432058, 1293753579, 1300523587, 1301332577, 1301518156, 1301739773, 1302994698, 1305902387, 1306042327, 1307539969, 1313416818, 1313702500, 1322701598, 1323398036, 1324507718, 1324905541, 1327174177, 1327743821, 1329111435, 1337394146, 1345725012, 1348037855, 1352786672, 1356710440, 1356913315, 1357975336, 1365803947, 1365938775, 1367059365, 1378150328, 1378548600, 1386842537, 1395555037, 1401610182, 1403888146, 1413779326, 1416060759, 1416900059, 1428431209, 1428901784, 1429408506, 1429879265, 1429880378, 1429881052, 1429882389, 1429883725, 1429887281, 1447008734, 1447559301, 1447713067, 1449063405, 1450762973, 1457436259, 1472538352, 1484140085, 1486585372, 1490314190, 1491547185, 1492254877, 1492589217, 1498988350, 1503494953, 1503837296, 1504438184, 1506245288, 1514826057, 1516540973, 1519612850, 1527503353, 1531583505, 1532226885, 1532710347, 1537812987, 1538992354, 1547539107, 1548166113, 1550374530, 1550374544, 1553877950, 1562364241, 1563286311, 1567044684, 1568593144, 1576149820, 1591456987, 1593747570, 1604324540, 1607725224, 1611637576, 1613546638, 1614780307, 1619211300, 1620824029, 1621420777, 1622172873, 1622659719, 1623148745, 1623478022, 1625090562, 1639293562, 1640272491, 1646748290, 1648581351, 1660395368, 1662801175, 1664441834, 1666522617, 1669413332, 1670201788, 1675742188, 1679068237, 1682599598, 1692511090, 1694141473, 1694977701, 1705629508, 1706095073, 1710056228, 1719976687, 1722066026, 1723805383, 1729708482, 1732085673, 1733581463, 1734625019, 1738748884, 1755247161, 1755441595, 1763822423, 1768164316, 1768548618, 1769455336, 1771130534, 1772033309, 1772460393, 1781145963, 1792879344, 1796247438, 1800128893, 1800401972, 1800886518, 1801622666, 1802291657, 1804873517, 1807294090, 1813879407, 1825405726, 1830310359, 1833878517, 1835399246, 1842894384, 1844460293, 1847555063, 1851249714, 1853632417, 1860022104, 1861441745, 1863724791, 1864494649, 1867552145, 1870897157, 1871197055, 1875783245, 1876572813, 1877582685, 1880508672, 1888206354, 1891834246, 1894671199, 1899349409, 1906044191, 1908137560, 1910916751, 1913895454, 1914062777, 1914261701, 1914813385, 1915348798, 1915412854, 1916009602, 1917396012, 1924220463, 1926178603, 1929714430, 1932118984, 1933030290, 1934108263, 1938661668, 1942915443, 1952928973, 1958850432, 1981972957, 1992086385, 1993666373, 1998756496, 2004258598, 2014410004, 2015150409, 2021219865, 2022294396, 2025055113, 2025114945, 2025584634, 2026116049, 2026378982, 2026819210, 2031558928, 2031559387, 2033442181, 2038277274, 2048392659, 2049945213, 2051693520, 2054959757, 2062397850, 2063734536, 2066099639, 2082663554, 2082702159, 2084789794, 2084838095, 2087824363, 2093796797, 2096737219, 2101478163, 2101966206, 2107659471, 2113364337, 2114654979, 2116234972, 2119112786, 2121498314, 2122013131, 2123232567, 2127021138, 2133490940, 2137631107, 2137714887, 2140014923, 2143813817, 2144839341, 2145735145};
		
		protected static string[] fields = new string[]{"a", "b", "c", "d", "e", "f", "h", "i", "k", "l", "m", "o", "q", "r", "s", "t", "v", "x", "y", "_0", "_1", "_2", "_3", "_4", "_5", "at", "cw", "m2", "or", "testNegate", "isGlobal", "__a", "abc", "abs", "add", "age", "and", "arr", "bar", "baz", "big", "buf", "ccw", "cls", "cur", "den", "div", "exp", "foo", "get", "has", "key", "len", "map", "max", "min", "not", "num", "or4", "pop", "pos", "pow", "res", "run", "set", "src", "str", "sub", "sum", "xor", "protocol", "testApplyIndexes", "moduloWithScale", "split", "teardown", "testOverflowing", "testEllipsisMiddle", "testVal4Nel", "compareTo", "testOrMethod", "keyIndex", "ceilTo", "flags", "testToBigInt", "testMaxInts", "testNullArgument", "slashes", "testMaxStrings", "match", "testBitwiseOperations", "testTraverseOption", "compare", "testNullArgumentUsing", "addSuccesses", "testIsUnit", "start", "stats", "failures", "executeMethod", "successes", "remove", "packageName", "testPrevNext", "nullUsingInt", "filter", "testFromNative", "merge", "testCrossMulti", "testFeatures", "startTime", "progress", "testParse", "hasSetup", "target", "testBigIntParsesNumbersCorrectly", "testIsZero", "hashCode", "testFilterFn", "testPathTo", "resize", "result", "warnings", "testNearEqualsFail", "method", "matched", "addErrors", "tuples", "testWrapColumnLong", "testBitSet", "testSameInstance", "behavior", "testDivisionBySelfIs1", "testConstructorLiteral", "subtractBig", "parseString", "newline", "roundTo", "roundUp", "setLoop", "testFindLast", "testFromArray", "testMultiply", "tests", "stackToString", "compareArg", "testChars", "testWrapColumnPreserveNewLines", "testPower", "append", "testDynamics", "onPrecheck", "testPowerHandlesSignsCorrectly", "getPackage", "assertations", "string", "testClamp", "testClone", "getObject", "_trace", "methodName", "hasErrors", "testArrayToString", "packageNames", "testReduceRight", "assertSnapNext", "testCount", "iterator", "get_getter", "indent", "toInt", "testAlphaNum", "dateutc", "assertSnapPrev", "testFromInt", "testCreate", "testHasPathValue", "testStripTags", "lastIndexOf", "testToLeft", "testToList", "testReduce", "testUsingMapFieldiOnFunction", "totals", "testIsRelativeAndIsAbsolute", "replacer", "hasNext", "testFibonacci", "onAddFailures", "setHandler", "innerError", "newId", "testLcmAndGcd", "message", "testIsImmutable", "testFindFnLast", "onStart", "multiply", "keysLoop", "reverse", "testAddition", "testToLeftUnsafe", "testAbstract", "testMultiplyHandlesSignsCorectly", "isSmall", "testSamePrimitive", "expireson", "nOccupied", "onTestComplete", "onAddWarnings", "nullInt", "testEnsure", "testRemove", "testMinString", "insert", "dumpStack", "dispatch", "testFromBools", "addBig", "length", "testDifferAt", "testFindFn", "testRepeat", "getTime", "testContains", "addAsync", "testZip5Ap", "plusOneBag", "testFoldLeftKeys", "testMultiplication", "testNormalization", "number", "allOk", "testScaleTo", "testUcwords", "testMergeWithTypedef", "testTuple0", "testTuple1", "testTuple2", "getter", "toStringWithBase", "balance", "setupName", "testFlatMap", "testToTuples", "testMaxFloats", "testNegativePow", "matchedRight", "hasTeardownError", "nextRun", "emptyArray", "testFromInt64", "displaySuccessResults", "methods", "invalidNumber", "getOption", "emptyIterable", "emptyIterator", "testSplitBy", "testCanHandleLargeNumbers", "getClass", "addPackage", "testIsEvenAndIsOdd", "invalidChar", "testString", "testSnapTo", "replace", "testToString", "onAddErrors", "setTimeout", "testInterpolateAngle", "testCompactFloats", "testSplitByPad", "testToRightUnsafe", "testIncrements", "removeAt", "testRange", "onAddSuccesses", "testOrderedSet", "testEmptyString", "testCompactStrings", "pretty", "testToArray", "compareToAbsBig", "testReplaceAt", "testIssue20151201", "testOrderFn", "onTimeout", "compareToAbs", "compareToBig", "testEachi", "oldId", "testComparison", "testBitMatrix", "testLeftMap", "value", "asyncStack", "quotient", "precheck", "testPowerOf0to0is1", "withoutValue", "aggregator", "testBooleans", "fieldsString", "onTested", "addHeader", "testInsertAt", "testUnshift", "addFailures", "withValue", "testFilterNullInt", "testStrings", "testIntersperse", "testOrderFnObjectOfFloat", "compareArgs", "testRound", "other", "testAbsolute", "testCombine", "cachedIndex", "checkTested", "change", "random", "globalPattern", "testModulo0ThrowsError", "compareToAbsSmall", "testMapFieldOnFunction", "testOperations", "success", "toString", "testOptionalArgs", "testToInt32s", "testFromToString", "testEmpty", "identity", "testSameMap", "packages", "testRtrim", "addWarnings", "testFoldLeft", "testOrWithIndex", "testPowerToNegativeNumbersIs0", "getResults", "divModSmall", "methodNames", "priority", "hashes", "runner", "hasAsyncError", "remainder", "testSameEnums", "toObject", "tomorrow", "testSymmetricDifference", "hostName", "testAbs", "testAdd", "testAnd", "testDir", "testExt", "testInt", "testMap", "testMin", "testNew", "testNow", "testOpt", "testPop", "testSep", "testSet", "testXor", "displayHeader", "pathName", "divMod", "divide", "testObjects", "testMergeWithNullable", "splice", "exists", "setValue", "equals", "expected", "testCompare", "testToBools", "testPrevNextCarriesOverCorrectly", "auth", "addResult", "modulo", "base", "isOdd", "getFixture", "addClass", "code", "copy", "bindHandler", "date", "done", "testIsRight", "matchSub", "fail", "testSameIterable", "testGroupBy", "testBase", "testNegation", "testBool", "expect", "upperMatch", "removeLoop", "minBinding", "testChar", "testCopy", "hash", "head", "testShift", "testLtrim", "testAverageInts", "isOk", "item", "testEmptyArray", "handler", "testSizes", "getOrCreateClass", "testFnRight", "testEach", "join", "testFail", "testFind", "testFrom", "key1", "key2", "key3", "key4", "key5", "key6", "keys", "left", "list", "concat", "testCarriesOverCorrectly", "testEquality", "clear", "testShiftingLeftAndRight", "testDivision", "testInts", "multiplySmall", "name", "next", "nind", "noop", "testSortFn", "hasTestError", "testJoin", "exception", "orig", "flattenPackage", "pack", "path", "port", "prev", "pure", "push", "testSplit", "testWrapColumn", "testGroupByInstance", "testIssue82", "testInStringInterpolation", "testMapi", "testMisc", "testFloat", "root", "matchedPos", "current", "isNegative", "execute", "toDateTime", "sign", "size", "some", "sort", "step", "stop", "quicksort", "testSetPath", "testOnce", "recursive", "test", "trim", "type", "testArrayAccess", "testPass", "testNotImplemented", "testPush", "testForms", "assertDecimalEquals", "testNumbersShouldBeTheSameWhenConstructedDifferently", "testMinFloats", "testIsPositiveAndIsNegativeWorkForBigNumbers", "vals", "testModuloHandlesSignsCorrectly", "testRank", "testRoot", "warn", "wire", "toFloat", "testJoinString", "completed", "values", "testTrim", "write", "spliceVoid", "testUpTo", "testUtf8", "zero", "errors", "testMinBy", "testVal4", "testWarn", "testWith", "shiftLeft", "cachedKey", "testRounding", "testMapRight", "hasTeardown", "testDateTimeUtc", "fromString", "handlers", "stackItems", "equality", "testAp", "testFn", "testIs", "testOr", "testUp", "tested", "runNext", "testUcwordsws", "testControl", "testHasPath", "parseRec", "hasFailures", "testReverse", "testGroupByArray", "ensureField", "testExists", "testEquals", "square", "timeout", "emptyString", "testGetPath", "classNames", "addFixture", "testModulo", "testFloats", "createFixture", "testSameType", "testGetOption", "hasWarnings", "testFromToDate", "concatNative", "nBuckets", "testAverageFloats", "className", "hasTimeoutError", "logged", "logger", "runFixture", "testRaisesFailure", "compareToSmall", "testExpand", "onComplete", "quote", "testNormalize", "keyAt", "existsClass", "testMemoize", "get_setter", "divisionSize", "offset", "isEven", "__unsafe_get", "__unsafe_set", "testIgnoreLeadingZeros", "indents", "indexOf", "testConcat", "testSubtraction", "lookup", "isMethod", "testCopyTo", "fileName", "search", "testPresetLength", "testDivisionBy1IsTheIdentity", "queryString", "unbindHandler", "set_setter", "onProgress", "testRotate", "testDistinct", "iteratorLoop", "testAssign", "scaleTo", "toDynamic", "valueIndex", "testFromToTime", "testDifference", "testAfter", "regex", "negate", "testFunctions", "oldLogger", "testRemovePath", "testEffectsLog", "testHumanize", "testIntersection", "testDivisionOf0Equals0", "right", "existsPackage", "testMapList", "classes", "plusTwoBags", "catches", "__hx_constructs", "testMapField", "isUnit", "testTraverseValidation", "testToWin32ToNix", "results", "fixtures", "checkMethod", "getClassName", "testNearEqualsSuccess", "teardownName", "unwire", "customParams", "testOrderFnObjectOfInt", "round", "testUsingMapField", "matchScale", "testBasics", "isZero", "testObjectSet2", "symbol", "getOrCreatePackage", "nested", "addEvent", "onTestStart", "hasSetupError", "setter", "testLowerUpperCaseFirst", "empty", "testUnion", "testNotEquals", "testFromToBools", "_height", "getPosition", "testSameArray", "newKey", "testFillEmpty", "testSquare", "toArray", "foo bar", "foo faz", "fixture", "testClampSym", "__get", "__set", "testLocalOffset", "testToRight", "testComplete", "testBigIntOutputsNumbersCorrectly", "error", "testUsing", "floorTo", "testMinInts", "testEscape", "testFromString", "testFindOption", "lineNumber", "testObjectSet", "toBool", "extra", "testIsBool", "subtract", "toDate", "testConstructorFromTypedef", "upperBound", "unshift", "testIsPositiveAndIsNegative", "shiftRight", "testAddMonth", "addSmall", "scale", "testContainsAll", "testContainsAny", "testOffset", "testIsPositiveAndIsNegativeWorkForSmallNumbers", "_keys", "setup", "roundDown", "testHashCode", "testStringExp", "testNotNull", "testSameObject", "shift", "divModBig", "__hx_createEmpty", "testSnapNext", "divideWithScale", "testPowerCarriesOverCorrectly", "testEllipsis", "subtractSmall", "testAngleDifference", "testSnapPrev", "addCase", "testIsLeft", "testOrder", "testToLines", "testRaisesSuccess", "assertSnapTo", "removeMinBinding", "slice", "multiplyBig", "testIsNull", "small", "_handler", "complete", "testEmptyIterable", "testEmptyIterator"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::haxe.lang.FieldLookup.fieldIds;
				string[] cfields = global::haxe.lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::haxe.lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Different fields length: ", global::haxe.lang.Runtime.toString(nlen)), " and "), global::haxe.lang.Runtime.toString(( nfields as global::System.Array ).Length)));
				}
				
				bool needsChange = false;
				{
					int[] _g_arr = nids;
					uint _g_idx = ((uint) (0) );
					while (((bool) (( _g_idx < ( _g_arr as global::System.Array ).Length )) )) {
						if (( global::haxe.lang.FieldLookup.findHash(((int) (_g_arr[((int) (_g_idx++) )]) ), cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::haxe.lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( ( ci < clen ) && ( ni < nlen ) ))) ) {
								break;
							}
							
							if (( cids[ci] < nids[ni] )) {
								ansIds[ansi] = cids[ci];
								ansFields[ansi] = cfields[ci];
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = nids[ni];
								ansFields[ansi] = nfields[ni];
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::haxe.lang.FieldLookup.fieldIds = ansIds;
						global::haxe.lang.FieldLookup.fields = ansFields;
						global::haxe.lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ((int) (( (( max - min )) / 2 )) ) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return global::haxe.lang.FieldLookup.fields[mid];
					}
					
				}
				
				throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat("Field not found for hash ", global::haxe.lang.Runtime.toString(key)));
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (string.Equals(s, null)) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				string[] fld = global::haxe.lang.FieldLookup.fields;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				int len = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						if ( ! (string.Equals(fld[mid], s)) ) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::haxe.lang.FieldLookup)){
					if (( len != global::haxe.lang.FieldLookup.length )) {
						return global::haxe.lang.FieldLookup.hash(s);
					}
					
					global::haxe.lang.FieldLookup.insert<int>(ref global::haxe.lang.FieldLookup.fieldIds, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((int) (key) ));
					global::haxe.lang.FieldLookup.insert<string>(ref global::haxe.lang.FieldLookup.fields, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((string) (s) ));
					 ++ global::haxe.lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ((int) (( (( max + min )) / 2 )) );
					int imid = hashs[mid];
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void @remove<T>(T[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = default(T);
			}
		}
		
		
		public static void insert<T>(ref T[] a, int length, int pos, T x) {
			unchecked {
				int capacity = ( a as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						T[] newarr = new T[( (( length << 1 )) + 1 )];
						( a as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a = ((T[]) (newarr) );
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						T[] newarr1 = new T[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a = ((T[]) (newarr1) );
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					T[] newarr2 = new T[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a = ((T[]) (newarr2) );
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a[pos] = x;
			}
		}
		
		
	}
}


