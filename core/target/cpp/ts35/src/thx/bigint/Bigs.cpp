// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "cpp/Int64.h"
#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_StringTools
#include <StringTools.h>
#endif
#ifndef INCLUDED_haxe_StackItem
#include <haxe/StackItem.h>
#endif
#ifndef INCLUDED_thx_Assert
#include <thx/Assert.h>
#endif
#ifndef INCLUDED_thx_Error
#include <thx/Error.h>
#endif
#ifndef INCLUDED_thx_Int64s
#include <thx/Int64s.h>
#endif
#ifndef INCLUDED_thx_Ints
#include <thx/Ints.h>
#endif
#ifndef INCLUDED_thx_Strings
#include <thx/Strings.h>
#endif
#ifndef INCLUDED_thx_bigint_Big
#include <thx/bigint/Big.h>
#endif
#ifndef INCLUDED_thx_bigint_BigIntImpl
#include <thx/bigint/BigIntImpl.h>
#endif
#ifndef INCLUDED_thx_bigint_Bigs
#include <thx/bigint/Bigs.h>
#endif
#ifndef INCLUDED_thx_bigint_Small
#include <thx/bigint/Small.h>
#endif

namespace thx{
namespace bigint{

void Bigs_obj::__construct() { }

Dynamic Bigs_obj::__CreateEmpty() { return new Bigs_obj; }

hx::ObjectPtr< Bigs_obj > Bigs_obj::__new()
{
	hx::ObjectPtr< Bigs_obj > _hx_result = new Bigs_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Bigs_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Bigs_obj > _hx_result = new Bigs_obj();
	_hx_result->__construct();
	return _hx_result;
}

Int Bigs_obj::BASE;

Float Bigs_obj::DOUBLE_BASE;

Int Bigs_obj::LOG_BASE;

Int Bigs_obj::MAX_INT;

::Array< Int > Bigs_obj::MAX_INT_ARR;

Float Bigs_obj::LOG_MAX_INT;

::Array< Int > Bigs_obj::powersOfTwo;

::Array< ::Dynamic> Bigs_obj::bigPowersOfTwo;

Int Bigs_obj::powers2Length;

Int Bigs_obj::highestPower2;

::Dynamic Bigs_obj::bigHighestPower2;

Bool Bigs_obj::isPrecise(Int value){
            	HX_STACK_FRAME("thx.bigint.Bigs","isPrecise",0x3511dd2b,"thx.bigint.Bigs.isPrecise","thx/bigint/Bigs.hx",25,0xb6bbbc16)
            	HX_STACK_ARG(value,"value")
HXLINE(  25)		if ((-(::thx::bigint::Bigs_obj::MAX_INT) < value)) {
HXLINE(  25)			return (value < ::thx::bigint::Bigs_obj::MAX_INT);
            		}
            		else {
HXLINE(  25)			return false;
            		}
HXDLIN(  25)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,isPrecise,return )

Bool Bigs_obj::canMultiply(Int a,Int b){
            	HX_STACK_FRAME("thx.bigint.Bigs","canMultiply",0x6e133e6e,"thx.bigint.Bigs.canMultiply","thx/bigint/Bigs.hx",27,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE(  28)		Bool _hx_tmp;
HXDLIN(  28)		if ((a != (int)0)) {
HXLINE(  28)			_hx_tmp = (b == (int)0);
            		}
            		else {
HXLINE(  28)			_hx_tmp = true;
            		}
HXDLIN(  28)		if (_hx_tmp) {
HXLINE(  28)			return true;
            		}
HXLINE(  29)		HX_VARI( Int,v) = (a * b);
HXLINE(  30)		if ((a != ((Float)v / (Float)b))) {
HXLINE(  30)			return false;
            		}
HXLINE(  31)		return ::thx::bigint::Bigs_obj::isPrecise(v);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,canMultiply,return )

Bool Bigs_obj::canPower(Int a,Int b){
            	HX_STACK_FRAME("thx.bigint.Bigs","canPower",0xd14fbd7b,"thx.bigint.Bigs.canPower","thx/bigint/Bigs.hx",34,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE(  35)		Bool _hx_tmp;
HXDLIN(  35)		if ((a != (int)0)) {
HXLINE(  35)			_hx_tmp = (b == (int)0);
            		}
            		else {
HXLINE(  35)			_hx_tmp = true;
            		}
HXDLIN(  35)		if (_hx_tmp) {
HXLINE(  35)			return true;
            		}
HXLINE(  36)		HX_VARI_NAME( Float,a1,"a") = ::Math_obj::abs(a);
HXLINE(  37)		HX_VARI_NAME( Float,b1,"b") = ::Math_obj::abs(b);
HXLINE(  38)		HX_VAR( Int,v);
HXLINE(  39)		try {
            			HX_STACK_CATCHABLE( ::Dynamic, 0);
HXLINE(  40)			Float _hx_tmp1 = ::Math_obj::pow(a1,b1);
HXDLIN(  40)			v = ::Std_obj::_hx_int(_hx_tmp1);
            		}
            		catch( ::Dynamic _hx_e){
            			if (_hx_e.IsClass<  ::Dynamic >() ){
            				HX_STACK_BEGIN_CATCH
            				 ::Dynamic e = _hx_e;
HXLINE(  42)				return false;
            			}
            			else {
            				HX_STACK_DO_THROW(_hx_e);
            			}
            		}
HXLINE(  44)		Float _hx_tmp2 = ::Math_obj::pow(v,((Float)((Float)1.0) / (Float)b1));
HXDLIN(  44)		Int _hx_tmp3 = ::Std_obj::_hx_int(_hx_tmp2);
HXDLIN(  44)		if ((_hx_tmp3 != a1)) {
HXLINE(  45)			return false;
            		}
HXLINE(  46)		return ::thx::bigint::Bigs_obj::isPrecise(v);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,canPower,return )

Bool Bigs_obj::canAdd(Int a,Int b){
            	HX_STACK_FRAME("thx.bigint.Bigs","canAdd",0xf434fa17,"thx.bigint.Bigs.canAdd","thx/bigint/Bigs.hx",49,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE(  50)		HX_VARI( Int,v) = (a + b);
HXLINE(  51)		Bool _hx_tmp;
HXDLIN(  51)		Bool _hx_tmp1;
HXDLIN(  51)		if ((a > (int)0)) {
HXLINE(  51)			_hx_tmp1 = (b > (int)0);
            		}
            		else {
HXLINE(  51)			_hx_tmp1 = false;
            		}
HXDLIN(  51)		if (_hx_tmp1) {
HXLINE(  51)			_hx_tmp = (v < (int)0);
            		}
            		else {
HXLINE(  51)			_hx_tmp = false;
            		}
HXDLIN(  51)		if (_hx_tmp) {
HXLINE(  52)			return false;
            		}
HXLINE(  53)		return ::thx::bigint::Bigs_obj::isPrecise(v);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,canAdd,return )

::Array< Int > Bigs_obj::smallToArray(Int n){
            	HX_STACK_FRAME("thx.bigint.Bigs","smallToArray",0xe158a2bd,"thx.bigint.Bigs.smallToArray","thx/bigint/Bigs.hx",56,0xb6bbbc16)
            	HX_STACK_ARG(n,"n")
HXLINE(  57)		::thx::Assert_obj::isTrue((n >= (int)0),(HX_("Bigs.smallToArray should always be non-negative: ",06,94,ab,08) + n),hx::SourceInfo(HX_("Bigs.hx",cb,0c,6e,4e),57,HX_("thx.bigint.Bigs",88,bd,8e,8b),HX_("smallToArray",17,a8,6e,22)));
HXLINE(  58)		if ((n < (int)10000000)) {
HXLINE(  59)			return ::Array_obj< Int >::__new(1)->init(0,n);
            		}
HXLINE(  60)		if ((n < ((Float)100000000000000.0))) {
HXLINE(  61)			Int _hx_tmp = hx::Mod(n,(int)10000000);
HXDLIN(  61)			Int _hx_tmp1 = ::Math_obj::floor(((Float)n / (Float)(int)10000000));
HXDLIN(  61)			return ::Array_obj< Int >::__new(2)->init(0,_hx_tmp)->init(1,_hx_tmp1);
            		}
HXLINE(  62)		Int _hx_tmp2 = hx::Mod(n,(int)10000000);
HXDLIN(  62)		Int _hx_tmp3 = ::Math_obj::floor(((Float)n / (Float)(int)10000000));
HXDLIN(  62)		Int _hx_tmp4 = hx::Mod(_hx_tmp3,(int)10000000);
HXDLIN(  62)		Int _hx_tmp5 = ::Math_obj::floor(((Float)n / (Float)((Float)100000000000000.0)));
HXDLIN(  62)		return ::Array_obj< Int >::__new(3)->init(0,_hx_tmp2)->init(1,_hx_tmp4)->init(2,_hx_tmp5);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,smallToArray,return )

 ::Dynamic Bigs_obj::arrayToSmall(::Array< Int > arr){
            	HX_STACK_FRAME("thx.bigint.Bigs","arrayToSmall",0xbc38c759,"thx.bigint.Bigs.arrayToSmall","thx/bigint/Bigs.hx",65,0xb6bbbc16)
            	HX_STACK_ARG(arr,"arr")
HXLINE(  66)		::thx::bigint::Bigs_obj::trim(arr);
HXLINE(  67)		HX_VARI( Int,length) = arr->length;
HXLINE(  68)		Bool _hx_tmp;
HXDLIN(  68)		if ((length < (int)4)) {
HXLINE(  68)			_hx_tmp = (::thx::bigint::Bigs_obj::compareToAbs(arr,::thx::bigint::Bigs_obj::MAX_INT_ARR) < (int)0);
            		}
            		else {
HXLINE(  68)			_hx_tmp = false;
            		}
HXDLIN(  68)		if (_hx_tmp) {
HXLINE(  69)			switch((int)(length)){
            				case (int)0: {
HXLINE(  70)					return (int)0;
            				}
            				break;
            				case (int)1: {
HXLINE(  71)					return arr->__get((int)0);
            				}
            				break;
            				case (int)2: {
HXLINE(  72)					return (arr->__get((int)0) + (arr->__get((int)1) * (int)10000000));
            				}
            				break;
            				default:{
HXLINE(  73)					return (arr->__get((int)0) + ((arr->__get((int)1) + (arr->__get((int)2) * (int)10000000)) * (int)10000000));
            				}
            			}
            		}
HXLINE(  76)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,arrayToSmall,return )

void Bigs_obj::trim(::Array< Int > v){
            	HX_STACK_FRAME("thx.bigint.Bigs","trim",0x6edf8188,"thx.bigint.Bigs.trim","thx/bigint/Bigs.hx",80,0xb6bbbc16)
            	HX_STACK_ARG(v,"v")
HXLINE(  80)		while((v->length > (int)1)){
HXLINE(  81)			if ((v->__get((v->length - (int)1)) != (int)0)) {
HXLINE(  82)				goto _hx_goto_0;
            			}
HXLINE(  83)			v->pop();
            		}
            		_hx_goto_0:;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,trim,(void))

::Array< Int > Bigs_obj::createArray(Int length){
            	HX_STACK_FRAME("thx.bigint.Bigs","createArray",0xf2e94117,"thx.bigint.Bigs.createArray","thx/bigint/Bigs.hx",87,0xb6bbbc16)
            	HX_STACK_ARG(length,"length")
HXLINE(  88)		HX_VARI( ::Array< Int >,x) = ::Array_obj< Int >::__new(0);
HXLINE(  89)		{
HXLINE(  89)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  89)			while((_g1 < length)){
HXLINE(  89)				HX_VARI( Int,i) = _g1++;
HXLINE(  90)				x[i] = (int)0;
            			}
            		}
HXLINE(  91)		return x;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,createArray,return )

::Array< Float > Bigs_obj::createFloatArray(Int length){
            	HX_STACK_FRAME("thx.bigint.Bigs","createFloatArray",0x2249061f,"thx.bigint.Bigs.createFloatArray","thx/bigint/Bigs.hx",94,0xb6bbbc16)
            	HX_STACK_ARG(length,"length")
HXLINE(  95)		HX_VARI( ::Array< Float >,x) = ::Array_obj< Float >::__new(0);
HXLINE(  96)		{
HXLINE(  96)			HX_VARI( Int,_g1) = (int)0;
HXDLIN(  96)			while((_g1 < length)){
HXLINE(  96)				HX_VARI( Int,i) = _g1++;
HXLINE(  97)				x[i] = ((Float)0.0);
            			}
            		}
HXLINE(  98)		return x;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,createFloatArray,return )

::Array< Int > Bigs_obj::add(::Array< Int > a,::Array< Int > b){
            	HX_STACK_FRAME("thx.bigint.Bigs","add",0x9361e43b,"thx.bigint.Bigs.add","thx/bigint/Bigs.hx",101,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 102)		HX_VARI( Int,l_a) = a->length;
HXDLIN( 102)		HX_VARI( Int,l_b) = b->length;
HXDLIN( 102)		HX_VARI( ::Array< Int >,r) = ::Array_obj< Int >::__new(0);
HXDLIN( 102)		HX_VARI( Int,carry) = (int)0;
HXDLIN( 102)		HX_VAR( Int,sum);
HXDLIN( 102)		HX_VARI( Int,i) = (int)0;
HXLINE( 107)		while((i < l_b)){
HXLINE( 108)			sum = ((a->__get(i) + b->__get(i)) + carry);
HXLINE( 109)			if ((sum >= (int)10000000)) {
HXLINE( 109)				carry = (int)1;
            			}
            			else {
HXLINE( 109)				carry = (int)0;
            			}
HXLINE( 110)			Int _hx_tmp = i++;
HXDLIN( 110)			r[_hx_tmp] = (sum - (carry * (int)10000000));
            		}
HXLINE( 112)		while((i < l_a)){
HXLINE( 113)			sum = (a->__get(i) + carry);
HXLINE( 114)			if ((sum == (int)10000000)) {
HXLINE( 114)				carry = (int)1;
            			}
            			else {
HXLINE( 114)				carry = (int)0;
            			}
HXLINE( 115)			Int _hx_tmp1 = i++;
HXDLIN( 115)			r[_hx_tmp1] = (sum - (carry * (int)10000000));
            		}
HXLINE( 117)		if ((carry > (int)0)) {
HXLINE( 117)			r->push(carry);
            		}
HXLINE( 118)		return r;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,add,return )

::Array< Int > Bigs_obj::addAny(::Array< Int > a,::Array< Int > b){
            	HX_STACK_FRAME("thx.bigint.Bigs","addAny",0xdb15e571,"thx.bigint.Bigs.addAny","thx/bigint/Bigs.hx",121,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 122)		Bool _hx_tmp = (a->length >= b->length);
HXDLIN( 122)		if (_hx_tmp) {
HXLINE( 122)			return ::thx::bigint::Bigs_obj::add(a,b);
            		}
HXLINE( 123)		return ::thx::bigint::Bigs_obj::add(b,a);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,addAny,return )

::Array< Int > Bigs_obj::addSmall(::Array< Int > a,Int carry){
            	HX_STACK_FRAME("thx.bigint.Bigs","addSmall",0x94ea468c,"thx.bigint.Bigs.addSmall","thx/bigint/Bigs.hx",126,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(carry,"carry")
HXLINE( 127)		HX_VARI( Int,l) = a->length;
HXDLIN( 127)		HX_VARI( ::Array< Int >,r) = ::Array_obj< Int >::__new(0);
HXDLIN( 127)		HX_VAR( Int,sum);
HXDLIN( 127)		HX_VARI( Int,i) = (int)0;
HXLINE( 130)		while((i < l)){
HXLINE( 131)			sum = ((a->__get(i) - (int)10000000) + carry);
HXLINE( 132)			carry = ::Math_obj::floor(((Float)sum / (Float)(int)10000000));
HXLINE( 133)			Int _hx_tmp = i++;
HXDLIN( 133)			r[_hx_tmp] = (sum - (carry * (int)10000000));
HXLINE( 134)			++carry;
            		}
HXLINE( 136)		while((carry > (int)0)){
HXLINE( 137)			Int _hx_tmp1 = i++;
HXDLIN( 137)			r[_hx_tmp1] = hx::Mod(carry,(int)10000000);
HXLINE( 138)			carry = ::Math_obj::floor(((Float)carry / (Float)(int)10000000));
            		}
HXLINE( 140)		return r;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,addSmall,return )

Int Bigs_obj::compareToAbs(::Array< Int > a,::Array< Int > b){
            	HX_STACK_FRAME("thx.bigint.Bigs","compareToAbs",0x6fa57d78,"thx.bigint.Bigs.compareToAbs","thx/bigint/Bigs.hx",143,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 144)		if ((a->length != b->length)) {
HXLINE( 145)			if ((a->length > b->length)) {
HXLINE( 145)				return (int)1;
            			}
            			else {
HXLINE( 145)				return (int)-1;
            			}
            		}
HXLINE( 146)		HX_VARI( Int,i) = a->length;
HXLINE( 147)		while(true){
HXLINE( 147)			Int _hx_tmp = --i;
HXDLIN( 147)			if (!((_hx_tmp >= (int)0))) {
HXLINE( 147)				goto _hx_goto_7;
            			}
HXLINE( 148)			if ((a->__get(i) != b->__get(i))) {
HXLINE( 148)				if ((a->__get(i) > b->__get(i))) {
HXLINE( 148)					return (int)1;
            				}
            				else {
HXLINE( 148)					return (int)-1;
            				}
            			}
            		}
            		_hx_goto_7:;
HXLINE( 149)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,compareToAbs,return )

::Array< Int > Bigs_obj::subtract(::Array< Int > a,::Array< Int > b){
            	HX_STACK_FRAME("thx.bigint.Bigs","subtract",0x9433a4ba,"thx.bigint.Bigs.subtract","thx/bigint/Bigs.hx",152,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 153)		HX_VARI( Int,a_l) = a->length;
HXDLIN( 153)		HX_VARI( Int,b_l) = b->length;
HXDLIN( 153)		HX_VARI( ::Array< Int >,r) = ::Array_obj< Int >::__new(0);
HXDLIN( 153)		HX_VARI( Int,borrow) = (int)0;
HXDLIN( 153)		HX_VARI( Int,i) = (int)0;
HXDLIN( 153)		HX_VAR( Int,difference);
HXLINE( 158)		while((i < b_l)){
HXLINE( 159)			difference = ((a->__get(i) - borrow) - b->__get(i));
HXLINE( 160)			Bool _hx_tmp = (difference < (int)0);
HXDLIN( 160)			if (_hx_tmp) {
HXLINE( 161)				hx::AddEq(difference,(int)10000000);
HXLINE( 162)				borrow = (int)1;
            			}
            			else {
HXLINE( 163)				borrow = (int)0;
            			}
HXLINE( 164)			Int _hx_tmp1 = i++;
HXDLIN( 164)			r[_hx_tmp1] = difference;
            		}
HXLINE( 166)		while((i < a_l)){
HXLINE( 167)			difference = (a->__get(i) - borrow);
HXLINE( 168)			if ((difference < (int)0)) {
HXLINE( 168)				hx::AddEq(difference,(int)10000000);
            			}
            			else {
HXLINE( 170)				Int _hx_tmp2 = i++;
HXDLIN( 170)				r[_hx_tmp2] = difference;
HXLINE( 171)				goto _hx_goto_9;
            			}
HXLINE( 173)			Int _hx_tmp3 = i++;
HXDLIN( 173)			r[_hx_tmp3] = difference;
            		}
            		_hx_goto_9:;
HXLINE( 175)		while((i < a_l)){
HXLINE( 176)			r[i] = a->__get(i);
HXLINE( 177)			++i;
            		}
HXLINE( 179)		::thx::bigint::Bigs_obj::trim(r);
HXLINE( 180)		return r;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,subtract,return )

::Dynamic Bigs_obj::subtractAny(::Array< Int > a,::Array< Int > b,Bool sign){
            	HX_STACK_FRAME("thx.bigint.Bigs","subtractAny",0xafce3e52,"thx.bigint.Bigs.subtractAny","thx/bigint/Bigs.hx",183,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(sign,"sign")
HXLINE( 184)		HX_VAR( ::Array< Int >,value);
HXLINE( 185)		if ((::thx::bigint::Bigs_obj::compareToAbs(a,b) >= (int)0)) {
HXLINE( 186)			value = ::thx::bigint::Bigs_obj::subtract(a,b);
            		}
            		else {
HXLINE( 188)			value = ::thx::bigint::Bigs_obj::subtract(b,a);
HXLINE( 189)			sign = !(sign);
            		}
HXLINE( 191)		HX_VARI(  ::Dynamic,n) = ::thx::bigint::Bigs_obj::arrayToSmall(value);
HXLINE( 192)		Bool _hx_tmp = hx::IsNotNull( n );
HXDLIN( 192)		if (_hx_tmp) {
HXLINE( 193)			if (sign) {
HXLINE( 193)				n = -(n);
            			}
HXLINE( 194)			return  ::thx::bigint::Small_obj::__new(n);
            		}
HXLINE( 196)		return  ::thx::bigint::Big_obj::__new(value,sign);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Bigs_obj,subtractAny,return )

::Dynamic Bigs_obj::subtractSmall(::Array< Int > a,Int b,Bool sign){
            	HX_STACK_FRAME("thx.bigint.Bigs","subtractSmall",0x4b1359ad,"thx.bigint.Bigs.subtractSmall","thx/bigint/Bigs.hx",199,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(sign,"sign")
HXLINE( 200)		HX_VARI( Int,l) = a->length;
HXDLIN( 200)		HX_VARI( ::Array< Int >,r) = ::Array_obj< Int >::__new(0);
HXDLIN( 200)		HX_VARI( Int,carry) = -(b);
HXDLIN( 200)		HX_VAR( Int,difference);
HXLINE( 204)		{
HXLINE( 204)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 204)			while((_g1 < l)){
HXLINE( 204)				HX_VARI( Int,i) = _g1++;
HXLINE( 205)				difference = (a->__get(i) + carry);
HXLINE( 206)				carry = ::Math_obj::floor(((Float)difference / (Float)(int)10000000));
HXLINE( 207)				Int _hx_tmp;
HXDLIN( 207)				if ((difference < (int)0)) {
HXLINE( 207)					_hx_tmp = (hx::Mod(difference,(int)10000000) + (int)10000000);
            				}
            				else {
HXLINE( 207)					_hx_tmp = difference;
            				}
HXDLIN( 207)				r[i] = _hx_tmp;
            			}
            		}
HXLINE( 209)		HX_VARI(  ::Dynamic,n) = ::thx::bigint::Bigs_obj::arrayToSmall(r);
HXLINE( 210)		Bool _hx_tmp1 = hx::IsNotNull( n );
HXDLIN( 210)		if (_hx_tmp1) {
HXLINE( 211)			if (sign) {
HXLINE( 211)				n = -(n);
            			}
HXLINE( 212)			return  ::thx::bigint::Small_obj::__new(n);
            		}
HXLINE( 214)		return  ::thx::bigint::Big_obj::__new(r,sign);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Bigs_obj,subtractSmall,return )

::Array< Int > Bigs_obj::multiplyLong(::Array< Int > a,::Array< Int > b){
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		Int _hx_run(Float v){
            			HX_STACK_FRAME("thx.bigint.Bigs","multiplyLong",0x0b8d9066,"thx.bigint.Bigs.multiplyLong","thx/bigint/Bigs.hx",235,0xb6bbbc16)
            			HX_STACK_ARG(v,"v")
HXLINE( 235)			return ::Std_obj::_hx_int(v);
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACK_FRAME("thx.bigint.Bigs","multiplyLong",0x0b8d9066,"thx.bigint.Bigs.multiplyLong","thx/bigint/Bigs.hx",219,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 220)		HX_VARI( Int,a_l) = a->length;
HXDLIN( 220)		HX_VARI( Int,b_l) = b->length;
HXDLIN( 220)		HX_VARI( ::Array< Float >,r) = ::thx::bigint::Bigs_obj::createFloatArray((a_l + b_l));
HXDLIN( 220)		HX_VAR( Float,product);
HXDLIN( 220)		HX_VAR( Float,carry);
HXDLIN( 220)		HX_VAR( Float,a_i);
HXDLIN( 220)		HX_VAR( Float,b_j);
HXLINE( 225)		{
HXLINE( 225)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 225)			while((_g1 < a_l)){
HXLINE( 225)				HX_VARI( Int,i) = _g1++;
HXLINE( 226)				a_i = a->__get(i);
HXLINE( 227)				{
HXLINE( 227)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 227)					while((_g3 < b_l)){
HXLINE( 227)						HX_VARI( Int,j) = _g3++;
HXLINE( 228)						b_j = b->__get(j);
HXLINE( 229)						product = ((a_i * b_j) + r->__get((i + j)));
HXLINE( 230)						HX_VARI( Float,value) = ((Float)product / (Float)(int)10000000);
HXDLIN( 230)						if ((value < ((Float)0.0))) {
HXLINE( 230)							carry = ::Math_obj::fceil(value);
            						}
            						else {
HXLINE( 230)							carry = ::Math_obj::ffloor(value);
            						}
HXLINE( 231)						Int _hx_tmp = (i + j);
HXDLIN( 231)						HX_VARI_NAME( Float,value1,"value") = (product - (carry * (int)10000000));
HXDLIN( 231)						Float _hx_tmp1;
HXDLIN( 231)						if ((value1 < ((Float)0.0))) {
HXLINE( 231)							_hx_tmp1 = ::Math_obj::fceil(value1);
            						}
            						else {
HXLINE( 231)							_hx_tmp1 = ::Math_obj::ffloor(value1);
            						}
HXDLIN( 231)						r[_hx_tmp] = _hx_tmp1;
HXLINE( 232)						hx::AddEq(r[((i + j) + (int)1)],carry);
            					}
            				}
            			}
            		}
HXLINE( 235)		HX_VARI( ::Array< Int >,arr) = r->map( ::Dynamic(new _hx_Closure_0()));
HXLINE( 236)		::thx::bigint::Bigs_obj::trim(arr);
HXLINE( 237)		return arr;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,multiplyLong,return )

::Array< Int > Bigs_obj::multiplySmall(::Array< Int > a,Int b){
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		Int _hx_run(Float v){
            			HX_STACK_FRAME("thx.bigint.Bigs","multiplySmall",0x16c2929d,"thx.bigint.Bigs.multiplySmall","thx/bigint/Bigs.hx",257,0xb6bbbc16)
            			HX_STACK_ARG(v,"v")
HXLINE( 257)			return ::Std_obj::_hx_int(v);
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACK_FRAME("thx.bigint.Bigs","multiplySmall",0x16c2929d,"thx.bigint.Bigs.multiplySmall","thx/bigint/Bigs.hx",240,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 241)		HX_VARI( Int,l) = a->length;
HXDLIN( 241)		HX_VARI( ::Array< Float >,r) = ::Array_obj< Float >::__new(0);
HXDLIN( 241)		HX_VARI( Float,carry) = ((Float)0.0);
HXDLIN( 241)		HX_VAR( Float,product);
HXDLIN( 241)		HX_VARI( Int,i) = (int)0;
HXDLIN( 241)		HX_VARI( Float,bf) = b;
HXLINE( 247)		while((i < l)){
HXLINE( 249)			product = (carry + (a->__get(i) * bf));
HXLINE( 250)			HX_VARI( Float,value) = ((Float)product / (Float)(int)10000000);
HXDLIN( 250)			if ((value < ((Float)0.0))) {
HXLINE( 250)				carry = ::Math_obj::fceil(value);
            			}
            			else {
HXLINE( 250)				carry = ::Math_obj::ffloor(value);
            			}
HXLINE( 251)			Int _hx_tmp = i++;
HXDLIN( 251)			r[_hx_tmp] = (product - (carry * (int)10000000));
            		}
HXLINE( 253)		while((carry > (int)0)){
HXLINE( 254)			Int _hx_tmp1 = i++;
HXDLIN( 254)			r[_hx_tmp1] = hx::Mod(carry,(int)10000000);
HXLINE( 255)			HX_VARI_NAME( Float,value1,"value") = ((Float)carry / (Float)(int)10000000);
HXDLIN( 255)			if ((value1 < ((Float)0.0))) {
HXLINE( 255)				carry = ::Math_obj::fceil(value1);
            			}
            			else {
HXLINE( 255)				carry = ::Math_obj::ffloor(value1);
            			}
            		}
HXLINE( 257)		HX_VARI( ::Array< Int >,arr) = r->map( ::Dynamic(new _hx_Closure_0()));
HXLINE( 258)		::thx::bigint::Bigs_obj::trim(arr);
HXLINE( 259)		return arr;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,multiplySmall,return )

::Array< Int > Bigs_obj::shiftLeft(::Array< Int > x,Int n){
            	HX_STACK_FRAME("thx.bigint.Bigs","shiftLeft",0xd4710b43,"thx.bigint.Bigs.shiftLeft","thx/bigint/Bigs.hx",262,0xb6bbbc16)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(n,"n")
HXLINE( 263)		HX_VARI( ::Array< Int >,r) = ::Array_obj< Int >::__new(0);
HXLINE( 264)		while(true){
HXLINE( 264)			Int _hx_tmp = n--;
HXDLIN( 264)			if (!((_hx_tmp > (int)0))) {
HXLINE( 264)				goto _hx_goto_16;
            			}
HXDLIN( 264)			r->push((int)0);
            		}
            		_hx_goto_16:;
HXLINE( 265)		return r->concat(x);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,shiftLeft,return )

::Array< Int > Bigs_obj::multiplyKaratsuba(::Array< Int > x,::Array< Int > y){
            	HX_STACK_FRAME("thx.bigint.Bigs","multiplyKaratsuba",0x85053946,"thx.bigint.Bigs.multiplyKaratsuba","thx/bigint/Bigs.hx",268,0xb6bbbc16)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
HXLINE( 269)		HX_VARI( Int,a) = x->length;
HXDLIN( 269)		HX_VARI( Int,b) = y->length;
HXDLIN( 269)		HX_VAR( Int,n);
HXDLIN( 269)		if ((a > b)) {
HXLINE( 269)			n = a;
            		}
            		else {
HXLINE( 269)			n = b;
            		}
HXLINE( 271)		if ((n <= (int)400)) {
HXLINE( 272)			return ::thx::bigint::Bigs_obj::multiplyLong(x,y);
            		}
HXLINE( 273)		n = ::Math_obj::ceil(((Float)n / (Float)(int)2));
HXLINE( 275)		HX_VARI_NAME( ::Array< Int >,b1,"b") = x->slice(n,null());
HXDLIN( 275)		HX_VARI_NAME( ::Array< Int >,a1,"a") = x->slice((int)0,n);
HXDLIN( 275)		HX_VARI( ::Array< Int >,d) = y->slice(n,null());
HXDLIN( 275)		HX_VARI( ::Array< Int >,c) = y->slice((int)0,n);
HXLINE( 280)		HX_VARI( ::Array< Int >,ac) = ::thx::bigint::Bigs_obj::multiplyKaratsuba(a1,c);
HXDLIN( 280)		HX_VARI( ::Array< Int >,bd) = ::thx::bigint::Bigs_obj::multiplyKaratsuba(b1,d);
HXLINE( 282)		::Array< Int > _hx_tmp = ::thx::bigint::Bigs_obj::addAny(a1,b1);
HXDLIN( 282)		::Array< Int > _hx_tmp1 = ::thx::bigint::Bigs_obj::addAny(c,d);
HXLINE( 280)		HX_VARI( ::Array< Int >,abcd) = ::thx::bigint::Bigs_obj::multiplyKaratsuba(_hx_tmp,_hx_tmp1);
HXLINE( 284)		::Array< Int > _hx_tmp2 = ::thx::bigint::Bigs_obj::subtract(abcd,ac);
HXDLIN( 284)		::Array< Int > _hx_tmp3 = ::thx::bigint::Bigs_obj::subtract(_hx_tmp2,bd);
HXDLIN( 284)		::Array< Int > _hx_tmp4 = ::thx::bigint::Bigs_obj::shiftLeft(_hx_tmp3,n);
HXDLIN( 284)		::Array< Int > _hx_tmp5 = ::thx::bigint::Bigs_obj::addAny(ac,_hx_tmp4);
HXDLIN( 284)		::Array< Int > _hx_tmp6 = ::thx::bigint::Bigs_obj::shiftLeft(bd,((int)2 * n));
HXDLIN( 284)		return ::thx::bigint::Bigs_obj::addAny(_hx_tmp5,_hx_tmp6);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,multiplyKaratsuba,return )

::Dynamic Bigs_obj::fromInt(Int value){
            	HX_STACK_FRAME("thx.bigint.Bigs","fromInt",0xb35ee4bf,"thx.bigint.Bigs.fromInt","thx/bigint/Bigs.hx",287,0xb6bbbc16)
            	HX_STACK_ARG(value,"value")
HXLINE( 288)		HX_VAR( Int,abs);
HXDLIN( 288)		if ((value < (int)0)) {
HXLINE( 288)			abs = -(value);
            		}
            		else {
HXLINE( 288)			abs = value;
            		}
HXLINE( 289)		if ((abs < (int)10000000)) {
HXLINE( 290)			return  ::thx::bigint::Small_obj::__new(value);
            		}
            		else {
HXLINE( 292)			::Array< Int > _hx_tmp = ::thx::bigint::Bigs_obj::smallToArray(abs);
HXDLIN( 292)			return  ::thx::bigint::Big_obj::__new(_hx_tmp,(value < (int)0));
            		}
HXLINE( 289)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,fromInt,return )

::Dynamic Bigs_obj::fromInt64( ::cpp::Int64Struct value){
            	HX_STACK_FRAME("thx.bigint.Bigs","fromInt64",0x747101bd,"thx.bigint.Bigs.fromInt64","thx/bigint/Bigs.hx",297,0xb6bbbc16)
            	HX_STACK_ARG(value,"value")
HXLINE( 297)		::String _hx_tmp = _hx_int64_to_string(value);
HXDLIN( 297)		return ::thx::bigint::Bigs_obj::parseBase(_hx_tmp,(int)10);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,fromInt64,return )

 ::cpp::Int64Struct Bigs_obj::toInt64(::Dynamic value){
            	HX_STACK_FRAME("thx.bigint.Bigs","toInt64",0xe608e98c,"thx.bigint.Bigs.toInt64","thx/bigint/Bigs.hx",301,0xb6bbbc16)
            	HX_STACK_ARG(value,"value")
HXLINE( 301)		::String _hx_tmp = ::thx::bigint::BigIntImpl_obj::toString(value);
HXDLIN( 301)		return ::thx::Int64s_obj::parse(_hx_tmp);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,toInt64,return )

::Dynamic Bigs_obj::fromFloat(Float value){
            	HX_STACK_FRAME("thx.bigint.Bigs","fromFloat",0xb8e7316c,"thx.bigint.Bigs.fromFloat","thx/bigint/Bigs.hx",303,0xb6bbbc16)
            	HX_STACK_ARG(value,"value")
HXLINE( 304)		Bool _hx_tmp;
HXDLIN( 304)		Bool _hx_tmp1 = !(::Math_obj::isNaN(value));
HXDLIN( 304)		if (_hx_tmp1) {
HXLINE( 304)			_hx_tmp = !(::Math_obj::isFinite(value));
            		}
            		else {
HXLINE( 304)			_hx_tmp = true;
            		}
HXDLIN( 304)		if (_hx_tmp) {
HXLINE( 305)			HX_STACK_DO_THROW( ::thx::Error_obj::__new(HX_("Conversion to BigInt failed. Number is NaN or Infinite",48,bb,ef,08),null(),hx::SourceInfo(HX_("Bigs.hx",cb,0c,6e,4e),305,HX_("thx.bigint.Bigs",88,bd,8e,8b),HX_("fromFloat",d2,af,1f,b7))));
            		}
HXLINE( 307)		HX_VARI( Float,noFractions) = (value - hx::Mod(value,(int)1));
HXDLIN( 307)		HX_VARI( ::Dynamic,result) = ::thx::bigint::Small_obj::zero;
HXDLIN( 307)		HX_VARI( Bool,neg) = (noFractions < ((Float)0.0));
HXDLIN( 307)		HX_VAR( Float,rest);
HXLINE( 310)		if (neg) {
HXLINE( 307)			rest = -(noFractions);
            		}
            		else {
HXLINE( 307)			rest = noFractions;
            		}
HXDLIN( 307)		HX_VARI( Int,i) = (int)0;
HXDLIN( 307)		HX_VAR( Float,curr);
HXLINE( 312)		while((rest >= (int)1)){
HXLINE( 313)			curr = hx::Mod(rest,(int)2);
HXLINE( 314)			hx::DivEq(rest,(int)2);
HXLINE( 315)			if ((curr >= (int)1)) {
HXLINE( 316)				::Dynamic _hx_tmp2 = ::thx::bigint::Small_obj::one->shiftLeft(i);
HXDLIN( 316)				result = ::thx::bigint::BigIntImpl_obj::add(result,_hx_tmp2);
            			}
HXLINE( 317)			++i;
            		}
HXLINE( 320)		if (neg) {
HXLINE( 321)			return ::thx::bigint::BigIntImpl_obj::negate(result);
            		}
            		else {
HXLINE( 323)			return result;
            		}
HXLINE( 320)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,fromFloat,return )

::Array< Int > Bigs_obj::square(::Array< Int > a){
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		Int _hx_run(Float v){
            			HX_STACK_FRAME("thx.bigint.Bigs","square",0x950cdac3,"thx.bigint.Bigs.square","thx/bigint/Bigs.hx",342,0xb6bbbc16)
            			HX_STACK_ARG(v,"v")
HXLINE( 342)			return ::Std_obj::_hx_int(v);
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACK_FRAME("thx.bigint.Bigs","square",0x950cdac3,"thx.bigint.Bigs.square","thx/bigint/Bigs.hx",328,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
HXLINE( 329)		HX_VARI( Int,l) = a->length;
HXDLIN( 329)		HX_VARI( ::Array< Float >,r) = ::thx::bigint::Bigs_obj::createFloatArray((l + l));
HXDLIN( 329)		HX_VAR( Float,product);
HXDLIN( 329)		HX_VAR( Float,carry);
HXDLIN( 329)		HX_VAR( Float,a_i);
HXDLIN( 329)		HX_VAR( Float,a_j);
HXLINE( 332)		{
HXLINE( 332)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 332)			while((_g1 < l)){
HXLINE( 332)				HX_VARI( Int,i) = _g1++;
HXLINE( 333)				a_i = a->__get(i);
HXLINE( 334)				{
HXLINE( 334)					HX_VARI( Int,_g3) = (int)0;
HXDLIN( 334)					while((_g3 < l)){
HXLINE( 334)						HX_VARI( Int,j) = _g3++;
HXLINE( 335)						a_j = a->__get(j);
HXLINE( 336)						product = ((a_i * a_j) + r->__get((i + j)));
HXLINE( 337)						HX_VARI( Float,value) = ((Float)product / (Float)(int)10000000);
HXDLIN( 337)						if ((value < ((Float)0.0))) {
HXLINE( 337)							carry = ::Math_obj::fceil(value);
            						}
            						else {
HXLINE( 337)							carry = ::Math_obj::ffloor(value);
            						}
HXLINE( 338)						Int _hx_tmp = (i + j);
HXDLIN( 338)						HX_VARI_NAME( Float,value1,"value") = (product - (carry * (int)10000000));
HXDLIN( 338)						Float _hx_tmp1;
HXDLIN( 338)						if ((value1 < ((Float)0.0))) {
HXLINE( 338)							_hx_tmp1 = ::Math_obj::fceil(value1);
            						}
            						else {
HXLINE( 338)							_hx_tmp1 = ::Math_obj::ffloor(value1);
            						}
HXDLIN( 338)						r[_hx_tmp] = _hx_tmp1;
HXLINE( 339)						hx::AddEq(r[((i + j) + (int)1)],carry);
            					}
            				}
            			}
            		}
HXLINE( 342)		HX_VARI( ::Array< Int >,arr) = r->map( ::Dynamic(new _hx_Closure_0()));
HXLINE( 343)		::thx::bigint::Bigs_obj::trim(arr);
HXLINE( 344)		return arr;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Bigs_obj,square,return )

::Array< ::Dynamic> Bigs_obj::divMod1(::Array< Int > a,::Array< Int > b){
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		Float _hx_run(Int v){
            			HX_STACK_FRAME("thx.bigint.Bigs","divMod1",0xb9c1c03a,"thx.bigint.Bigs.divMod1","thx/bigint/Bigs.hx",354,0xb6bbbc16)
            			HX_STACK_ARG(v,"v")
HXLINE( 354)			return v;
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_1) HXARGC(1)
            		Int _hx_run(Float v1){
            			HX_STACK_FRAME("thx.bigint.Bigs","divMod1",0xb9c1c03a,"thx.bigint.Bigs.divMod1","thx/bigint/Bigs.hx",400,0xb6bbbc16)
            			HX_STACK_ARG(v1,"v1")
HXLINE( 400)			return ::Std_obj::_hx_int(v1);
            		}
            		HX_END_LOCAL_FUNC1(return)

            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_2) HXARGC(1)
            		Int _hx_run(Float v2){
            			HX_STACK_FRAME("thx.bigint.Bigs","divMod1",0xb9c1c03a,"thx.bigint.Bigs.divMod1","thx/bigint/Bigs.hx",402,0xb6bbbc16)
            			HX_STACK_ARG(v2,"v2")
HXLINE( 402)			return ::Std_obj::_hx_int(v2);
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACK_FRAME("thx.bigint.Bigs","divMod1",0xb9c1c03a,"thx.bigint.Bigs.divMod1","thx/bigint/Bigs.hx",347,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 348)		HX_VARI( Int,a_l) = a->length;
HXDLIN( 348)		HX_VARI( Int,b_l) = b->length;
HXDLIN( 348)		HX_VARI( ::Array< Float >,result) = ::thx::bigint::Bigs_obj::createFloatArray(b->length);
HXDLIN( 348)		HX_VARI( Float,divisorMostSignificantDigit) = b->__get((b_l - (int)1));
HXDLIN( 348)		HX_VARI( Int,lambda) = ::Math_obj::ceil(((Float)(int)10000000 / (Float)((int)2 * divisorMostSignificantDigit)));
HXDLIN( 348)		HX_VARI( ::Array< Float >,remainder) = ::thx::bigint::Bigs_obj::multiplySmall(a,lambda)->map( ::Dynamic(new _hx_Closure_0()));
HXDLIN( 348)		HX_VARI( ::Array< Int >,divisor) = ::thx::bigint::Bigs_obj::multiplySmall(b,lambda);
HXDLIN( 348)		HX_VAR( Float,quotientDigit);
HXDLIN( 348)		HX_VAR( Int,shift);
HXDLIN( 348)		HX_VAR( Float,carry);
HXDLIN( 348)		HX_VAR( Float,borrow);
HXDLIN( 348)		HX_VAR( Int,l);
HXDLIN( 348)		HX_VAR( Float,q);
HXLINE( 357)		Bool _hx_tmp = (remainder->length <= a_l);
HXDLIN( 357)		if (_hx_tmp) {
HXLINE( 358)			remainder->push(((Float)0.0));
            		}
HXLINE( 359)		divisor->push((int)0);
HXLINE( 360)		divisorMostSignificantDigit = divisor->__get((b_l - (int)1));
HXLINE( 361)		shift = (a_l - b_l);
HXLINE( 362)		while((shift >= (int)0)){
HXLINE( 363)			quotientDigit = ((Float)9999999.);
HXLINE( 364)			quotientDigit = ::Math_obj::ffloor(((Float)((remainder->__get((shift + b_l)) * (int)10000000) + remainder->__get(((shift + b_l) - (int)1))) / (Float)divisorMostSignificantDigit));
HXLINE( 365)			carry = ((Float)0.0);
HXLINE( 366)			borrow = ((Float)0.0);
HXLINE( 367)			l = divisor->length;
HXLINE( 368)			{
HXLINE( 368)				HX_VARI( Int,_g1) = (int)0;
HXDLIN( 368)				while((_g1 < l)){
HXLINE( 368)					HX_VARI( Int,i) = _g1++;
HXLINE( 369)					hx::AddEq(carry,(quotientDigit * divisor->__get(i)));
HXLINE( 370)					HX_VARI( Float,value) = ((Float)carry / (Float)(int)10000000);
HXDLIN( 370)					if ((value < ((Float)0.0))) {
HXLINE( 370)						q = ::Math_obj::fceil(value);
            					}
            					else {
HXLINE( 370)						q = ::Math_obj::ffloor(value);
            					}
HXLINE( 371)					hx::AddEq(borrow,(remainder->__get((shift + i)) - (carry - (q * (int)10000000))));
HXLINE( 372)					carry = q;
HXLINE( 373)					if ((borrow < ((Float)0.0))) {
HXLINE( 374)						remainder[(shift + i)] = (borrow + (int)10000000);
HXLINE( 375)						borrow = ((Float)-1.0);
            					}
            					else {
HXLINE( 377)						remainder[(shift + i)] = borrow;
HXLINE( 378)						borrow = ((Float)0.0);
            					}
            				}
            			}
HXLINE( 381)			while((borrow != (int)0)){
HXLINE( 382)				--quotientDigit;
HXLINE( 383)				carry = (int)0;
HXLINE( 384)				{
HXLINE( 384)					HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN( 384)					while((_g11 < l)){
HXLINE( 384)						HX_VARI_NAME( Int,i1,"i") = _g11++;
HXLINE( 385)						hx::AddEq(carry,((remainder->__get((shift + i1)) - (int)10000000) + divisor->__get(i1)));
HXLINE( 386)						if ((carry < (int)0)) {
HXLINE( 387)							remainder[(shift + i1)] = (carry + (int)10000000);
HXLINE( 388)							carry = (int)0;
            						}
            						else {
HXLINE( 390)							remainder[(shift + i1)] = carry;
HXLINE( 391)							carry = (int)1;
            						}
            					}
            				}
HXLINE( 394)				hx::AddEq(borrow,carry);
            			}
HXLINE( 396)			result[shift] = quotientDigit;
HXLINE( 397)			--shift;
            		}
HXLINE( 400)		HX_VARI( ::Array< Int >,arr) = remainder->map( ::Dynamic(new _hx_Closure_1()));
HXLINE( 401)		HX_VARI_NAME( ::Array< Int >,remainder1,"remainder") = ( (::Array< Int >)(::thx::bigint::Bigs_obj::divModSmall(arr,lambda)->__Field(HX_("q",71,00,00,00),hx::paccDynamic)) );
HXLINE( 402)		HX_VARI_NAME( ::Array< Int >,arr1,"arr") = result->map( ::Dynamic(new _hx_Closure_2()));
HXLINE( 403)		::thx::bigint::Bigs_obj::trim(arr1);
HXLINE( 406)		 ::Dynamic _hx_tmp1 = ::thx::bigint::Bigs_obj::arrayToSmall(arr1);
HXLINE( 405)		HX_VARI_NAME(  ::Dynamic,q1,"q") =  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("big",c0,b8,4a,00),arr1)
            			->setFixed(1,HX_("small",c7,f0,6a,7f),_hx_tmp1));
HXLINE( 410)		 ::Dynamic _hx_tmp2 = ::thx::bigint::Bigs_obj::arrayToSmall(remainder1);
HXLINE( 413)		return ::Array_obj< ::Dynamic>::__new(2)->init(0,q1)->init(1, ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("big",c0,b8,4a,00),remainder1)
            			->setFixed(1,HX_("small",c7,f0,6a,7f),_hx_tmp2)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,divMod1,return )

::Array< ::Dynamic> Bigs_obj::divMod2(::Array< Int > a,::Array< Int > b){
            	HX_STACK_FRAME("thx.bigint.Bigs","divMod2",0xb9c1c03b,"thx.bigint.Bigs.divMod2","thx/bigint/Bigs.hx",416,0xb6bbbc16)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 418)		HX_VARI( Int,a_l) = a->length;
HXDLIN( 418)		HX_VARI( Int,b_l) = b->length;
HXDLIN( 418)		HX_VARI( ::Array< Int >,result) = ::Array_obj< Int >::__new(0);
HXDLIN( 418)		HX_VARI( ::Array< Int >,part) = ::Array_obj< Int >::__new(0);
HXDLIN( 418)		HX_VAR( Int,guess);
HXDLIN( 418)		HX_VAR( Int,xlen);
HXDLIN( 418)		HX_VAR( Int,highx);
HXDLIN( 418)		HX_VAR( Int,highy);
HXDLIN( 418)		HX_VAR( ::Array< Int >,check);
HXLINE( 423)		while((a_l != (int)0)){
HXLINE( 424)			Int _hx_tmp = --a_l;
HXDLIN( 424)			part->unshift(a->__get(_hx_tmp));
HXLINE( 425)			if ((::thx::bigint::Bigs_obj::compareToAbs(part,b) < (int)0)) {
HXLINE( 426)				result->push((int)0);
HXLINE( 427)				continue;
            			}
HXLINE( 429)			xlen = part->length;
HXLINE( 430)			highx = ((part->__get((xlen - (int)1)) * (int)10000000) + part->__get((xlen - (int)2)));
HXLINE( 431)			highy = ((b->__get((b_l - (int)1)) * (int)10000000) + b->__get((b_l - (int)2)));
HXLINE( 432)			if ((xlen > b_l)) {
HXLINE( 433)				Int _hx_tmp1 = (highx + (int)1);
HXDLIN( 433)				highx = (_hx_tmp1 * (int)10000000);
            			}
HXLINE( 435)			guess = ::Math_obj::ceil(((Float)highx / (Float)highy));
HXLINE( 436)			while(true){
HXLINE( 437)				check = ::thx::bigint::Bigs_obj::multiplySmall(b,guess);
HXLINE( 438)				if ((::thx::bigint::Bigs_obj::compareToAbs(check,part) <= (int)0)) {
HXLINE( 438)					goto _hx_goto_25;
            				}
HXLINE( 439)				--guess;
HXLINE( 436)				if (!((guess != (int)0))) {
HXLINE( 436)					goto _hx_goto_25;
            				}
            			}
            			_hx_goto_25:;
HXLINE( 441)			result->push(guess);
HXLINE( 442)			part = ::thx::bigint::Bigs_obj::subtract(part,check);
            		}
HXLINE( 444)		result->reverse();
HXLINE( 446)		 ::Dynamic _hx_tmp2 = ::thx::bigint::Bigs_obj::arrayToSmall(result);
HXLINE( 445)		 ::Dynamic _hx_tmp3 =  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("big",c0,b8,4a,00),result)
            			->setFixed(1,HX_("small",c7,f0,6a,7f),_hx_tmp2));
HXLINE( 449)		 ::Dynamic _hx_tmp4 = ::thx::bigint::Bigs_obj::arrayToSmall(part);
HXLINE( 445)		return ::Array_obj< ::Dynamic>::__new(2)->init(0,_hx_tmp3)->init(1, ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("big",c0,b8,4a,00),part)
            			->setFixed(1,HX_("small",c7,f0,6a,7f),_hx_tmp4)));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,divMod2,return )

 ::Dynamic Bigs_obj::divModSmall(::Array< Int > value,Int lambda){
            	HX_STACK_FRAME("thx.bigint.Bigs","divModSmall",0x5ed55930,"thx.bigint.Bigs.divModSmall","thx/bigint/Bigs.hx",454,0xb6bbbc16)
            	HX_STACK_ARG(value,"value")
            	HX_STACK_ARG(lambda,"lambda")
HXLINE( 455)		HX_VARI( Int,length) = value->length;
HXDLIN( 455)		HX_VARI( ::Array< Int >,quotient) = ::thx::bigint::Bigs_obj::createArray(length);
HXDLIN( 455)		HX_VAR( Int,i);
HXDLIN( 455)		HX_VAR( Float,q);
HXDLIN( 455)		HX_VAR( Float,remainder);
HXDLIN( 455)		HX_VAR( Float,divisor);
HXLINE( 458)		remainder = (int)0;
HXLINE( 459)		i = (length - (int)1);
HXLINE( 460)		while((i >= (int)0)){
HXLINE( 461)			divisor = ((remainder * (int)10000000) + value->__get(i));
HXLINE( 462)			HX_VARI_NAME( Float,value1,"value") = ((Float)divisor / (Float)lambda);
HXDLIN( 462)			if ((value1 < ((Float)0.0))) {
HXLINE( 462)				q = ::Math_obj::fceil(value1);
            			}
            			else {
HXLINE( 462)				q = ::Math_obj::ffloor(value1);
            			}
HXLINE( 463)			remainder = (divisor - (q * lambda));
HXLINE( 464)			Int _hx_tmp = i--;
HXDLIN( 464)			Int _hx_tmp1 = ::Std_obj::_hx_int(q);
HXDLIN( 464)			quotient[_hx_tmp] = _hx_tmp1;
            		}
HXLINE( 466)		Int _hx_tmp2;
HXDLIN( 466)		if ((remainder < ((Float)0.0))) {
HXLINE( 466)			_hx_tmp2 = ::Math_obj::ceil(remainder);
            		}
            		else {
HXLINE( 466)			_hx_tmp2 = ::Math_obj::floor(remainder);
            		}
HXDLIN( 466)		return  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("q",71,00,00,00),quotient)
            			->setFixed(1,HX_("r",72,00,00,00),_hx_tmp2));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,divModSmall,return )

::Dynamic Bigs_obj::parseBase(::String text,Int base){
            	HX_STACK_FRAME("thx.bigint.Bigs","parseBase",0xca7ebb7e,"thx.bigint.Bigs.parseBase","thx/bigint/Bigs.hx",469,0xb6bbbc16)
            	HX_STACK_ARG(text,"text")
            	HX_STACK_ARG(base,"base")
HXLINE( 470)		HX_VARI( ::Dynamic,val) = ::thx::bigint::Small_obj::zero;
HXDLIN( 470)		HX_VARI( ::Dynamic,pow) = ::thx::bigint::Small_obj::one;
HXDLIN( 470)		HX_VARI(  ::thx::bigint::Small,bigBase) =  ::thx::bigint::Small_obj::__new(base);
HXLINE( 473)		::String _hx_tmp = text.substring((int)0,(int)1);
HXLINE( 470)		HX_VARI( Bool,isNegative) = (_hx_tmp == HX_("-",2d,00,00,00));
HXLINE( 474)		Bool _hx_tmp1;
HXDLIN( 474)		if (((int)2 <= base)) {
HXLINE( 474)			_hx_tmp1 = (base > (int)36);
            		}
            		else {
HXLINE( 474)			_hx_tmp1 = true;
            		}
HXDLIN( 474)		if (_hx_tmp1) {
HXLINE( 475)			HX_STACK_DO_THROW( ::thx::Error_obj::__new(((HX_("base (",59,ea,27,55) + base) + HX_(") must be a number between 2 ad 36",bf,cc,91,8a)),null(),hx::SourceInfo(HX_("Bigs.hx",cb,0c,6e,4e),475,HX_("thx.bigint.Bigs",88,bd,8e,8b),HX_("parseBase",e4,39,b7,c8))));
            		}
HXLINE( 476)		if (isNegative) {
HXLINE( 477)			text = text.substring((int)1,null());
            		}
HXLINE( 479)		text = ::thx::Strings_obj::trimCharsLeft(text,HX_("0",30,00,00,00)).toLowerCase();
HXLINE( 480)		Bool _hx_tmp2 = (text.length == (int)0);
HXDLIN( 480)		if (_hx_tmp2) {
HXLINE( 481)			text = HX_("0",30,00,00,00);
            		}
HXLINE( 483)		HX_VAR( Int,e);
HXLINE( 484)		Bool _hx_tmp3;
HXDLIN( 484)		if ((base == (int)10)) {
HXLINE( 484)			e = text.indexOf(HX_("e",65,00,00,00),null());
HXDLIN( 484)			_hx_tmp3 = (e > (int)0);
            		}
            		else {
HXLINE( 484)			_hx_tmp3 = false;
            		}
HXDLIN( 484)		if (_hx_tmp3) {
HXLINE( 485)			HX_VARI( ::String,sexp) = text.substring((e + (int)1),null());
HXLINE( 486)			text = text.substring((int)0,e);
HXLINE( 487)			HX_VAR(  ::Dynamic,exp);
HXDLIN( 487)			Bool _hx_tmp4 = ::StringTools_obj::startsWith(sexp,HX_("+",2b,00,00,00));
HXDLIN( 487)			if (_hx_tmp4) {
HXLINE( 487)				::String _hx_tmp5 = sexp.substring((int)1,null());
HXDLIN( 487)				exp = ::Std_obj::parseInt(_hx_tmp5);
            			}
            			else {
HXLINE( 487)				exp = ::Std_obj::parseInt(sexp);
            			}
HXLINE( 488)			HX_VARI( Int,decimalPlace) = text.indexOf(HX_(".",2e,00,00,00),null());
HXLINE( 489)			if ((decimalPlace >= (int)0)) {
HXLINE( 490)				hx::SubEq(exp,(text.length - decimalPlace));
HXLINE( 491)				::String _hx_tmp6 = text.substring((int)0,decimalPlace);
HXDLIN( 491)				::String _hx_tmp7 = text.substring(((int)1 + decimalPlace),null());
HXDLIN( 491)				text = (_hx_tmp6 + _hx_tmp7);
            			}
HXLINE( 495)			Int _hx_tmp8 = (text.length + exp);
HXDLIN( 495)			text = ::thx::Strings_obj::rpad(text,HX_("0",30,00,00,00),_hx_tmp8);
            		}
HXLINE( 497)		HX_VARI( Int,length) = text.length;
HXLINE( 499)		Float _hx_tmp9 = ::thx::bigint::Bigs_obj::LOG_MAX_INT;
HXDLIN( 499)		Float _hx_tmp10 = ::Math_obj::log(base);
HXDLIN( 499)		if ((length <= ((Float)_hx_tmp9 / (Float)_hx_tmp10))) {
HXLINE( 500)			 ::Dynamic _hx_tmp11 = ::thx::Ints_obj::parse(text,base);
HXDLIN( 500)			Int _hx_tmp12;
HXDLIN( 500)			if (isNegative) {
HXLINE( 500)				_hx_tmp12 = (int)-1;
            			}
            			else {
HXLINE( 500)				_hx_tmp12 = (int)1;
            			}
HXDLIN( 500)			return  ::thx::bigint::Small_obj::__new((_hx_tmp11 * _hx_tmp12));
            		}
HXLINE( 502)		HX_VARI( ::Array< ::Dynamic>,digits) = ::Array_obj< ::Dynamic>::__new(0);
HXLINE( 503)		{
HXLINE( 503)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 503)			while((_g1 < length)){
HXLINE( 503)				HX_VARI( Int,i) = _g1++;
HXLINE( 504)				HX_VARI(  ::Dynamic,charCode) = text.charCodeAt(i);
HXLINE( 505)				Bool _hx_tmp13;
HXDLIN( 505)				if (hx::IsLessEq( (int)48,charCode )) {
HXLINE( 505)					_hx_tmp13 = hx::IsLessEq( charCode,(int)57 );
            				}
            				else {
HXLINE( 505)					_hx_tmp13 = false;
            				}
HXDLIN( 505)				if (_hx_tmp13) {
HXLINE( 506)					digits->push( ::thx::bigint::Small_obj::__new((charCode - (int)48)));
            				}
            				else {
HXLINE( 507)					Bool _hx_tmp14;
HXDLIN( 507)					if (hx::IsLessEq( (int)97,charCode )) {
HXLINE( 507)						_hx_tmp14 = hx::IsLessEq( charCode,(int)122 );
            					}
            					else {
HXLINE( 507)						_hx_tmp14 = false;
            					}
HXDLIN( 507)					if (_hx_tmp14) {
HXLINE( 508)						digits->push( ::thx::bigint::Small_obj::__new((charCode - (int)87)));
            					}
            					else {
HXLINE( 509)						HX_STACK_DO_THROW( ::thx::Error_obj::__new(((HX_("",00,00,00,00) + text) + HX_(" is not a valid string",57,c9,1f,f8)),null(),hx::SourceInfo(HX_("Bigs.hx",cb,0c,6e,4e),509,HX_("thx.bigint.Bigs",88,bd,8e,8b),HX_("parseBase",e4,39,b7,c8))));
            					}
            				}
            			}
            		}
HXLINE( 511)		digits->reverse();
HXLINE( 512)		HX_VAR( ::Dynamic,mul);
HXLINE( 513)		{
HXLINE( 513)			HX_VARI_NAME( Int,_g11,"_g1") = (int)0;
HXDLIN( 513)			HX_VARI( Int,_g) = digits->length;
HXDLIN( 513)			while((_g11 < _g)){
HXLINE( 513)				HX_VARI_NAME( Int,i1,"i") = _g11++;
HXLINE( 514)				mul = digits->__get(i1).StaticCast<  ::thx::bigint::Small >()->multiply(pow);
HXLINE( 515)				val = ::thx::bigint::BigIntImpl_obj::add(val,mul);
HXLINE( 516)				pow = ::thx::bigint::BigIntImpl_obj::multiply(pow,bigBase);
            			}
            		}
HXLINE( 518)		if (isNegative) {
HXLINE( 518)			return ::thx::bigint::BigIntImpl_obj::negate(val);
            		}
            		else {
HXLINE( 518)			return val;
            		}
HXDLIN( 518)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Bigs_obj,parseBase,return )

::Dynamic Bigs_obj::bitwise(::Dynamic x,::Dynamic y, ::Dynamic fn){
            	HX_STACK_FRAME("thx.bigint.Bigs","bitwise",0x5b881f8b,"thx.bigint.Bigs.bitwise","thx/bigint/Bigs.hx",521,0xb6bbbc16)
            	HX_STACK_ARG(x,"x")
            	HX_STACK_ARG(y,"y")
            	HX_STACK_ARG(fn,"fn")
HXLINE( 522)		HX_VARI( Bool,xSign) = ( (Bool)(x->__Field(HX_("sign",3d,90,53,4c),hx::paccDynamic)) );
HXDLIN( 522)		HX_VARI( Bool,ySign) = ( (Bool)(y->__Field(HX_("sign",3d,90,53,4c),hx::paccDynamic)) );
HXLINE( 524)		HX_VAR( ::Dynamic,xRem);
HXDLIN( 524)		if (xSign) {
HXLINE( 524)			xRem = ::thx::bigint::BigIntImpl_obj::_hx_not(x);
            		}
            		else {
HXLINE( 524)			xRem = x;
            		}
HXDLIN( 524)		HX_VAR( ::Dynamic,yRem);
HXLINE( 525)		if (ySign) {
HXLINE( 524)			yRem = ::thx::bigint::BigIntImpl_obj::_hx_not(y);
            		}
            		else {
HXLINE( 524)			yRem = y;
            		}
HXLINE( 526)		HX_VARI( ::Array< Int >,xBits) = ::Array_obj< Int >::__new(0);
HXDLIN( 526)		HX_VARI( ::Array< Int >,yBits) = ::Array_obj< Int >::__new(0);
HXLINE( 528)		HX_VARI( Bool,xStop) = false;
HXDLIN( 528)		HX_VARI( Bool,yStop) = false;
HXLINE( 530)		while(true){
HXLINE( 530)			Bool _hx_tmp;
HXDLIN( 530)			if (!(!(xStop))) {
HXLINE( 530)				_hx_tmp = !(yStop);
            			}
            			else {
HXLINE( 530)				_hx_tmp = true;
            			}
HXDLIN( 530)			if (!(_hx_tmp)) {
HXLINE( 530)				goto _hx_goto_29;
            			}
HXLINE( 531)			Bool _hx_tmp1 = ::thx::bigint::BigIntImpl_obj::isZero(xRem);
HXDLIN( 531)			if (_hx_tmp1) {
HXLINE( 532)				xStop = true;
HXLINE( 533)				Int _hx_tmp2;
HXDLIN( 533)				if (xSign) {
HXLINE( 533)					_hx_tmp2 = (int)1;
            				}
            				else {
HXLINE( 533)					_hx_tmp2 = (int)0;
            				}
HXDLIN( 533)				xBits->push(_hx_tmp2);
            			}
            			else {
HXLINE( 534)				if (xSign) {
HXLINE( 535)					Int _hx_tmp3;
HXDLIN( 535)					Bool _hx_tmp4 = ::thx::bigint::BigIntImpl_obj::isEven(xRem);
HXDLIN( 535)					if (_hx_tmp4) {
HXLINE( 535)						_hx_tmp3 = (int)1;
            					}
            					else {
HXLINE( 535)						_hx_tmp3 = (int)0;
            					}
HXDLIN( 535)					xBits->push(_hx_tmp3);
            				}
            				else {
HXLINE( 537)					Int _hx_tmp5;
HXDLIN( 537)					Bool _hx_tmp6 = ::thx::bigint::BigIntImpl_obj::isEven(xRem);
HXDLIN( 537)					if (_hx_tmp6) {
HXLINE( 537)						_hx_tmp5 = (int)0;
            					}
            					else {
HXLINE( 537)						_hx_tmp5 = (int)1;
            					}
HXDLIN( 537)					xBits->push(_hx_tmp5);
            				}
            			}
HXLINE( 539)			Bool _hx_tmp7 = ::thx::bigint::BigIntImpl_obj::isZero(yRem);
HXDLIN( 539)			if (_hx_tmp7) {
HXLINE( 540)				yStop = true;
HXLINE( 541)				Int _hx_tmp8;
HXDLIN( 541)				if (ySign) {
HXLINE( 541)					_hx_tmp8 = (int)1;
            				}
            				else {
HXLINE( 541)					_hx_tmp8 = (int)0;
            				}
HXDLIN( 541)				yBits->push(_hx_tmp8);
            			}
            			else {
HXLINE( 542)				if (ySign) {
HXLINE( 543)					Int _hx_tmp9;
HXDLIN( 543)					Bool _hx_tmp10 = ::thx::bigint::BigIntImpl_obj::isEven(yRem);
HXDLIN( 543)					if (_hx_tmp10) {
HXLINE( 543)						_hx_tmp9 = (int)1;
            					}
            					else {
HXLINE( 543)						_hx_tmp9 = (int)0;
            					}
HXDLIN( 543)					yBits->push(_hx_tmp9);
            				}
            				else {
HXLINE( 545)					Int _hx_tmp11;
HXDLIN( 545)					Bool _hx_tmp12 = ::thx::bigint::BigIntImpl_obj::isEven(yRem);
HXDLIN( 545)					if (_hx_tmp12) {
HXLINE( 545)						_hx_tmp11 = (int)0;
            					}
            					else {
HXLINE( 545)						_hx_tmp11 = (int)1;
            					}
HXDLIN( 545)					yBits->push(_hx_tmp11);
            				}
            			}
HXLINE( 547)			xRem = ::thx::bigint::BigIntImpl_obj::divide(xRem,::thx::bigint::Small_obj::two);
HXLINE( 548)			yRem = ::thx::bigint::BigIntImpl_obj::divide(yRem,::thx::bigint::Small_obj::two);
            		}
            		_hx_goto_29:;
HXLINE( 550)		HX_VARI( ::Array< Int >,result) = ::Array_obj< Int >::__new(0);
HXLINE( 551)		{
HXLINE( 551)			HX_VARI( Int,_g1) = (int)0;
HXDLIN( 551)			HX_VARI( Int,_g) = xBits->length;
HXDLIN( 551)			while((_g1 < _g)){
HXLINE( 551)				HX_VARI( Int,i) = _g1++;
HXLINE( 552)				Int _hx_tmp13 = ( (Int)(fn(xBits->__get(i),yBits->__get(i))) );
HXDLIN( 552)				result->push(_hx_tmp13);
            			}
            		}
HXLINE( 554)		 ::Dynamic _hx_tmp14 = result->pop();
HXDLIN( 554)		HX_VARI( ::Dynamic,a) = ::thx::bigint::Bigs_obj::fromInt(_hx_tmp14);
HXLINE( 555)		::Dynamic _hx_tmp15 = ::thx::bigint::Bigs_obj::fromInt(result->length);
HXLINE( 554)		HX_VARI( ::Dynamic,p) = ::thx::bigint::Small_obj::two->pow(_hx_tmp15);
HXDLIN( 554)		HX_VARI( ::Dynamic,sum) = ::thx::bigint::BigIntImpl_obj::multiply(::thx::bigint::BigIntImpl_obj::negate(a),p);
HXLINE( 557)		while((result->length > (int)0)){
HXLINE( 558)			 ::Dynamic _hx_tmp16 = result->pop();
HXDLIN( 558)			a = ::thx::bigint::Bigs_obj::fromInt(_hx_tmp16);
HXLINE( 559)			::Dynamic _hx_tmp17 = ::thx::bigint::Bigs_obj::fromInt(result->length);
HXDLIN( 559)			p = ::thx::bigint::Small_obj::two->pow(_hx_tmp17);
HXLINE( 560)			::Dynamic _hx_tmp18 = ::thx::bigint::BigIntImpl_obj::multiply(a,p);
HXDLIN( 560)			sum = ::thx::bigint::BigIntImpl_obj::add(sum,_hx_tmp18);
            		}
HXLINE( 562)		return sum;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Bigs_obj,bitwise,return )


Bigs_obj::Bigs_obj()
{
}

bool Bigs_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"add") ) { outValue = add_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"trim") ) { outValue = trim_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"canAdd") ) { outValue = canAdd_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addAny") ) { outValue = addAny_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"square") ) { outValue = square_dyn(); return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"MAX_INT") ) { outValue = MAX_INT; return true; }
		if (HX_FIELD_EQ(inName,"fromInt") ) { outValue = fromInt_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toInt64") ) { outValue = toInt64_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"divMod1") ) { outValue = divMod1_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"divMod2") ) { outValue = divMod2_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"bitwise") ) { outValue = bitwise_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"canPower") ) { outValue = canPower_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"addSmall") ) { outValue = addSmall_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"subtract") ) { outValue = subtract_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"isPrecise") ) { outValue = isPrecise_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"shiftLeft") ) { outValue = shiftLeft_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fromInt64") ) { outValue = fromInt64_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"fromFloat") ) { outValue = fromFloat_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"parseBase") ) { outValue = parseBase_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"MAX_INT_ARR") ) { outValue = MAX_INT_ARR; return true; }
		if (HX_FIELD_EQ(inName,"LOG_MAX_INT") ) { outValue = LOG_MAX_INT; return true; }
		if (HX_FIELD_EQ(inName,"powersOfTwo") ) { outValue = powersOfTwo; return true; }
		if (HX_FIELD_EQ(inName,"canMultiply") ) { outValue = canMultiply_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"createArray") ) { outValue = createArray_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"subtractAny") ) { outValue = subtractAny_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"divModSmall") ) { outValue = divModSmall_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"smallToArray") ) { outValue = smallToArray_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"arrayToSmall") ) { outValue = arrayToSmall_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"compareToAbs") ) { outValue = compareToAbs_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"multiplyLong") ) { outValue = multiplyLong_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"powers2Length") ) { outValue = powers2Length; return true; }
		if (HX_FIELD_EQ(inName,"highestPower2") ) { outValue = highestPower2; return true; }
		if (HX_FIELD_EQ(inName,"subtractSmall") ) { outValue = subtractSmall_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"multiplySmall") ) { outValue = multiplySmall_dyn(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"bigPowersOfTwo") ) { outValue = bigPowersOfTwo; return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"bigHighestPower2") ) { outValue = bigHighestPower2; return true; }
		if (HX_FIELD_EQ(inName,"createFloatArray") ) { outValue = createFloatArray_dyn(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"multiplyKaratsuba") ) { outValue = multiplyKaratsuba_dyn(); return true; }
	}
	return false;
}

bool Bigs_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 7:
		if (HX_FIELD_EQ(inName,"MAX_INT") ) { MAX_INT=ioValue.Cast< Int >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"MAX_INT_ARR") ) { MAX_INT_ARR=ioValue.Cast< ::Array< Int > >(); return true; }
		if (HX_FIELD_EQ(inName,"LOG_MAX_INT") ) { LOG_MAX_INT=ioValue.Cast< Float >(); return true; }
		if (HX_FIELD_EQ(inName,"powersOfTwo") ) { powersOfTwo=ioValue.Cast< ::Array< Int > >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"powers2Length") ) { powers2Length=ioValue.Cast< Int >(); return true; }
		if (HX_FIELD_EQ(inName,"highestPower2") ) { highestPower2=ioValue.Cast< Int >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"bigPowersOfTwo") ) { bigPowersOfTwo=ioValue.Cast< ::Array< ::Dynamic> >(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"bigHighestPower2") ) { bigHighestPower2=ioValue.Cast< ::Dynamic >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Bigs_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Bigs_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &Bigs_obj::BASE,HX_HCSTRING("BASE","\x11","\xb0","\xd1","\x2b")},
	{hx::fsFloat,(void *) &Bigs_obj::DOUBLE_BASE,HX_HCSTRING("DOUBLE_BASE","\x3f","\xb7","\x1a","\x29")},
	{hx::fsInt,(void *) &Bigs_obj::LOG_BASE,HX_HCSTRING("LOG_BASE","\x0c","\xf1","\x52","\x12")},
	{hx::fsInt,(void *) &Bigs_obj::MAX_INT,HX_HCSTRING("MAX_INT","\x54","\x26","\x6d","\x69")},
	{hx::fsObject /*Array< int >*/ ,(void *) &Bigs_obj::MAX_INT_ARR,HX_HCSTRING("MAX_INT_ARR","\x96","\xbf","\x9d","\xfa")},
	{hx::fsFloat,(void *) &Bigs_obj::LOG_MAX_INT,HX_HCSTRING("LOG_MAX_INT","\x39","\x74","\x1c","\xbd")},
	{hx::fsObject /*Array< int >*/ ,(void *) &Bigs_obj::powersOfTwo,HX_HCSTRING("powersOfTwo","\x07","\xd9","\xa4","\xa0")},
	{hx::fsObject /*Array< ::thx::bigint::BigIntImpl >*/ ,(void *) &Bigs_obj::bigPowersOfTwo,HX_HCSTRING("bigPowersOfTwo","\x27","\xf0","\x29","\x1b")},
	{hx::fsInt,(void *) &Bigs_obj::powers2Length,HX_HCSTRING("powers2Length","\xaa","\xd7","\xf3","\x5e")},
	{hx::fsInt,(void *) &Bigs_obj::highestPower2,HX_HCSTRING("highestPower2","\xd1","\xf9","\x12","\x3d")},
	{hx::fsObject /*::thx::bigint::BigIntImpl*/ ,(void *) &Bigs_obj::bigHighestPower2,HX_HCSTRING("bigHighestPower2","\xf1","\x18","\x64","\x34")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Bigs_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Bigs_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Bigs_obj::BASE,"BASE");
	HX_MARK_MEMBER_NAME(Bigs_obj::DOUBLE_BASE,"DOUBLE_BASE");
	HX_MARK_MEMBER_NAME(Bigs_obj::LOG_BASE,"LOG_BASE");
	HX_MARK_MEMBER_NAME(Bigs_obj::MAX_INT,"MAX_INT");
	HX_MARK_MEMBER_NAME(Bigs_obj::MAX_INT_ARR,"MAX_INT_ARR");
	HX_MARK_MEMBER_NAME(Bigs_obj::LOG_MAX_INT,"LOG_MAX_INT");
	HX_MARK_MEMBER_NAME(Bigs_obj::powersOfTwo,"powersOfTwo");
	HX_MARK_MEMBER_NAME(Bigs_obj::bigPowersOfTwo,"bigPowersOfTwo");
	HX_MARK_MEMBER_NAME(Bigs_obj::powers2Length,"powers2Length");
	HX_MARK_MEMBER_NAME(Bigs_obj::highestPower2,"highestPower2");
	HX_MARK_MEMBER_NAME(Bigs_obj::bigHighestPower2,"bigHighestPower2");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Bigs_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Bigs_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Bigs_obj::BASE,"BASE");
	HX_VISIT_MEMBER_NAME(Bigs_obj::DOUBLE_BASE,"DOUBLE_BASE");
	HX_VISIT_MEMBER_NAME(Bigs_obj::LOG_BASE,"LOG_BASE");
	HX_VISIT_MEMBER_NAME(Bigs_obj::MAX_INT,"MAX_INT");
	HX_VISIT_MEMBER_NAME(Bigs_obj::MAX_INT_ARR,"MAX_INT_ARR");
	HX_VISIT_MEMBER_NAME(Bigs_obj::LOG_MAX_INT,"LOG_MAX_INT");
	HX_VISIT_MEMBER_NAME(Bigs_obj::powersOfTwo,"powersOfTwo");
	HX_VISIT_MEMBER_NAME(Bigs_obj::bigPowersOfTwo,"bigPowersOfTwo");
	HX_VISIT_MEMBER_NAME(Bigs_obj::powers2Length,"powers2Length");
	HX_VISIT_MEMBER_NAME(Bigs_obj::highestPower2,"highestPower2");
	HX_VISIT_MEMBER_NAME(Bigs_obj::bigHighestPower2,"bigHighestPower2");
};

#endif

hx::Class Bigs_obj::__mClass;

static ::String Bigs_obj_sStaticFields[] = {
	HX_HCSTRING("BASE","\x11","\xb0","\xd1","\x2b"),
	HX_HCSTRING("DOUBLE_BASE","\x3f","\xb7","\x1a","\x29"),
	HX_HCSTRING("LOG_BASE","\x0c","\xf1","\x52","\x12"),
	HX_HCSTRING("MAX_INT","\x54","\x26","\x6d","\x69"),
	HX_HCSTRING("MAX_INT_ARR","\x96","\xbf","\x9d","\xfa"),
	HX_HCSTRING("LOG_MAX_INT","\x39","\x74","\x1c","\xbd"),
	HX_HCSTRING("powersOfTwo","\x07","\xd9","\xa4","\xa0"),
	HX_HCSTRING("bigPowersOfTwo","\x27","\xf0","\x29","\x1b"),
	HX_HCSTRING("powers2Length","\xaa","\xd7","\xf3","\x5e"),
	HX_HCSTRING("highestPower2","\xd1","\xf9","\x12","\x3d"),
	HX_HCSTRING("bigHighestPower2","\xf1","\x18","\x64","\x34"),
	HX_HCSTRING("isPrecise","\x91","\x5b","\x4a","\x33"),
	HX_HCSTRING("canMultiply","\x54","\xa2","\x34","\xca"),
	HX_HCSTRING("canPower","\xd5","\x8d","\x2d","\x35"),
	HX_HCSTRING("canAdd","\xf1","\x1f","\x1a","\xb8"),
	HX_HCSTRING("smallToArray","\x17","\xa8","\x6e","\x22"),
	HX_HCSTRING("arrayToSmall","\xb3","\xcc","\x4e","\xfd"),
	HX_HCSTRING("trim","\xe2","\x9c","\x03","\x4d"),
	HX_HCSTRING("createArray","\xfd","\xa4","\x0a","\x4f"),
	HX_HCSTRING("createFloatArray","\x79","\xc0","\x55","\x79"),
	HX_HCSTRING("add","\x21","\xf2","\x49","\x00"),
	HX_HCSTRING("addAny","\x4b","\x0b","\xfb","\x9e"),
	HX_HCSTRING("addSmall","\xe6","\x16","\xc8","\xf8"),
	HX_HCSTRING("compareToAbs","\xd2","\x82","\xbb","\xb0"),
	HX_HCSTRING("subtract","\x14","\x75","\x11","\xf8"),
	HX_HCSTRING("subtractAny","\x38","\xa2","\xef","\x0b"),
	HX_HCSTRING("subtractSmall","\x13","\x03","\x42","\xfd"),
	HX_HCSTRING("multiplyLong","\xc0","\x95","\xa3","\x4c"),
	HX_HCSTRING("multiplySmall","\x03","\x3c","\xf1","\xc8"),
	HX_HCSTRING("shiftLeft","\xa9","\x89","\xa9","\xd2"),
	HX_HCSTRING("multiplyKaratsuba","\xac","\x8d","\x1b","\x59"),
	HX_HCSTRING("fromInt","\xa5","\xdd","\xfa","\x57"),
	HX_HCSTRING("fromInt64","\x23","\x80","\xa9","\x72"),
	HX_HCSTRING("toInt64","\x72","\xe2","\xa4","\x8a"),
	HX_HCSTRING("fromFloat","\xd2","\xaf","\x1f","\xb7"),
	HX_HCSTRING("square","\x9d","\x00","\xf2","\x58"),
	HX_HCSTRING("divMod1","\x20","\xb9","\x5d","\x5e"),
	HX_HCSTRING("divMod2","\x21","\xb9","\x5d","\x5e"),
	HX_HCSTRING("divModSmall","\x16","\xbd","\xf6","\xba"),
	HX_HCSTRING("parseBase","\xe4","\x39","\xb7","\xc8"),
	HX_HCSTRING("bitwise","\x71","\x18","\x24","\x00"),
	::String(null())
};

void Bigs_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("thx.bigint.Bigs","\x88","\xbd","\x8e","\x8b");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Bigs_obj::__GetStatic;
	__mClass->mSetStaticField = &Bigs_obj::__SetStatic;
	__mClass->mMarkFunc = Bigs_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Bigs_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Bigs_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Bigs_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Bigs_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Bigs_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Bigs_obj::__boot()
{
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",6,0xb6bbbc16)
HXLINE(   6)		BASE = (int)10000000;
            	}
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",7,0xb6bbbc16)
HXLINE(   7)		DOUBLE_BASE = ((Float)100000000000000.0);
            	}
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",8,0xb6bbbc16)
HXLINE(   8)		LOG_BASE = (int)7;
            	}
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",9,0xb6bbbc16)
HXLINE(   9)		MAX_INT = (int)2147483647;
            	}
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",10,0xb6bbbc16)
HXLINE(  10)		MAX_INT_ARR = ::thx::bigint::Bigs_obj::smallToArray(::thx::bigint::Bigs_obj::MAX_INT);
            	}
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",11,0xb6bbbc16)
HXLINE(  11)		LOG_MAX_INT = ::Math_obj::log(::thx::bigint::Bigs_obj::MAX_INT);
            	}
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",13,0xb6bbbc16)
HXLINE(  14)		HX_VARI( ::Array< Int >,powers) = ::Array_obj< Int >::__new(1)->init(0,(int)1);
HXLINE(  15)		while((powers->__get((powers->length - (int)1)) <= (int)10000000)){
HXLINE(  16)			Int _hx_tmp = powers->__get((powers->length - (int)1));
HXDLIN(  16)			powers->push(((int)2 * _hx_tmp));
            		}
HXLINE(  17)		powersOfTwo = powers;
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(1)
            		::Dynamic _hx_run(Int v){
            			HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",19,0xb6bbbc16)
            			HX_STACK_ARG(v,"v")
HXLINE(  19)			return  ::thx::bigint::Small_obj::__new(v);
            		}
            		HX_END_LOCAL_FUNC1(return)

            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",19,0xb6bbbc16)
HXLINE(  19)		bigPowersOfTwo = ::thx::bigint::Bigs_obj::powersOfTwo->map( ::Dynamic(new _hx_Closure_0()));
            	}
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",20,0xb6bbbc16)
HXLINE(  20)		powers2Length = ::thx::bigint::Bigs_obj::powersOfTwo->length;
            	}
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",21,0xb6bbbc16)
HXLINE(  21)		highestPower2 = ::thx::bigint::Bigs_obj::powersOfTwo->__get((::thx::bigint::Bigs_obj::powers2Length - (int)1));
            	}
{
            	HX_STACK_FRAME("thx.bigint.Bigs","boot",0x62f768d8,"thx.bigint.Bigs.boot","thx/bigint/Bigs.hx",22,0xb6bbbc16)
HXLINE(  22)		bigHighestPower2 =  ::thx::bigint::Small_obj::__new(::thx::bigint::Bigs_obj::highestPower2);
            	}
}

} // end namespace thx
} // end namespace bigint
