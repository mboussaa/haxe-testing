// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_Timer
#include <haxe/Timer.h>
#endif
#ifndef INCLUDED_haxe_ds_IntMap
#include <haxe/ds/IntMap.h>
#endif
#ifndef INCLUDED_thx_Functions
#include <thx/Functions.h>
#endif
#ifndef INCLUDED_thx_Timer
#include <thx/Timer.h>
#endif

namespace thx{

void Timer_obj::__construct() { }

Dynamic Timer_obj::__CreateEmpty() { return new Timer_obj; }

hx::ObjectPtr< Timer_obj > Timer_obj::__new()
{
	hx::ObjectPtr< Timer_obj > _hx_result = new Timer_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Timer_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Timer_obj > _hx_result = new Timer_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::Dynamic Timer_obj::debounce( ::Dynamic callback,Int delayms,hx::Null< Bool >  __o_leading){
            		HX_BEGIN_LOCAL_FUNC_S3(hx::LocalFunc,_hx_Closure_0,Int,delayms,::Array< ::Dynamic>,cancel, ::Dynamic,callback) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("thx.Timer","debounce",0xad888e5c,"thx.Timer.debounce","thx/Timer.hx",29,0xdd0b5e64)
HXLINE(  30)			cancel->__get((int)0)();
HXLINE(  31)			 ::Dynamic _hx_tmp = ::thx::Timer_obj::delay(callback,delayms);
HXDLIN(  31)			cancel[(int)0] = _hx_tmp;
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S3(hx::LocalFunc,_hx_Closure_1, ::Dynamic,poll, ::Dynamic,callback,::Array< Bool >,leading1) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("thx.Timer","debounce",0xad888e5c,"thx.Timer.debounce","thx/Timer.hx",33,0xdd0b5e64)
HXLINE(  34)			if (leading1->__get((int)0)) {
HXLINE(  35)				leading1[(int)0] = false;
HXLINE(  36)				callback();
            			}
HXLINE(  38)			poll();
            		}
            		HX_END_LOCAL_FUNC0((void))

Bool leading = __o_leading.Default(false);
            	HX_STACK_FRAME("thx.Timer","debounce",0xad888e5c,"thx.Timer.debounce","thx/Timer.hx",27,0xdd0b5e64)
            	HX_STACK_ARG(callback,"callback")
            	HX_STACK_ARG(delayms,"delayms")
            	HX_STACK_ARG(leading,"leading")
HXLINE(  27)		HX_VARI_NAME( ::Array< Bool >,leading1,"leading") = ::Array_obj< Bool >::__new(1)->init(0,leading);
HXLINE(  28)		HX_VARI( ::Array< ::Dynamic>,cancel) = ::Array_obj< ::Dynamic>::__new(1)->init(0,::thx::Functions_obj::noop_dyn());
HXLINE(  29)		HX_VARI(  ::Dynamic,poll) =  ::Dynamic(new _hx_Closure_0(delayms,cancel,callback));
HXLINE(  33)		return  ::Dynamic(new _hx_Closure_1(poll,callback,leading1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Timer_obj,debounce,return )

 ::Dynamic Timer_obj::throttle( ::Dynamic callback,Int delayms,hx::Null< Bool >  __o_leading){
            		HX_BEGIN_LOCAL_FUNC_S3(hx::LocalFunc,_hx_Closure_0,Int,delayms, ::Dynamic,callback,::Array< Bool >,waiting) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("thx.Timer","throttle",0x2281393d,"thx.Timer.throttle","thx/Timer.hx",49,0xdd0b5e64)
HXLINE(  50)			waiting[(int)0] = true;
HXLINE(  51)			::thx::Timer_obj::delay(callback,delayms);
            		}
            		HX_END_LOCAL_FUNC0((void))

            		HX_BEGIN_LOCAL_FUNC_S4(hx::LocalFunc,_hx_Closure_1, ::Dynamic,poll,::Array< Bool >,waiting, ::Dynamic,callback,::Array< Bool >,leading1) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("thx.Timer","throttle",0x2281393d,"thx.Timer.throttle","thx/Timer.hx",53,0xdd0b5e64)
HXLINE(  54)			if (leading1->__get((int)0)) {
HXLINE(  55)				leading1[(int)0] = false;
HXLINE(  56)				callback();
HXLINE(  57)				return;
            			}
HXLINE(  59)			if (waiting->__get((int)0)) {
HXLINE(  60)				return;
            			}
HXLINE(  61)			poll();
            		}
            		HX_END_LOCAL_FUNC0((void))

Bool leading = __o_leading.Default(false);
            	HX_STACK_FRAME("thx.Timer","throttle",0x2281393d,"thx.Timer.throttle","thx/Timer.hx",47,0xdd0b5e64)
            	HX_STACK_ARG(callback,"callback")
            	HX_STACK_ARG(delayms,"delayms")
            	HX_STACK_ARG(leading,"leading")
HXLINE(  47)		HX_VARI_NAME( ::Array< Bool >,leading1,"leading") = ::Array_obj< Bool >::__new(1)->init(0,leading);
HXLINE(  48)		HX_VARI( ::Array< Bool >,waiting) = ::Array_obj< Bool >::__new(1)->init(0,false);
HXLINE(  49)		HX_VARI(  ::Dynamic,poll) =  ::Dynamic(new _hx_Closure_0(delayms,callback,waiting));
HXLINE(  53)		return  ::Dynamic(new _hx_Closure_1(poll,waiting,callback,leading1));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Timer_obj,throttle,return )

 ::haxe::ds::IntMap Timer_obj::timers;

Int Timer_obj::_id;

 ::Dynamic Timer_obj::repeat( ::Dynamic callback,Int delayms){
            	HX_STACK_FRAME("thx.Timer","repeat",0x10ad572e,"thx.Timer.repeat","thx/Timer.hx",88,0xdd0b5e64)
            	HX_STACK_ARG(callback,"callback")
            	HX_STACK_ARG(delayms,"delayms")
HXLINE(  88)		HX_STACK_DO_THROW(HX_("platform does not support delays (Timer.repeat)",15,bc,a4,7e));
HXDLIN(  88)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Timer_obj,repeat,return )

 ::Dynamic Timer_obj::delay( ::Dynamic callback,Int delayms){
            	HX_STACK_FRAME("thx.Timer","delay",0x64663310,"thx.Timer.delay","thx/Timer.hx",114,0xdd0b5e64)
            	HX_STACK_ARG(callback,"callback")
            	HX_STACK_ARG(delayms,"delayms")
HXLINE( 114)		HX_STACK_DO_THROW(HX_("platform does not support delays (Timer.delay)",7f,49,55,22));
HXDLIN( 114)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Timer_obj,delay,return )

 ::Dynamic Timer_obj::frame( ::Dynamic callback){
            		HX_BEGIN_LOCAL_FUNC_S3(hx::LocalFunc,_hx_Closure_0,::Array< Float >,current,::Array< Float >,next, ::Dynamic,callback) HXARGC(0)
            		void _hx_run(){
            			HX_STACK_FRAME("thx.Timer","frame",0x93c2d3ba,"thx.Timer.frame","thx/Timer.hx",171,0xdd0b5e64)
HXLINE( 172)			Float _hx_tmp1 = ::haxe::Timer_obj::stamp();
HXDLIN( 172)			next[(int)0] = (_hx_tmp1 * ((Float)1000.0));
HXLINE( 173)			callback((next->__get((int)0) - current->__get((int)0)));
HXLINE( 174)			current[(int)0] = next->__get((int)0);
            		}
            		HX_END_LOCAL_FUNC0((void))

            	HX_STACK_FRAME("thx.Timer","frame",0x93c2d3ba,"thx.Timer.frame","thx/Timer.hx",130,0xdd0b5e64)
            	HX_STACK_ARG(callback,"callback")
HXLINE( 169)		Float _hx_tmp = ::haxe::Timer_obj::stamp();
HXDLIN( 169)		HX_VARI( ::Array< Float >,current) = ::Array_obj< Float >::__new(1)->init(0,(_hx_tmp * ((Float)1000.0)));
HXDLIN( 169)		HX_VARI( ::Array< Float >,next) = ::Array_obj< Float >::__new(0);
HXDLIN( 169)		HX_VARI(  ::Dynamic,listener) =  ::Dynamic(new _hx_Closure_0(current,next,callback));
HXLINE( 176)		return ::thx::Timer_obj::repeat(listener,::thx::Timer_obj::FRAME_RATE);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Timer_obj,frame,return )

 ::Dynamic Timer_obj::nextFrame( ::Dynamic callback){
            	HX_STACK_FRAME("thx.Timer","nextFrame",0xecd13847,"thx.Timer.nextFrame","thx/Timer.hx",206,0xdd0b5e64)
            	HX_STACK_ARG(callback,"callback")
HXLINE( 206)		return ::thx::Timer_obj::delay(callback,::thx::Timer_obj::FRAME_RATE);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Timer_obj,nextFrame,return )

Int Timer_obj::FRAME_RATE;

 ::Dynamic Timer_obj::immediate( ::Dynamic callback){
            	HX_STACK_FRAME("thx.Timer","immediate",0x0ef9b9fe,"thx.Timer.immediate","thx/Timer.hx",224,0xdd0b5e64)
            	HX_STACK_ARG(callback,"callback")
HXLINE( 224)		return ::thx::Timer_obj::delay(callback,(int)0);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Timer_obj,immediate,return )

void Timer_obj::clear( ::Dynamic id){
            	HX_STACK_FRAME("thx.Timer","clear",0xd59acd1a,"thx.Timer.clear","thx/Timer.hx",235,0xdd0b5e64)
            	HX_STACK_ARG(id,"id")
HXLINE( 235)		HX_STACK_DO_THROW(HX_("platform does not support delays (Timer.clear)",35,78,27,bf));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Timer_obj,clear,(void))

Float Timer_obj::time(){
            	HX_STACK_FRAME("thx.Timer","time",0x446fe120,"thx.Timer.time","thx/Timer.hx",256,0xdd0b5e64)
HXLINE( 256)		Float _hx_tmp = ::haxe::Timer_obj::stamp();
HXDLIN( 256)		return (_hx_tmp * ((Float)1000.0));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Timer_obj,time,return )

 ::Dynamic Timer_obj::_resolution;

Float Timer_obj::resolution(){
            	HX_STACK_FRAME("thx.Timer","resolution",0x55d1da7f,"thx.Timer.resolution","thx/Timer.hx",270,0xdd0b5e64)
HXLINE( 271)		if (hx::IsNotNull( ::thx::Timer_obj::_resolution )) {
HXLINE( 272)			return ::thx::Timer_obj::_resolution;
            		}
HXLINE( 273)		Float _hx_tmp = ::haxe::Timer_obj::stamp();
HXDLIN( 273)		HX_VARI( Float,start) = (_hx_tmp * ((Float)1000.0));
HXDLIN( 273)		HX_VAR( Float,end);
HXLINE( 275)		while(true){
HXLINE( 277)			Float _hx_tmp1 = ::haxe::Timer_obj::stamp();
HXDLIN( 277)			end = (_hx_tmp1 * ((Float)1000.0));
HXLINE( 275)			if (!(((end - start) == (int)0))) {
HXLINE( 275)				goto _hx_goto_0;
            			}
            		}
            		_hx_goto_0:;
HXLINE( 279)		return (::thx::Timer_obj::_resolution = (end - start));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC0(Timer_obj,resolution,return )


Timer_obj::Timer_obj()
{
}

bool Timer_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"_id") ) { outValue = _id; return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"time") ) { outValue = time_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"delay") ) { outValue = delay_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"frame") ) { outValue = frame_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"clear") ) { outValue = clear_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"timers") ) { outValue = timers; return true; }
		if (HX_FIELD_EQ(inName,"repeat") ) { outValue = repeat_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"debounce") ) { outValue = debounce_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"throttle") ) { outValue = throttle_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"nextFrame") ) { outValue = nextFrame_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"immediate") ) { outValue = immediate_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"FRAME_RATE") ) { outValue = FRAME_RATE; return true; }
		if (HX_FIELD_EQ(inName,"resolution") ) { outValue = resolution_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_resolution") ) { outValue = _resolution; return true; }
	}
	return false;
}

bool Timer_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"_id") ) { _id=ioValue.Cast< Int >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"timers") ) { timers=ioValue.Cast<  ::haxe::ds::IntMap >(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"FRAME_RATE") ) { FRAME_RATE=ioValue.Cast< Int >(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"_resolution") ) { _resolution=ioValue.Cast<  ::Dynamic >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Timer_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Timer_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*::haxe::ds::IntMap*/ ,(void *) &Timer_obj::timers,HX_HCSTRING("timers","\x0e","\x0d","\xd2","\x1e")},
	{hx::fsInt,(void *) &Timer_obj::_id,HX_HCSTRING("_id","\xfa","\x71","\x48","\x00")},
	{hx::fsInt,(void *) &Timer_obj::FRAME_RATE,HX_HCSTRING("FRAME_RATE","\x92","\x37","\x8a","\xad")},
	{hx::fsObject /*Dynamic*/ ,(void *) &Timer_obj::_resolution,HX_HCSTRING("_resolution","\x4b","\x02","\xd3","\x3f")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Timer_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Timer_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Timer_obj::timers,"timers");
	HX_MARK_MEMBER_NAME(Timer_obj::_id,"_id");
	HX_MARK_MEMBER_NAME(Timer_obj::FRAME_RATE,"FRAME_RATE");
	HX_MARK_MEMBER_NAME(Timer_obj::_resolution,"_resolution");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Timer_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Timer_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Timer_obj::timers,"timers");
	HX_VISIT_MEMBER_NAME(Timer_obj::_id,"_id");
	HX_VISIT_MEMBER_NAME(Timer_obj::FRAME_RATE,"FRAME_RATE");
	HX_VISIT_MEMBER_NAME(Timer_obj::_resolution,"_resolution");
};

#endif

hx::Class Timer_obj::__mClass;

static ::String Timer_obj_sStaticFields[] = {
	HX_HCSTRING("debounce","\xc9","\xf3","\xc9","\x25"),
	HX_HCSTRING("throttle","\xaa","\x9e","\xc2","\x9a"),
	HX_HCSTRING("timers","\x0e","\x0d","\xd2","\x1e"),
	HX_HCSTRING("_id","\xfa","\x71","\x48","\x00"),
	HX_HCSTRING("repeat","\x5b","\x97","\x7c","\x06"),
	HX_HCSTRING("delay","\x83","\xd7","\x26","\xd7"),
	HX_HCSTRING("frame","\x2d","\x78","\x83","\x06"),
	HX_HCSTRING("nextFrame","\x3a","\x92","\xc8","\xad"),
	HX_HCSTRING("FRAME_RATE","\x92","\x37","\x8a","\xad"),
	HX_HCSTRING("immediate","\xf1","\x13","\xf1","\xcf"),
	HX_HCSTRING("clear","\x8d","\x71","\x5b","\x48"),
	HX_HCSTRING("time","\x0d","\xcc","\xfc","\x4c"),
	HX_HCSTRING("_resolution","\x4b","\x02","\xd3","\x3f"),
	HX_HCSTRING("resolution","\x2c","\x35","\x49","\x6d"),
	::String(null())
};

void Timer_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("thx.Timer","\x3b","\x64","\xbf","\x57");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Timer_obj::__GetStatic;
	__mClass->mSetStaticField = &Timer_obj::__SetStatic;
	__mClass->mMarkFunc = Timer_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Timer_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Timer_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Timer_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Timer_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Timer_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Timer_obj::__boot()
{
{
            	HX_STACK_FRAME("thx.Timer","boot",0x388e9945,"thx.Timer.boot","thx/Timer.hx",68,0xdd0b5e64)
HXLINE(  68)		timers =  ::haxe::ds::IntMap_obj::__new();
            	}
{
            	HX_STACK_FRAME("thx.Timer","boot",0x388e9945,"thx.Timer.boot","thx/Timer.hx",69,0xdd0b5e64)
HXLINE(  69)		_id = (int)0;
            	}
{
            	HX_STACK_FRAME("thx.Timer","boot",0x388e9945,"thx.Timer.boot","thx/Timer.hx",210,0xdd0b5e64)
HXLINE( 210)		FRAME_RATE = ::Math_obj::round(((Float)16.6666666666666679));
            	}
}

} // end namespace thx
