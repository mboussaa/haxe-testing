// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_EReg
#include <EReg.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_thx_Floats
#include <thx/Floats.h>
#endif
#ifndef INCLUDED_thx_OrderingImpl
#include <thx/OrderingImpl.h>
#endif
#ifndef INCLUDED_thx__Ord_Ord_Impl_
#include <thx/_Ord/Ord_Impl_.h>
#endif

namespace thx{

void Floats_obj::__construct() { }

Dynamic Floats_obj::__CreateEmpty() { return new Floats_obj; }

hx::ObjectPtr< Floats_obj > Floats_obj::__new()
{
	hx::ObjectPtr< Floats_obj > _hx_result = new Floats_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Floats_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Floats_obj > _hx_result = new Floats_obj();
	_hx_result->__construct();
	return _hx_result;
}

Float Floats_obj::TOLERANCE;

Float Floats_obj::EPSILON;

 ::EReg Floats_obj::pattern_parse;

Float Floats_obj::angleDifference(Float a,Float b, ::Dynamic __o_turn){
 ::Dynamic turn = __o_turn.Default(((Float)360.0));
            	HX_STACK_FRAME("thx.Floats","angleDifference",0x9806e563,"thx.Floats.angleDifference","thx/Floats.hx",18,0xbd451f1c)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(turn,"turn")
HXLINE(  19)		HX_VARI( Float,r) = hx::Mod((b - a),turn);
HXLINE(  20)		Bool _hx_tmp = (r < (int)0);
HXDLIN(  20)		if (_hx_tmp) {
HXLINE(  21)			hx::AddEq(r,turn);
            		}
HXLINE(  22)		Bool _hx_tmp1 = (r > ((Float)turn / (Float)(int)2));
HXDLIN(  22)		if (_hx_tmp1) {
HXLINE(  23)			hx::SubEq(r,turn);
            		}
HXLINE(  24)		return r;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Floats_obj,angleDifference,return )

Float Floats_obj::ceilTo(Float f,Int decimals){
            	HX_STACK_FRAME("thx.Floats","ceilTo",0x619f5a8d,"thx.Floats.ceilTo","thx/Floats.hx",30,0xbd451f1c)
            	HX_STACK_ARG(f,"f")
            	HX_STACK_ARG(decimals,"decimals")
HXLINE(  31)		HX_VARI( Float,p) = ::Math_obj::pow((int)10,decimals);
HXLINE(  32)		Float _hx_tmp = ::Math_obj::fceil((f * p));
HXDLIN(  32)		return ((Float)_hx_tmp / (Float)p);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,ceilTo,return )

Bool Floats_obj::canParse(::String s){
            	HX_STACK_FRAME("thx.Floats","canParse",0xcee9fdf0,"thx.Floats.canParse","thx/Floats.hx",39,0xbd451f1c)
            	HX_STACK_ARG(s,"s")
HXLINE(  39)		return ::thx::Floats_obj::pattern_parse->match(s);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Floats_obj,canParse,return )

Float Floats_obj::clamp(Float v,Float min,Float max){
            	HX_STACK_FRAME("thx.Floats","clamp",0x7d9440ee,"thx.Floats.clamp","thx/Floats.hx",51,0xbd451f1c)
            	HX_STACK_ARG(v,"v")
            	HX_STACK_ARG(min,"min")
            	HX_STACK_ARG(max,"max")
HXLINE(  51)		if ((v < min)) {
HXLINE(  51)			return min;
            		}
            		else {
HXLINE(  51)			if ((v > max)) {
HXLINE(  51)				return max;
            			}
            			else {
HXLINE(  51)				return v;
            			}
            		}
HXDLIN(  51)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Floats_obj,clamp,return )

Float Floats_obj::clampSym(Float v,Float max){
            	HX_STACK_FRAME("thx.Floats","clampSym",0x2223ecb9,"thx.Floats.clampSym","thx/Floats.hx",58,0xbd451f1c)
            	HX_STACK_ARG(v,"v")
            	HX_STACK_ARG(max,"max")
HXLINE(  58)		HX_VARI( Float,min) = -(max);
HXDLIN(  58)		if ((v < min)) {
HXLINE(  58)			return min;
            		}
            		else {
HXLINE(  58)			if ((v > max)) {
HXLINE(  58)				return max;
            			}
            			else {
HXLINE(  58)				return v;
            			}
            		}
HXDLIN(  58)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,clampSym,return )

Int Floats_obj::compare(Float a,Float b){
            	HX_STACK_FRAME("thx.Floats","compare",0x59aa8958,"thx.Floats.compare","thx/Floats.hx",64,0xbd451f1c)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE(  64)		if ((a < b)) {
HXLINE(  64)			return (int)-1;
            		}
            		else {
HXLINE(  64)			if ((a > b)) {
HXLINE(  64)				return (int)1;
            			}
            			else {
HXLINE(  64)				return (int)0;
            			}
            		}
HXDLIN(  64)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,compare,return )

Float Floats_obj::floorTo(Float f,Int decimals){
            	HX_STACK_FRAME("thx.Floats","floorTo",0xc989971a,"thx.Floats.floorTo","thx/Floats.hx",69,0xbd451f1c)
            	HX_STACK_ARG(f,"f")
            	HX_STACK_ARG(decimals,"decimals")
HXLINE(  70)		HX_VARI( Float,p) = ::Math_obj::pow((int)10,decimals);
HXLINE(  71)		Float _hx_tmp = ::Math_obj::ffloor((f * p));
HXDLIN(  71)		return ((Float)_hx_tmp / (Float)p);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,floorTo,return )

Float Floats_obj::interpolate(Float f,Float a,Float b){
            	HX_STACK_FRAME("thx.Floats","interpolate",0x9ba61af4,"thx.Floats.interpolate","thx/Floats.hx",78,0xbd451f1c)
            	HX_STACK_ARG(f,"f")
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE(  78)		return (((b - a) * f) + a);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Floats_obj,interpolate,return )

Float Floats_obj::interpolateAngle(Float f,Float a,Float b,hx::Null< Float >  __o_turn){
Float turn = __o_turn.Default(360);
            	HX_STACK_FRAME("thx.Floats","interpolateAngle",0xf71f643f,"thx.Floats.interpolateAngle","thx/Floats.hx",86,0xbd451f1c)
            	HX_STACK_ARG(f,"f")
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(turn,"turn")
HXLINE(  86)		return ::thx::Floats_obj::wrapCircular(::thx::Floats_obj::interpolate(f,a,(a + ::thx::Floats_obj::angleDifference(a,b,turn))),turn);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Floats_obj,interpolateAngle,return )

Float Floats_obj::interpolateAngleWidest(Float f,Float a,Float b,hx::Null< Float >  __o_turn){
Float turn = __o_turn.Default(360);
            	HX_STACK_FRAME("thx.Floats","interpolateAngleWidest",0xb7104913,"thx.Floats.interpolateAngleWidest","thx/Floats.hx",94,0xbd451f1c)
            	HX_STACK_ARG(f,"f")
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(turn,"turn")
HXLINE(  94)		return ::thx::Floats_obj::wrapCircular((::thx::Floats_obj::interpolateAngle(f,a,b,turn) - ((Float)turn / (Float)(int)2)),turn);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Floats_obj,interpolateAngleWidest,return )

Float Floats_obj::interpolateAngleCW(Float f,Float a,Float b,hx::Null< Float >  __o_turn){
Float turn = __o_turn.Default(360);
            	HX_STACK_FRAME("thx.Floats","interpolateAngleCW",0x88f06cb3,"thx.Floats.interpolateAngleCW","thx/Floats.hx",100,0xbd451f1c)
            	HX_STACK_ARG(f,"f")
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(turn,"turn")
HXLINE( 101)		a = ::thx::Floats_obj::wrapCircular(a,turn);
HXLINE( 102)		b = ::thx::Floats_obj::wrapCircular(b,turn);
HXLINE( 103)		Bool _hx_tmp = (b < a);
HXDLIN( 103)		if (_hx_tmp) {
HXLINE( 104)			hx::AddEq(b,turn);
            		}
HXLINE( 105)		return ::thx::Floats_obj::wrapCircular(::thx::Floats_obj::interpolate(f,a,b),turn);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Floats_obj,interpolateAngleCW,return )

Float Floats_obj::interpolateAngleCCW(Float f,Float a,Float b,hx::Null< Float >  __o_turn){
Float turn = __o_turn.Default(360);
            	HX_STACK_FRAME("thx.Floats","interpolateAngleCCW",0x496e9ed8,"thx.Floats.interpolateAngleCCW","thx/Floats.hx",111,0xbd451f1c)
            	HX_STACK_ARG(f,"f")
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(turn,"turn")
HXLINE( 112)		a = ::thx::Floats_obj::wrapCircular(a,turn);
HXLINE( 113)		b = ::thx::Floats_obj::wrapCircular(b,turn);
HXLINE( 114)		Bool _hx_tmp = (b > a);
HXDLIN( 114)		if (_hx_tmp) {
HXLINE( 115)			hx::SubEq(b,turn);
            		}
HXLINE( 116)		return ::thx::Floats_obj::wrapCircular(::thx::Floats_obj::interpolate(f,a,b),turn);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Floats_obj,interpolateAngleCCW,return )

 ::Dynamic Floats_obj::max( ::Dynamic a, ::Dynamic b){
            	HX_STACK_FRAME("thx.Floats","max",0x5e5b65d7,"thx.Floats.max","thx/Floats.hx",123,0xbd451f1c)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 123)		if (hx::IsGreater( a,b )) {
HXLINE( 123)			return a;
            		}
            		else {
HXLINE( 123)			return b;
            		}
HXDLIN( 123)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,max,return )

 ::Dynamic Floats_obj::min( ::Dynamic a, ::Dynamic b){
            	HX_STACK_FRAME("thx.Floats","min",0x5e5b6cc5,"thx.Floats.min","thx/Floats.hx",129,0xbd451f1c)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
HXLINE( 129)		if (hx::IsLess( a,b )) {
HXLINE( 129)			return a;
            		}
            		else {
HXLINE( 129)			return b;
            		}
HXDLIN( 129)		return null();
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,min,return )

Bool Floats_obj::nearEquals(Float a,Float b, ::Dynamic __o_tollerance){
 ::Dynamic tollerance = __o_tollerance.Default(((Float)1e-9));
            	HX_STACK_FRAME("thx.Floats","nearEquals",0x45073274,"thx.Floats.nearEquals","thx/Floats.hx",136,0xbd451f1c)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(tollerance,"tollerance")
HXLINE( 137)		Bool _hx_tmp = ::Math_obj::isFinite(a);
HXDLIN( 137)		if (_hx_tmp) {
HXLINE( 142)			Float _hx_tmp1 = ::Math_obj::abs((a - b));
HXDLIN( 142)			return hx::IsLessEq( _hx_tmp1,tollerance );
            		}
HXLINE( 144)		Bool _hx_tmp2 = ::Math_obj::isNaN(a);
HXDLIN( 144)		if (_hx_tmp2) {
HXLINE( 145)			return ::Math_obj::isNaN(b);
            		}
HXLINE( 146)		Bool _hx_tmp3 = ::Math_obj::isNaN(b);
HXDLIN( 146)		if (_hx_tmp3) {
HXLINE( 147)			return false;
            		}
HXLINE( 148)		Bool _hx_tmp4 = !(::Math_obj::isFinite(b));
HXDLIN( 148)		if (_hx_tmp4) {
HXLINE( 149)			return ((a > (int)0) == (b > (int)0));
            		}
HXLINE( 151)		return false;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Floats_obj,nearEquals,return )

Bool Floats_obj::nearEqualAngles(Float a,Float b, ::Dynamic __o_turn, ::Dynamic __o_tollerance){
 ::Dynamic turn = __o_turn.Default(((Float)360.0));
 ::Dynamic tollerance = __o_tollerance.Default(((Float)1e-9));
            	HX_STACK_FRAME("thx.Floats","nearEqualAngles",0xf7ac73bf,"thx.Floats.nearEqualAngles","thx/Floats.hx",161,0xbd451f1c)
            	HX_STACK_ARG(a,"a")
            	HX_STACK_ARG(b,"b")
            	HX_STACK_ARG(turn,"turn")
            	HX_STACK_ARG(tollerance,"tollerance")
HXLINE( 161)		Float _hx_tmp = ::Math_obj::abs(::thx::Floats_obj::angleDifference(a,b,turn));
HXDLIN( 161)		return hx::IsLessEq( _hx_tmp,tollerance );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC4(Floats_obj,nearEqualAngles,return )

Bool Floats_obj::nearZero(Float n, ::Dynamic __o_tollerance){
 ::Dynamic tollerance = __o_tollerance.Default(((Float)1e-9));
            	HX_STACK_FRAME("thx.Floats","nearZero",0x46bc6c1d,"thx.Floats.nearZero","thx/Floats.hx",168,0xbd451f1c)
            	HX_STACK_ARG(n,"n")
            	HX_STACK_ARG(tollerance,"tollerance")
HXLINE( 168)		Float _hx_tmp = ::Math_obj::abs(n);
HXDLIN( 168)		return hx::IsLessEq( _hx_tmp,tollerance );
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,nearZero,return )

Float Floats_obj::normalize(Float v){
            	HX_STACK_FRAME("thx.Floats","normalize",0xa9a67b00,"thx.Floats.normalize","thx/Floats.hx",174,0xbd451f1c)
            	HX_STACK_ARG(v,"v")
HXLINE( 174)		if ((v < (int)0)) {
HXLINE( 174)			return (int)0;
            		}
            		else {
HXLINE( 174)			if ((v > (int)1)) {
HXLINE( 174)				return (int)1;
            			}
            			else {
HXLINE( 174)				return v;
            			}
            		}
HXDLIN( 174)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Floats_obj,normalize,return )

Float Floats_obj::parse(::String s){
            	HX_STACK_FRAME("thx.Floats","parse",0xf2915e26,"thx.Floats.parse","thx/Floats.hx",179,0xbd451f1c)
            	HX_STACK_ARG(s,"s")
HXLINE( 180)		::String _hx_tmp = s.substring((int)0,(int)1);
HXDLIN( 180)		if ((_hx_tmp == HX_("+",2b,00,00,00))) {
HXLINE( 181)			s = s.substring((int)1,null());
            		}
HXLINE( 182)		return ::Std_obj::parseFloat(s);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Floats_obj,parse,return )

Float Floats_obj::root(Float base,Float index){
            	HX_STACK_FRAME("thx.Floats","root",0x34f65f8f,"thx.Floats.root","thx/Floats.hx",189,0xbd451f1c)
            	HX_STACK_ARG(base,"base")
            	HX_STACK_ARG(index,"index")
HXLINE( 189)		return ::Math_obj::pow(base,((Float)(int)1 / (Float)index));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,root,return )

Float Floats_obj::roundTo(Float f,Int decimals){
            	HX_STACK_FRAME("thx.Floats","roundTo",0x6350e21c,"thx.Floats.roundTo","thx/Floats.hx",194,0xbd451f1c)
            	HX_STACK_ARG(f,"f")
            	HX_STACK_ARG(decimals,"decimals")
HXLINE( 195)		HX_VARI( Float,p) = ::Math_obj::pow((int)10,decimals);
HXLINE( 196)		Float _hx_tmp = ::Math_obj::fround((f * p));
HXDLIN( 196)		return ((Float)_hx_tmp / (Float)p);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,roundTo,return )

Int Floats_obj::sign( ::Dynamic value){
            	HX_STACK_FRAME("thx.Floats","sign",0x359b01aa,"thx.Floats.sign","thx/Floats.hx",203,0xbd451f1c)
            	HX_STACK_ARG(value,"value")
HXLINE( 203)		if (hx::IsLess( value,(int)0 )) {
HXLINE( 203)			return (int)-1;
            		}
            		else {
HXLINE( 203)			return (int)1;
            		}
HXDLIN( 203)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Floats_obj,sign,return )

::String Floats_obj::toString(Float v){
            	HX_STACK_FRAME("thx.Floats","toString",0xdb6ffc99,"thx.Floats.toString","thx/Floats.hx",206,0xbd451f1c)
            	HX_STACK_ARG(v,"v")
HXLINE( 206)		return (HX_("",00,00,00,00) + v);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Floats_obj,toString,return )

Float Floats_obj::toFloat(::String s){
            	HX_STACK_FRAME("thx.Floats","toFloat",0xa55c82d4,"thx.Floats.toFloat","thx/Floats.hx",212,0xbd451f1c)
            	HX_STACK_ARG(s,"s")
HXLINE( 212)		return ::thx::Floats_obj::parse(s);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Floats_obj,toFloat,return )

Int Floats_obj::trunc(Float value){
            	HX_STACK_FRAME("thx.Floats","trunc",0x4b6a931f,"thx.Floats.trunc","thx/Floats.hx",215,0xbd451f1c)
            	HX_STACK_ARG(value,"value")
HXLINE( 215)		if ((value < ((Float)0.0))) {
HXLINE( 215)			return ::Math_obj::ceil(value);
            		}
            		else {
HXLINE( 215)			return ::Math_obj::floor(value);
            		}
HXDLIN( 215)		return (int)0;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Floats_obj,trunc,return )

Float Floats_obj::ftrunc(Float value){
            	HX_STACK_FRAME("thx.Floats","ftrunc",0x3dadf9b3,"thx.Floats.ftrunc","thx/Floats.hx",218,0xbd451f1c)
            	HX_STACK_ARG(value,"value")
HXLINE( 218)		if ((value < ((Float)0.0))) {
HXLINE( 218)			return ::Math_obj::fceil(value);
            		}
            		else {
HXLINE( 218)			return ::Math_obj::ffloor(value);
            		}
HXDLIN( 218)		return ((Float)0.);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Floats_obj,ftrunc,return )

Float Floats_obj::wrap(Float v,Float min,Float max){
            	HX_STACK_FRAME("thx.Floats","wrap",0x3846ab37,"thx.Floats.wrap","thx/Floats.hx",226,0xbd451f1c)
            	HX_STACK_ARG(v,"v")
            	HX_STACK_ARG(min,"min")
            	HX_STACK_ARG(max,"max")
HXLINE( 227)		HX_VARI( Float,range) = ((max - min) + (int)1);
HXLINE( 228)		Bool _hx_tmp = (v < min);
HXDLIN( 228)		if (_hx_tmp) {
HXLINE( 228)			Float _hx_tmp1 = (range * (((Float)(min - v) / (Float)range) + (int)1));
HXDLIN( 228)			hx::AddEq(v,_hx_tmp1);
            		}
HXLINE( 229)		return (min + hx::Mod((v - min),range));
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC3(Floats_obj,wrap,return )

Float Floats_obj::wrapCircular(Float v,Float max){
            	HX_STACK_FRAME("thx.Floats","wrapCircular",0x6acb9cb6,"thx.Floats.wrapCircular","thx/Floats.hx",235,0xbd451f1c)
            	HX_STACK_ARG(v,"v")
            	HX_STACK_ARG(max,"max")
HXLINE( 236)		hx::ModEq(v,max);
HXLINE( 237)		Bool _hx_tmp = (v < (int)0);
HXDLIN( 237)		if (_hx_tmp) {
HXLINE( 238)			hx::AddEq(v,max);
            		}
HXLINE( 239)		return v;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(Floats_obj,wrapCircular,return )

 ::Dynamic Floats_obj::order;

 ::Dynamic Floats_obj::monoid;


Floats_obj::Floats_obj()
{
}

bool Floats_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"max") ) { outValue = max_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"min") ) { outValue = min_dyn(); return true; }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"root") ) { outValue = root_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"sign") ) { outValue = sign_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"wrap") ) { outValue = wrap_dyn(); return true; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"clamp") ) { outValue = clamp_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"parse") ) { outValue = parse_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"trunc") ) { outValue = trunc_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"order") ) { outValue = order; return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"ceilTo") ) { outValue = ceilTo_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"ftrunc") ) { outValue = ftrunc_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"monoid") ) { outValue = monoid; return true; }
		break;
	case 7:
		if (HX_FIELD_EQ(inName,"compare") ) { outValue = compare_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"floorTo") ) { outValue = floorTo_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"roundTo") ) { outValue = roundTo_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toFloat") ) { outValue = toFloat_dyn(); return true; }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"canParse") ) { outValue = canParse_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"clampSym") ) { outValue = clampSym_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"nearZero") ) { outValue = nearZero_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"toString") ) { outValue = toString_dyn(); return true; }
		break;
	case 9:
		if (HX_FIELD_EQ(inName,"normalize") ) { outValue = normalize_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"nearEquals") ) { outValue = nearEquals_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"interpolate") ) { outValue = interpolate_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"wrapCircular") ) { outValue = wrapCircular_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"pattern_parse") ) { outValue = pattern_parse; return true; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"angleDifference") ) { outValue = angleDifference_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"nearEqualAngles") ) { outValue = nearEqualAngles_dyn(); return true; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"interpolateAngle") ) { outValue = interpolateAngle_dyn(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"interpolateAngleCW") ) { outValue = interpolateAngleCW_dyn(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"interpolateAngleCCW") ) { outValue = interpolateAngleCCW_dyn(); return true; }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"interpolateAngleWidest") ) { outValue = interpolateAngleWidest_dyn(); return true; }
	}
	return false;
}

bool Floats_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"order") ) { order=ioValue.Cast<  ::Dynamic >(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"monoid") ) { monoid=ioValue.Cast<  ::Dynamic >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"pattern_parse") ) { pattern_parse=ioValue.Cast<  ::EReg >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Floats_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Floats_obj_sStaticStorageInfo[] = {
	{hx::fsFloat,(void *) &Floats_obj::TOLERANCE,HX_HCSTRING("TOLERANCE","\xed","\xac","\xd4","\x2e")},
	{hx::fsFloat,(void *) &Floats_obj::EPSILON,HX_HCSTRING("EPSILON","\x4a","\x89","\x92","\x2c")},
	{hx::fsObject /*::EReg*/ ,(void *) &Floats_obj::pattern_parse,HX_HCSTRING("pattern_parse","\xc4","\x79","\x71","\x3d")},
	{hx::fsObject /*Dynamic*/ ,(void *) &Floats_obj::order,HX_HCSTRING("order","\x8e","\xf0","\x20","\x35")},
	{hx::fsObject /*Dynamic*/ ,(void *) &Floats_obj::monoid,HX_HCSTRING("monoid","\xbe","\xc6","\x6a","\xc7")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Floats_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Floats_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Floats_obj::TOLERANCE,"TOLERANCE");
	HX_MARK_MEMBER_NAME(Floats_obj::EPSILON,"EPSILON");
	HX_MARK_MEMBER_NAME(Floats_obj::pattern_parse,"pattern_parse");
	HX_MARK_MEMBER_NAME(Floats_obj::order,"order");
	HX_MARK_MEMBER_NAME(Floats_obj::monoid,"monoid");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Floats_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Floats_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Floats_obj::TOLERANCE,"TOLERANCE");
	HX_VISIT_MEMBER_NAME(Floats_obj::EPSILON,"EPSILON");
	HX_VISIT_MEMBER_NAME(Floats_obj::pattern_parse,"pattern_parse");
	HX_VISIT_MEMBER_NAME(Floats_obj::order,"order");
	HX_VISIT_MEMBER_NAME(Floats_obj::monoid,"monoid");
};

#endif

hx::Class Floats_obj::__mClass;

static ::String Floats_obj_sStaticFields[] = {
	HX_HCSTRING("TOLERANCE","\xed","\xac","\xd4","\x2e"),
	HX_HCSTRING("EPSILON","\x4a","\x89","\x92","\x2c"),
	HX_HCSTRING("pattern_parse","\xc4","\x79","\x71","\x3d"),
	HX_HCSTRING("angleDifference","\xb0","\x09","\x09","\xfc"),
	HX_HCSTRING("ceilTo","\xe0","\xf3","\x86","\x02"),
	HX_HCSTRING("canParse","\x03","\xd2","\xe8","\x2b"),
	HX_HCSTRING("clamp","\xfb","\x72","\x58","\x48"),
	HX_HCSTRING("clampSym","\xcc","\xc0","\x22","\x7f"),
	HX_HCSTRING("compare","\xa5","\x18","\x69","\x83"),
	HX_HCSTRING("floorTo","\x67","\x26","\x48","\xf3"),
	HX_HCSTRING("interpolate","\xc1","\xd4","\x32","\x1f"),
	HX_HCSTRING("interpolateAngle","\x52","\x03","\xfd","\x14"),
	HX_HCSTRING("interpolateAngleWidest","\x66","\xf8","\x86","\x03"),
	HX_HCSTRING("interpolateAngleCW","\x86","\x36","\xc2","\x10"),
	HX_HCSTRING("interpolateAngleCCW","\xa5","\x6d","\x2d","\x99"),
	HX_HCSTRING("max","\xa4","\x0a","\x53","\x00"),
	HX_HCSTRING("min","\x92","\x11","\x53","\x00"),
	HX_HCSTRING("nearEquals","\x47","\x71","\x71","\xfe"),
	HX_HCSTRING("nearEqualAngles","\x0c","\x98","\xae","\x5b"),
	HX_HCSTRING("nearZero","\x30","\x40","\xbb","\xa3"),
	HX_HCSTRING("normalize","\x8d","\x37","\xa1","\xab"),
	HX_HCSTRING("parse","\x33","\x90","\x55","\xbd"),
	HX_HCSTRING("root","\x22","\xee","\xae","\x4b"),
	HX_HCSTRING("roundTo","\x69","\x71","\x0f","\x8d"),
	HX_HCSTRING("sign","\x3d","\x90","\x53","\x4c"),
	HX_HCSTRING("toString","\xac","\xd0","\x6e","\x38"),
	HX_HCSTRING("toFloat","\x21","\x12","\x1b","\xcf"),
	HX_HCSTRING("trunc","\x2c","\xc5","\x2e","\x16"),
	HX_HCSTRING("ftrunc","\x06","\x93","\x95","\xde"),
	HX_HCSTRING("wrap","\xca","\x39","\xff","\x4e"),
	HX_HCSTRING("wrapCircular","\x49","\x76","\x61","\x02"),
	HX_HCSTRING("order","\x8e","\xf0","\x20","\x35"),
	HX_HCSTRING("monoid","\xbe","\xc6","\x6a","\xc7"),
	::String(null())
};

void Floats_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("thx.Floats","\x21","\x66","\x3c","\x92");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Floats_obj::__GetStatic;
	__mClass->mSetStaticField = &Floats_obj::__SetStatic;
	__mClass->mMarkFunc = Floats_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Floats_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Floats_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Floats_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Floats_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Floats_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Floats_obj::__boot()
{
{
            	HX_STACK_FRAME("thx.Floats","boot",0x2a62f59f,"thx.Floats.boot","thx/Floats.hx",7,0xbd451f1c)
HXLINE(   7)		TOLERANCE = ((Float)10e-5);
            	}
{
            	HX_STACK_FRAME("thx.Floats","boot",0x2a62f59f,"thx.Floats.boot","thx/Floats.hx",11,0xbd451f1c)
HXLINE(  11)		EPSILON = ((Float)1e-9);
            	}
{
            	HX_STACK_FRAME("thx.Floats","boot",0x2a62f59f,"thx.Floats.boot","thx/Floats.hx",13,0xbd451f1c)
HXLINE(  13)		pattern_parse =  ::EReg_obj::__new(HX_("^(\\+|-)?\\d+(\\.\\d+)?(e-?\\d+)?$",dc,f2,2a,f6),HX_("",00,00,00,00));
            	}
{
            	HX_STACK_FRAME("thx.Floats","boot",0x2a62f59f,"thx.Floats.boot","thx/Floats.hx",245,0xbd451f1c)
HXLINE( 245)		order = ::thx::_Ord::Ord_Impl__obj::fromIntComparison(::thx::Floats_obj::compare_dyn());
            	}
{
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            		Float _hx_run(Float a,Float b){
            			HX_STACK_FRAME("thx.Floats","boot",0x2a62f59f,"thx.Floats.boot","thx/Floats.hx",248,0xbd451f1c)
            			HX_STACK_ARG(a,"a")
            			HX_STACK_ARG(b,"b")
HXLINE( 248)			return (a + b);
            		}
            		HX_END_LOCAL_FUNC2(return)

            	HX_STACK_FRAME("thx.Floats","boot",0x2a62f59f,"thx.Floats.boot","thx/Floats.hx",248,0xbd451f1c)
HXLINE( 248)		monoid =  ::Dynamic(hx::Anon_obj::Create(2)
            			->setFixed(0,HX_("append",da,e1,d3,8f), ::Dynamic(new _hx_Closure_0()))
            			->setFixed(1,HX_("zero",28,0f,f1,50),((Float)0.0)));
            	}
}

} // end namespace thx
