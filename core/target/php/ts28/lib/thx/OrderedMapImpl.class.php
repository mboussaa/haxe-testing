<?php

// Generated by Haxe 3.3.0
class thx_OrderedMapImpl implements haxe_IMap{
	public function __construct($map) {
		if(!php_Boot::$skip_constructor) {
		$this->map = $map;
		$this->arr = (new _hx_array(array()));
		$this->length = 0;
	}}
	public $map;
	public $arr;
	public $length;
	public function get($k) {
		return $this->map->get($k);
	}
	public function keyAt($index) {
		return $this->arr[$index];
	}
	public function keyIndex($k) {
		{
			$_g1 = 0;
			$_g = $this->arr->length;
			while($_g1 < $_g) {
				$i = $_g1++;
				if((is_object($_t = $this->arr[$i]) && ($_t instanceof Enum) ? $_t == $k : _hx_equal($_t, $k))) {
					return $i;
				}
				unset($i,$_t);
			}
		}
		return -1;
	}
	public function valueIndex($v) {
		{
			$_g1 = 0;
			$_g = $this->arr->length;
			while($_g1 < $_g) {
				$i = $_g1++;
				$tmp = $this->map->get($this->arr[$i]);
				if((is_object($_t = $tmp) && ($_t instanceof Enum) ? $_t == $v : _hx_equal($_t, $v))) {
					return $i;
				}
				unset($tmp,$i,$_t);
			}
		}
		return -1;
	}
	public function at($index) {
		$tmp = $this->keyAt($index);
		return $this->map->get($tmp);
	}
	public function set($k, $v) {
		$tmp = !$this->map->exists($k);
		if($tmp) {
			$this->arr->push($k);
			$this->length++;
		}
		$this->map->set($k, $v);
	}
	public function hempty() {
		throw new HException(new thx_error_AbstractMethod(_hx_anonymous(array("fileName" => "OrderedMap.hx", "lineNumber" => 125, "className" => "thx.OrderedMapImpl", "methodName" => "empty"))));
	}
	public function setValue($k, $v) {
		$this->set($k, $v);
		return $v;
	}
	public function insert($index, $k, $v) {
		$this->remove($k);
		$this->arr->insert($index, $k);
		$this->map->set($k, $v);
		$this->length++;
	}
	public function exists($k) {
		return $this->map->exists($k);
	}
	public function remove($k) {
		$tmp = !$this->map->exists($k);
		if($tmp) {
			return false;
		}
		$this->map->remove($k);
		$this->arr->remove($k);
		$this->length--;
		return true;
	}
	public function removeAt($index) {
		$key = $this->arr[$index];
		if($key === null) {
			return false;
		}
		$this->map->remove($key);
		$this->arr->remove($key);
		$this->length--;
		return true;
	}
	public function keys() {
		return $this->arr->iterator();
	}
	public function iterator() {
		return $this->toArray()->iterator();
	}
	public function tuples() {
		$_gthis = $this;
		return $this->arr->map(array(new _hx_lambda(array(&$_gthis), "thx_OrderedMapImpl_0"), 'execute'));
	}
	public function toString() {
		$s = "";
		$s = "[";
		$it = $this->keys();
		while(true) {
			$tmp = !$it->hasNext();
			if($tmp) {
				break;
			}
			$k = $it->next();
			$tmp1 = Std::string($k);
			$s .= _hx_string_or_null($tmp1);
			$s .= " => ";
			$tmp2 = $this->map->get($k);
			$tmp3 = Std::string($tmp2);
			$s .= _hx_string_or_null($tmp3);
			$tmp4 = $it->hasNext();
			if($tmp4) {
				$s .= ", ";
			}
			unset($tmp4,$tmp3,$tmp2,$tmp1,$tmp,$k);
		}
		$s .= "]";
		return $s;
	}
	public function toArray() {
		$values = (new _hx_array(array()));
		{
			$_g = 0;
			$_g1 = $this->arr;
			while($_g < $_g1->length) {
				$k = $_g1[$_g];
				++$_g;
				$tmp = $this->map->get($k);
				$values->push($tmp);
				unset($tmp,$k);
			}
		}
		return $values;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return $this->toString(); }
}
function thx_OrderedMapImpl_0(&$_gthis, $key) {
	{
		$_1 = $_gthis->map->get($key);
		return _hx_anonymous(array("_0" => $key, "_1" => $_1));
	}
}
