<?php

// Generated by Haxe 3.3.0
class thx_Ints {
	public function __construct(){}
	static $pattern_parse;
	static function abs($v) {
		if($v < 0) {
			return -$v;
		} else {
			return $v;
		}
	}
	static function canParse($s) {
		return thx_Ints::$pattern_parse->match($s);
	}
	static function clamp($v, $min, $max) {
		if($v < $min) {
			return $min;
		} else {
			if($v > $max) {
				return $max;
			} else {
				return $v;
			}
		}
	}
	static function clampSym($v, $max) {
		$min = -$max;
		if($v < $min) {
			return $min;
		} else {
			if($v > $max) {
				return $max;
			} else {
				return $v;
			}
		}
	}
	static function compare($a, $b) {
		return $a - $b;
	}
	static function gcd($m, $n) {
		$tmp = $m < 0;
		if($tmp) {
			$m = -$m;
		} else {
			$m = $m;
		}
		$tmp1 = $n < 0;
		if($tmp1) {
			$n = -$n;
		} else {
			$n = $n;
		}
		if($n === 0) {
			return $m;
		}
		return thx_Ints::gcd($n, _hx_mod($m, $n));
	}
	static function interpolate($f, $a, $b) {
		return Math::round($a + ($b - $a) * $f);
	}
	static function isEven($v) {
		return _hx_mod($v, 2) === 0;
	}
	static function isOdd($v) {
		return _hx_mod($v, 2) !== 0;
	}
	static function lpad($v, $pad = null, $len) {
		if($pad === null) {
			$pad = "0";
		}
		$neg = false;
		$tmp = $v < 0;
		if($tmp) {
			$neg = true;
			$v = -$v;
		}
		$tmp1 = null;
		if($neg) {
			$tmp1 = "-";
		} else {
			$tmp1 = "";
		}
		$s = "" . _hx_string_rec($v, "");
		$tmp2 = null;
		$tmp3 = null;
		if(strlen($pad) !== 0) {
			$tmp3 = strlen($s) >= $len;
		} else {
			$tmp3 = true;
		}
		if($tmp3) {
			$tmp2 = $s;
		} else {
			$tmp2 = str_pad($s, Math::ceil(($len - strlen($s)) / strlen($pad)) * strlen($pad) + strlen($s), $pad, STR_PAD_LEFT);
		}
		return _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
	}
	static function lcm($m, $n) {
		$tmp = $m < 0;
		if($tmp) {
			$m = -$m;
		} else {
			$m = $m;
		}
		$tmp1 = $n < 0;
		if($tmp1) {
			$n = -$n;
		} else {
			$n = $n;
		}
		if($n === 0) {
			return $m;
		}
		$tmp2 = Std::int($n / thx_Ints::gcd($m, $n));
		return $m * $tmp2;
	}
	static function rpad($v, $pad = null, $len) {
		if($pad === null) {
			$pad = "0";
		}
		$s = "" . _hx_string_rec($v, "");
		$tmp = null;
		if(strlen($pad) !== 0) {
			$tmp = strlen($s) >= $len;
		} else {
			$tmp = true;
		}
		if($tmp) {
			return $s;
		} else {
			return str_pad($s, Math::ceil(($len - strlen($s)) / strlen($pad)) * strlen($pad) + strlen($s), $pad, STR_PAD_RIGHT);
		}
	}
	static function max($a, $b) {
		if($a > $b) {
			return $a;
		} else {
			return $b;
		}
	}
	static function min($a, $b) {
		if($a < $b) {
			return $a;
		} else {
			return $b;
		}
	}
	static function parse($s, $base = null) {
		$tmp = null;
		if($base !== null) {
			if($base >= 2) {
				$tmp = $base > strlen(thx_Ints::$BASE);
			} else {
				$tmp = true;
			}
		} else {
			$tmp = false;
		}
		if($tmp) {
			throw new HException("invalid base " . _hx_string_rec($base, "") . ", it must be between 2 and " . _hx_string_rec(strlen(thx_Ints::$BASE), ""));
		}
		$s = strtolower(trim($s));
		$sign = null;
		$tmp1 = StringTools::startsWith($s, "+");
		if($tmp1) {
			$s = _hx_substring($s, 1, null);
			$sign = 1;
		} else {
			$tmp2 = StringTools::startsWith($s, "-");
			if($tmp2) {
				$s = _hx_substring($s, 1, null);
				$sign = -1;
			} else {
				$sign = 1;
			}
		}
		if(strlen($s) === 0) {
			return null;
		}
		$tmp3 = StringTools::startsWith($s, "0x");
		if($tmp3) {
			$tmp4 = null;
			if(null !== $base) {
				$tmp4 = 16 !== $base;
			} else {
				$tmp4 = false;
			}
			if($tmp4) {
				return null;
			}
			$base = 16;
			$s = _hx_substring($s, 2, null);
		} else {
			$tmp5 = null === $base;
			if($tmp5) {
				$base = 10;
			}
		}
		$acc = 0;
		try {
			thx_Strings::map($s, array(new _hx_lambda(array(&$acc, &$base), "thx_Ints_0"), 'execute'));
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{}
		}
		return $acc * $sign;
	}
	static function random($min = null, $max) {
		if($min === null) {
			$min = 0;
		}
		$tmp = Std::random($max + 1);
		return $tmp + $min;
	}
	static function range($start, $stop = null, $step = null) {
		if($step === null) {
			$step = 1;
		}
		$tmp = null === $stop;
		if($tmp) {
			$stop = $start;
			$start = 0;
		}
		if(($stop - $start) / $step === Math::$POSITIVE_INFINITY) {
			throw new HException("infinite range");
		}
		$range = (new _hx_array(array()));
		$i = -1;
		$j = null;
		if($step < 0) {
			while(true) {
				$tmp1 = ++$i;
				$j = $start + $step * $tmp1;
				if(!($j > $stop)) {
					break;
				}
				$range->push($j);
				unset($tmp1);
			}
		} else {
			while(true) {
				$tmp2 = ++$i;
				$j = $start + $step * $tmp2;
				if(!($j < $stop)) {
					break;
				}
				$range->push($j);
				unset($tmp2);
			}
		}
		return $range;
	}
	static function rangeIter($start, $stop = null, $step = null) {
		if($step === null) {
			$step = 1;
		}
		return new thx_RangeIterator($start, $stop, $step);
	}
	static $BASE = "0123456789abcdefghijklmnopqrstuvwxyz";
	static function toString($value, $base) {
		$tmp = null;
		if($base >= 2) {
			$tmp = $base > strlen(thx_Ints::$BASE);
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException("invalid base " . _hx_string_rec($base, "") . ", it must be between 2 and " . _hx_string_rec(strlen(thx_Ints::$BASE), ""));
		}
		$tmp1 = null;
		if($base !== 10) {
			$tmp1 = $value === 0;
		} else {
			$tmp1 = true;
		}
		if($tmp1) {
			return "" . _hx_string_rec($value, "");
		}
		$buf = "";
		$abs = null;
		if($value < 0) {
			$abs = -$value;
		} else {
			$abs = $value;
		}
		while($abs > 0) {
			$tmp2 = _hx_char_at(thx_Ints::$BASE, _hx_mod($abs, $base));
			$buf = _hx_string_or_null($tmp2) . _hx_string_or_null($buf);
			$abs = Std::int($abs / $base);
			unset($tmp2);
		}
		$tmp3 = null;
		if($value < 0) {
			$tmp3 = "-";
		} else {
			$tmp3 = "";
		}
		return _hx_string_or_null($tmp3) . _hx_string_or_null($buf);
	}
	static function toBase($value, $base) {
		return thx_Ints::toString($value, $base);
	}
	static function toBool($v) {
		return $v !== 0;
	}
	static function toInt($s, $base = null) {
		return thx_Ints::parse($s, $base);
	}
	static function sign($value) {
		if($value < 0) {
			return -1;
		} else {
			return 1;
		}
	}
	static function wrapCircular($v, $max) {
		$v = _hx_mod($v, $max);
		$tmp = $v < 0;
		if($tmp) {
			$v += $max;
		}
		return $v;
	}
	static function order() { $args = func_get_args(); return call_user_func_array(self::$order, $args); }
	static $order;
	static $monoid;
	function __toString() { return 'thx.Ints'; }
}
thx_Ints::$pattern_parse = new EReg("^[ \x09\x0D\x0A]*[+-]?(\\d+|0x[0-9A-F]+)", "i");
thx_Ints::$order = array(new _hx_lambda(array(), "thx_Ints_1"), 'execute');
thx_Ints::$monoid = _hx_anonymous(array("zero" => 0, "append" => array(new _hx_lambda(array(), "thx_Ints_2"), 'execute')));
function thx_Ints_0(&$acc, &$base, $c) {
	{
		$i = _hx_index_of(thx_Ints::$BASE, $c, null);
		$tmp6 = null;
		if($i >= 0) {
			$tmp6 = $i >= $base;
		} else {
			$tmp6 = true;
		}
		if($tmp6) {
			throw new HException("invalid");
		}
		$tmp7 = $acc * $base;
		$acc = $tmp7 + $i;
	}
}
function thx_Ints_1($i0, $i1) {
	{
		if($i0 > $i1) {
			return thx_OrderingImpl::$GT;
		} else {
			if($i0 === $i1) {
				return thx_OrderingImpl::$EQ;
			} else {
				return thx_OrderingImpl::$LT;
			}
		}
	}
}
function thx_Ints_2($a, $b) {
	{
		return $a + $b;
	}
}
