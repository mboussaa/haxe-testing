<?php

// Generated by Haxe 3.3.0
class haxe_format_JsonPrinter {
	public function __construct($replacer, $space) {
		if(!php_Boot::$skip_constructor) {
		$this->replacer = $replacer;
		$this->indent = $space;
		$this->pretty = $space !== null;
		$this->nind = 0;
		$this->buf = new StringBuf();
	}}
	public $buf;
	public $replacer;
	public $indent;
	public $pretty;
	public $nind;
	public function write($k, $v) {
		if($this->replacer !== null) {
			$v = $this->replacer($k, $v);
		}
		{
			$_g = Type::typeof($v);
			$tmp = $_g->index;
			switch($tmp) {
			case 0:{
				$this->buf->add("null");
			}break;
			case 1:{
				$this->buf->add($v);
			}break;
			case 2:{
				$v1 = null;
				$tmp1 = Math::isFinite($v);
				if($tmp1) {
					$v1 = $v;
				} else {
					$v1 = "null";
				}
				$this->buf->add($v1);
			}break;
			case 3:{
				$tmp2 = null;
				if($v) {
					$tmp2 = "true";
				} else {
					$tmp2 = "false";
				}
				$this->buf->add($tmp2);
			}break;
			case 4:{
				$tmp3 = Reflect::fields($v);
				$this->fieldsString($v, $tmp3);
			}break;
			case 5:{
				$this->buf->add("\"<fun>\"");
			}break;
			case 6:{
				$c = _hx_deref($_g)->params[0];
				if((is_object($_t = $c) && ($_t instanceof Enum) ? $_t == _hx_qtype("String") : _hx_equal($_t, _hx_qtype("String")))) {
					$this->quote($v);
				} else {
					if((is_object($_t2 = $c) && ($_t2 instanceof Enum) ? $_t2 == _hx_qtype("Array") : _hx_equal($_t2, _hx_qtype("Array")))) {
						$v2 = $v;
						$this->buf->b .= "[";
						$len = $v2->length;
						$last = $len - 1;
						{
							$_g1 = 0;
							$_g2 = $len;
							while($_g1 < $_g2) {
								$i = $_g1++;
								if($i > 0) {
									$this->buf->b .= ",";
								} else {
									$this->nind++;
								}
								$tmp4 = $this->pretty;
								if($tmp4) {
									$this->buf->b .= "\x0A";
								}
								$tmp5 = $this->pretty;
								if($tmp5) {
									$c1 = $this->indent;
									$l = $this->nind * strlen($this->indent);
									$v3 = null;
									$tmp6 = null;
									if(strlen($c1) !== 0) {
										$tmp6 = strlen("") >= $l;
									} else {
										$tmp6 = true;
									}
									if($tmp6) {
										$v3 = "";
									} else {
										$v3 = str_pad("", Math::ceil(($l - strlen("")) / strlen($c1)) * strlen($c1) + strlen(""), $c1, STR_PAD_LEFT);
									}
									$this->buf->add($v3);
									unset($v3,$tmp6,$l,$c1);
								}
								$this->write($i, $v2[$i]);
								if($i === $last) {
									$this->nind--;
									$tmp7 = $this->pretty;
									if($tmp7) {
										$this->buf->b .= "\x0A";
									}
									$tmp8 = $this->pretty;
									if($tmp8) {
										$c2 = $this->indent;
										$l1 = $this->nind * strlen($this->indent);
										$v4 = null;
										$tmp9 = null;
										if(strlen($c2) !== 0) {
											$tmp9 = strlen("") >= $l1;
										} else {
											$tmp9 = true;
										}
										if($tmp9) {
											$v4 = "";
										} else {
											$v4 = str_pad("", Math::ceil(($l1 - strlen("")) / strlen($c2)) * strlen($c2) + strlen(""), $c2, STR_PAD_LEFT);
										}
										$this->buf->add($v4);
										unset($v4,$tmp9,$l1,$c2);
									}
									unset($tmp8,$tmp7);
								}
								unset($tmp5,$tmp4,$i);
							}
						}
						$this->buf->b .= "]";
					} else {
						if((is_object($_t3 = $c) && ($_t3 instanceof Enum) ? $_t3 == _hx_qtype("haxe.ds.StringMap") : _hx_equal($_t3, _hx_qtype("haxe.ds.StringMap")))) {
							$v5 = $v;
							$o = _hx_anonymous(array());
							{
								$tmp10 = $v5->keys();
								while(true) {
									$tmp11 = !$tmp10->hasNext();
									if($tmp11) {
										break;
									}
									$k1 = $tmp10->next();
									$value = $v5->get($k1);
									$o->{$k1} = $value;
									unset($value,$tmp11,$k1);
								}
							}
							$tmp12 = Reflect::fields($o);
							$this->fieldsString($o, $tmp12);
						} else {
							if((is_object($_t4 = $c) && ($_t4 instanceof Enum) ? $_t4 == _hx_qtype("Date") : _hx_equal($_t4, _hx_qtype("Date")))) {
								$v6 = $v;
								$tmp13 = $v6->toString();
								$this->quote($tmp13);
							} else {
								$tmp14 = Reflect::fields($v);
								$this->fieldsString($v, $tmp14);
							}
						}
					}
				}
			}break;
			case 7:{
				$i1 = $v->index;
				$this->buf->add($i1);
			}break;
			case 8:{
				$this->buf->add("\"???\"");
			}break;
			}
		}
	}
	public function fieldsString($v, $fields) {
		$this->buf->b .= "{";
		$len = $fields->length;
		$last = $len - 1;
		$first = true;
		{
			$_g1 = 0;
			$_g = $len;
			while($_g1 < $_g) {
				$i = $_g1++;
				$f = $fields[$i];
				$value = Reflect::field($v, $f);
				$tmp = Reflect::isFunction($value);
				if($tmp) {
					continue;
				}
				if($first) {
					$this->nind++;
					$first = false;
				} else {
					$this->buf->b .= ",";
				}
				$tmp1 = $this->pretty;
				if($tmp1) {
					$this->buf->b .= "\x0A";
				}
				$tmp2 = $this->pretty;
				if($tmp2) {
					$c = $this->indent;
					$l = $this->nind * strlen($this->indent);
					$v1 = null;
					$tmp3 = null;
					if(strlen($c) !== 0) {
						$tmp3 = strlen("") >= $l;
					} else {
						$tmp3 = true;
					}
					if($tmp3) {
						$v1 = "";
					} else {
						$v1 = str_pad("", Math::ceil(($l - strlen("")) / strlen($c)) * strlen($c) + strlen(""), $c, STR_PAD_LEFT);
					}
					$this->buf->add($v1);
					unset($v1,$tmp3,$l,$c);
				}
				$this->quote($f);
				$this->buf->b .= ":";
				$tmp4 = $this->pretty;
				if($tmp4) {
					$this->buf->b .= " ";
				}
				$this->write($f, $value);
				if($i === $last) {
					$this->nind--;
					$tmp5 = $this->pretty;
					if($tmp5) {
						$this->buf->b .= "\x0A";
					}
					$tmp6 = $this->pretty;
					if($tmp6) {
						$c1 = $this->indent;
						$l1 = $this->nind * strlen($this->indent);
						$v2 = null;
						$tmp7 = null;
						if(strlen($c1) !== 0) {
							$tmp7 = strlen("") >= $l1;
						} else {
							$tmp7 = true;
						}
						if($tmp7) {
							$v2 = "";
						} else {
							$v2 = str_pad("", Math::ceil(($l1 - strlen("")) / strlen($c1)) * strlen($c1) + strlen(""), $c1, STR_PAD_LEFT);
						}
						$this->buf->add($v2);
						unset($v2,$tmp7,$l1,$c1);
					}
					unset($tmp6,$tmp5);
				}
				unset($value,$tmp4,$tmp2,$tmp1,$tmp,$i,$f);
			}
		}
		$this->buf->b .= "}";
	}
	public function quote($s) {
		$tmp = strlen($s);
		$tmp1 = haxe_Utf8::length($s);
		if($tmp !== $tmp1) {
			$this->quoteUtf8($s);
			return;
		}
		$this->buf->b .= "\"";
		$i = 0;
		while(true) {
			$index = $i++;
			$c = ord(substr($s,$index,1));
			$tmp2 = ($c === 0);
			if($tmp2) {
				break;
			}
			switch($c) {
			case 8:{
				$this->buf->add("\\b");
			}break;
			case 9:{
				$this->buf->add("\\t");
			}break;
			case 10:{
				$this->buf->add("\\n");
			}break;
			case 12:{
				$this->buf->add("\\f");
			}break;
			case 13:{
				$this->buf->add("\\r");
			}break;
			case 34:{
				$this->buf->add("\\\"");
			}break;
			case 92:{
				$this->buf->add("\\\\");
			}break;
			default:{
				$this->buf->b .= _hx_string_or_null(chr($c));
			}break;
			}
			unset($tmp2,$index,$c);
		}
		$this->buf->b .= "\"";
	}
	public function quoteUtf8($s) {
		$u = new haxe_Utf8(null);
		haxe_Utf8::iter($s, array(new _hx_lambda(array(&$u), "haxe_format_JsonPrinter_0"), 'execute'));
		$this->buf->add("\"");
		$tmp = $u->toString();
		$this->buf->add($tmp);
		$this->buf->add("\"");
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function hprint($o, $replacer = null, $space = null) {
		$printer = new haxe_format_JsonPrinter($replacer, $space);
		$printer->write("", $o);
		return $printer->buf->b;
	}
	function __toString() { return 'haxe.format.JsonPrinter'; }
}
function haxe_format_JsonPrinter_0(&$u, $c) {
	{
		switch($c) {
		case 8:{
			$u->addChar(92);
			$u->addChar(98);
		}break;
		case 9:{
			$u->addChar(92);
			$u->addChar(116);
		}break;
		case 10:{
			$u->addChar(92);
			$u->addChar(110);
		}break;
		case 12:{
			$u->addChar(92);
			$u->addChar(102);
		}break;
		case 13:{
			$u->addChar(92);
			$u->addChar(114);
		}break;
		case 34:case 92:{
			$u->addChar(92);
			$u->addChar($c);
		}break;
		default:{
			$u->addChar($c);
		}break;
		}
	}
}
