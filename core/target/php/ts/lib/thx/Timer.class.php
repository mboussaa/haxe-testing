<?php

// Generated by Haxe 3.3.0
class thx_Timer {
	public function __construct(){}
	static function debounce($callback, $delayms, $leading = null) {
		if($leading === null) {
			$leading = false;
		}
		$cancel = (isset(thx_Functions::$noop) ? thx_Functions::$noop: array("thx_Functions", "noop"));
		$poll = array(new _hx_lambda(array(&$callback, &$cancel, &$delayms), "thx_Timer_0"), 'execute');
		return array(new _hx_lambda(array(&$callback, &$leading, &$poll), "thx_Timer_1"), 'execute');
	}
	static function throttle($callback, $delayms, $leading = null) {
		if($leading === null) {
			$leading = false;
		}
		$waiting = false;
		$poll = array(new _hx_lambda(array(&$callback, &$delayms, &$waiting), "thx_Timer_2"), 'execute');
		return array(new _hx_lambda(array(&$callback, &$leading, &$poll, &$waiting), "thx_Timer_3"), 'execute');
	}
	static $timers;
	static $_id = 0;
	static function repeat($callback, $delayms) {
		throw new HException("platform does not support delays (Timer.repeat)");
	}
	static function delay($callback, $delayms) {
		throw new HException("platform does not support delays (Timer.delay)");
	}
	static function frame($callback) {
		$current = microtime(true) * 1000.0;
		$next = null;
		$listener = array(new _hx_lambda(array(&$callback, &$current, &$next), "thx_Timer_4"), 'execute');
		return thx_Timer::repeat($listener, thx_Timer::$FRAME_RATE);
	}
	static function nextFrame($callback) {
		return thx_Timer::delay($callback, thx_Timer::$FRAME_RATE);
	}
	static $FRAME_RATE;
	static function immediate($callback) {
		return thx_Timer::delay($callback, 0);
	}
	static function clear($id) {
		throw new HException("platform does not support delays (Timer.clear)");
	}
	static function time() {
		return microtime(true) * 1000.0;
	}
	static $_resolution;
	static function resolution() {
		if(null !== thx_Timer::$_resolution) {
			return thx_Timer::$_resolution;
		}
		$start = microtime(true) * 1000.0;
		$end = null;
		$loop = 0.0;
		while(true) {
			++$loop;
			$end = microtime(true) * 1000.0;
			if(!(_hx_equal($end - $start, 0))) {
				break;
			}
		}
		return thx_Timer::$_resolution = $end - $start;
	}
	function __toString() { return 'thx.Timer'; }
}
thx_Timer::$timers = new haxe_ds_IntMap();
thx_Timer::$FRAME_RATE = Math::round(16.6666666666666679);
function thx_Timer_0(&$callback, &$cancel, &$delayms) {
	{
		call_user_func($cancel);
		$cancel = thx_Timer::delay($callback, $delayms);
	}
}
function thx_Timer_1(&$callback, &$leading, &$poll) {
	{
		if($leading) {
			$leading = false;
			call_user_func($callback);
		}
		call_user_func($poll);
	}
}
function thx_Timer_2(&$callback, &$delayms, &$waiting) {
	{
		$waiting = true;
		thx_Timer::delay($callback, $delayms);
	}
}
function thx_Timer_3(&$callback, &$leading, &$poll, &$waiting) {
	{
		if($leading) {
			$leading = false;
			call_user_func($callback);
			return;
		}
		if($waiting) {
			return;
		}
		call_user_func($poll);
	}
}
function thx_Timer_4(&$callback, &$current, &$next) {
	{
		$next = microtime(true) * 1000.0;
		call_user_func_array($callback, array($next - $current));
		$current = $next;
	}
}
