<?php

// Generated by Haxe 3.3.0
class thx_Floats {
	public function __construct(){}
	static $TOLERANCE = 10e-5;
	static $EPSILON = 1e-9;
	static $pattern_parse;
	static function angleDifference($a, $b, $turn = null) {
		if($turn === null) {
			$turn = 360.0;
		}
		$r = _hx_mod(($b - $a), $turn);
		$tmp = $r < 0;
		if($tmp) {
			$r += $turn;
		}
		$tmp1 = $r > $turn / 2;
		if($tmp1) {
			$r -= $turn;
		}
		return $r;
	}
	static function ceilTo($f, $decimals) {
		$p = Math::pow(10, $decimals);
		$tmp = Math::fceil($f * $p);
		return $tmp / $p;
	}
	static function canParse($s) {
		return thx_Floats::$pattern_parse->match($s);
	}
	static function clamp($v, $min, $max) {
		if($v < $min) {
			return $min;
		} else {
			if($v > $max) {
				return $max;
			} else {
				return $v;
			}
		}
	}
	static function clampSym($v, $max) {
		$min = -$max;
		if($v < $min) {
			return $min;
		} else {
			if($v > $max) {
				return $max;
			} else {
				return $v;
			}
		}
	}
	static function compare($a, $b) {
		if($a < $b) {
			return -1;
		} else {
			if($a > $b) {
				return 1;
			} else {
				return 0;
			}
		}
	}
	static function floorTo($f, $decimals) {
		$p = Math::pow(10, $decimals);
		$tmp = Math::ffloor($f * $p);
		return $tmp / $p;
	}
	static function interpolate($f, $a, $b) {
		return ($b - $a) * $f + $a;
	}
	static function interpolateAngle($f, $a, $b, $turn = null) {
		if($turn === null) {
			$turn = 360;
		}
		return thx_Floats::wrapCircular(thx_Floats::interpolate($f, $a, $a + thx_Floats::angleDifference($a, $b, $turn)), $turn);
	}
	static function interpolateAngleWidest($f, $a, $b, $turn = null) {
		if($turn === null) {
			$turn = 360;
		}
		return thx_Floats::wrapCircular(thx_Floats::interpolateAngle($f, $a, $b, $turn) - $turn / 2, $turn);
	}
	static function interpolateAngleCW($f, $a, $b, $turn = null) {
		if($turn === null) {
			$turn = 360;
		}
		$a = thx_Floats::wrapCircular($a, $turn);
		$b = thx_Floats::wrapCircular($b, $turn);
		$tmp = $b < $a;
		if($tmp) {
			$b += $turn;
		}
		return thx_Floats::wrapCircular(thx_Floats::interpolate($f, $a, $b), $turn);
	}
	static function interpolateAngleCCW($f, $a, $b, $turn = null) {
		if($turn === null) {
			$turn = 360;
		}
		$a = thx_Floats::wrapCircular($a, $turn);
		$b = thx_Floats::wrapCircular($b, $turn);
		$tmp = $b > $a;
		if($tmp) {
			$b -= $turn;
		}
		return thx_Floats::wrapCircular(thx_Floats::interpolate($f, $a, $b), $turn);
	}
	static function max($a, $b) {
		if($a > $b) {
			return $a;
		} else {
			return $b;
		}
	}
	static function min($a, $b) {
		if($a < $b) {
			return $a;
		} else {
			return $b;
		}
	}
	static function nearEquals($a, $b, $tollerance = null) {
		if($tollerance === null) {
			$tollerance = 1e-9;
		}
		$tmp = Math::isFinite($a);
		if($tmp) {
			$tmp1 = !Math::isFinite($b);
			if($tmp1) {
				return false;
			}
			$tmp2 = Math::abs($a - $b);
			return $tmp2 <= $tollerance;
		}
		$tmp3 = Math::isNaN($a);
		if($tmp3) {
			return Math::isNaN($b);
		}
		$tmp4 = Math::isNaN($b);
		if($tmp4) {
			return false;
		}
		$tmp5 = !Math::isFinite($b);
		if($tmp5) {
			return (is_object($_t = ($a > 0)) && ($_t instanceof Enum) ? $_t == $b > 0 : _hx_equal($_t, $b > 0));
		}
		return false;
	}
	static function nearEqualAngles($a, $b, $turn = null, $tollerance = null) {
		if($tollerance === null) {
			$tollerance = 1e-9;
		}
		if($turn === null) {
			$turn = 360.0;
		}
		$tmp = Math::abs(thx_Floats::angleDifference($a, $b, $turn));
		return $tmp <= $tollerance;
	}
	static function nearZero($n, $tollerance = null) {
		if($tollerance === null) {
			$tollerance = 1e-9;
		}
		$tmp = Math::abs($n);
		return $tmp <= $tollerance;
	}
	static function normalize($v) {
		if($v < 0) {
			return 0;
		} else {
			if($v > 1) {
				return 1;
			} else {
				return $v;
			}
		}
	}
	static function parse($s) {
		$tmp = _hx_substring($s, 0, 1);
		if($tmp === "+") {
			$s = _hx_substring($s, 1, null);
		}
		return Std::parseFloat($s);
	}
	static function root($base, $index) {
		return Math::pow($base, 1 / $index);
	}
	static function roundTo($f, $decimals) {
		$p = Math::pow(10, $decimals);
		$tmp = Math::fround($f * $p);
		return $tmp / $p;
	}
	static function sign($value) {
		if($value < 0) {
			return -1;
		} else {
			return 1;
		}
	}
	static function toString($v) {
		return "" . _hx_string_rec($v, "");
	}
	static function toFloat($s) {
		return thx_Floats::parse($s);
	}
	static function trunc($value) {
		if($value < 0.0) {
			return Math::ceil($value);
		} else {
			return Math::floor($value);
		}
	}
	static function ftrunc($value) {
		if($value < 0.0) {
			return Math::fceil($value);
		} else {
			return Math::ffloor($value);
		}
	}
	static function wrap($v, $min, $max) {
		$range = $max - $min + 1;
		$tmp = $v < $min;
		if($tmp) {
			$tmp1 = $range * (($min - $v) / $range + 1);
			$v += $tmp1;
		}
		return $min + _hx_mod(($v - $min), $range);
	}
	static function wrapCircular($v, $max) {
		$v = _hx_mod($v, $max);
		$tmp = $v < 0;
		if($tmp) {
			$v += $max;
		}
		return $v;
	}
	static function order() { $args = func_get_args(); return call_user_func_array(self::$order, $args); }
	static $order;
	static $monoid;
	function __toString() { return 'thx.Floats'; }
}
thx_Floats::$pattern_parse = new EReg("^(\\+|-)?\\d+(\\.\\d+)?(e-?\\d+)?\$", "");
thx_Floats::$order = thx__Ord_Ord_Impl_::fromIntComparison((isset(thx_Floats::$compare) ? thx_Floats::$compare: array("thx_Floats", "compare")));
thx_Floats::$monoid = _hx_anonymous(array("zero" => 0.0, "append" => array(new _hx_lambda(array(), "thx_Floats_0"), 'execute')));
function thx_Floats_0($a, $b) {
	{
		return $a + $b;
	}
}
