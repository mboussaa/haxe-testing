<?php

// Generated by Haxe 3.3.0
class thx__BigInt_BigInt_Impl_ {
	public function __construct(){}
	static $zero;
	static $one;
	static $two;
	static $negativeOne;
	static function fromInt($value) {
		return thx_bigint_Bigs::fromInt($value);
	}
	static function fromFloat($value) {
		return thx_bigint_Bigs::fromFloat($value);
	}
	static function fromInt64($value) {
		return thx_bigint_Bigs::fromInt64($value);
	}
	static function fromString($value) {
		return thx_bigint_Bigs::parseBase($value, 10);
	}
	static function fromStringWithBase($value, $base) {
		return thx_bigint_Bigs::parseBase($value, $base);
	}
	static function randomBetween($a, $b) {
		$tmp = null;
		$tmp1 = thx__BigInt_BigInt_Impl_::less($a, $b);
		if($tmp1) {
			$tmp = $a;
		} else {
			$tmp = $b;
		}
		$low = $tmp;
		$tmp2 = null;
		$tmp3 = thx__BigInt_BigInt_Impl_::greater($a, $b);
		if($tmp3) {
			$tmp2 = $a;
		} else {
			$tmp2 = $b;
		}
		$range = $tmp2->subtract($low);
		$that = $range->random();
		return $low->add($that);
	}
	static function compare($a, $b) {
		return $a->compareTo($b);
	}
	static function isZero($this1) {
		return $this1->isZero();
	}
	static function abs($this1) {
		return $this1->abs();
	}
	static function compareTo($this1, $that) {
		return $this1->compareTo($that);
	}
	static function compareToAbs($this1, $that) {
		return $this1->compareToAbs($that);
	}
	static function next($this1) {
		return $this1->next();
	}
	static function prev($this1) {
		return $this1->prev();
	}
	static function square($this1) {
		return $this1->square();
	}
	static function pow($this1, $exp) {
		return $this1->pow($exp);
	}
	static function isEven($this1) {
		return $this1->isEven();
	}
	static function isOdd($this1) {
		return $this1->isOdd();
	}
	static function isNegative($this1) {
		return $this1->sign;
	}
	static function isPositive($this1) {
		$tmp = $this1->compareTo(thx__BigInt_BigInt_Impl_::$zero);
		return $tmp > 0;
	}
	static function isUnit($this1) {
		return $this1->isUnit();
	}
	static function isDivisibleBy($this1, $that) {
		$tmp = $that->isZero();
		if($tmp) {
			return false;
		}
		$tmp1 = $that->isUnit();
		if($tmp1) {
			return true;
		}
		$tmp2 = thx__BigInt_BigInt_Impl_::equals($that, thx__BigInt_BigInt_Impl_::$two);
		if($tmp2) {
			return $this1->isEven();
		}
		$this2 = $this1->modulo($that);
		return $this2->isZero();
	}
	static function isPrime($this1) {
		$n = $this1->abs();
		$nPrev = $n->prev();
		$tmp = $n->isUnit();
		if($tmp) {
			return false;
		}
		$tmp1 = null;
		$tmp2 = null;
		$tmp3 = !thx__BigInt_BigInt_Impl_::equals($n, thx_bigint_Bigs::fromInt(2));
		if($tmp3) {
			$tmp2 = thx__BigInt_BigInt_Impl_::equals($n, thx_bigint_Bigs::fromInt(3));
		} else {
			$tmp2 = true;
		}
		if(!$tmp2) {
			$tmp1 = thx__BigInt_BigInt_Impl_::equals($n, thx_bigint_Bigs::fromInt(5));
		} else {
			$tmp1 = true;
		}
		if($tmp1) {
			return true;
		}
		$tmp4 = null;
		$tmp5 = null;
		$tmp6 = !$n->isEven();
		if($tmp6) {
			$tmp5 = thx__BigInt_BigInt_Impl_::isDivisibleBy($n, thx_bigint_Bigs::fromInt(3));
		} else {
			$tmp5 = true;
		}
		if(!$tmp5) {
			$tmp4 = thx__BigInt_BigInt_Impl_::isDivisibleBy($n, thx_bigint_Bigs::fromInt(5));
		} else {
			$tmp4 = true;
		}
		if($tmp4) {
			return false;
		}
		$tmp7 = thx__BigInt_BigInt_Impl_::less($n, thx_bigint_Bigs::fromInt(25));
		if($tmp7) {
			return true;
		}
		$a = (new _hx_array(array(2, 3, 5, 7, 11, 13, 17, 19)));
		$b = $nPrev;
		$d = null;
		$t = null;
		$x = null;
		while(true) {
			$tmp8 = !$b->isEven();
			if($tmp8) {
				break;
			}
			$that = thx_bigint_Bigs::fromInt(2);
			$b = $b->divide($that);
			unset($tmp8,$that);
		}
		{
			$_g1 = 0;
			$_g = $a->length;
			while($_g1 < $_g) {
				$i = $_g1++;
				$x = thx__BigInt_BigInt_Impl_::modPow(thx_bigint_Bigs::fromInt($a[$i]), $b, $n);
				$tmp9 = null;
				$tmp10 = !thx__BigInt_BigInt_Impl_::equals($x, thx__BigInt_BigInt_Impl_::$one);
				if($tmp10) {
					$tmp9 = thx__BigInt_BigInt_Impl_::equals($x, $nPrev);
				} else {
					$tmp9 = true;
				}
				if($tmp9) {
					continue;
				}
				$t = true;
				$d = $b;
				while(true) {
					$tmp11 = null;
					if($t) {
						$tmp11 = thx__BigInt_BigInt_Impl_::less($d, $nPrev);
					} else {
						$tmp11 = false;
					}
					if(!$tmp11) {
						break;
					}
					$this2 = $x->square();
					$x = $this2->modulo($n);
					$tmp12 = thx__BigInt_BigInt_Impl_::equals($x, $nPrev);
					if($tmp12) {
						$t = false;
					}
					$that1 = thx_bigint_Bigs::fromInt(2);
					$d = $d->multiply($that1);
					unset($tmp12,$tmp11,$this2,$that1);
				}
				if($t) {
					return false;
				}
				unset($tmp9,$tmp10,$i);
			}
		}
		return false;
	}
	static function modPow($this1, $exp, $mod) {
		$tmp = $mod->isZero();
		if($tmp) {
			throw new HException(new thx_Error("Cannot take modPow with modulus 0", null, _hx_anonymous(array("fileName" => "BigInt.hx", "lineNumber" => 126, "className" => "thx._BigInt.BigInt_Impl_", "methodName" => "modPow"))));
		}
		$r = thx_bigint_Small::$one;
		$base = $this1->modulo($mod);
		$tmp1 = $base->isZero();
		if($tmp1) {
			return thx_bigint_Small::$zero;
		}
		while(true) {
			$tmp2 = $exp->compareTo(thx__BigInt_BigInt_Impl_::$zero);
			if(!($tmp2 > 0)) {
				break;
			}
			$tmp3 = $exp->isOdd();
			if($tmp3) {
				$r = $r->multiply($base)->modulo($mod);
			}
			$exp = $exp->divide(thx_bigint_Small::$two);
			$this2 = $base->square();
			$base = $this2->modulo($mod);
			unset($tmp3,$tmp2,$this2);
		}
		return $r;
	}
	static function euclideanModPow($this1, $exp, $mod) {
		$x = thx__BigInt_BigInt_Impl_::modPow($this1, $exp, $mod);
		$tmp = $x->sign;
		if($tmp) {
			return $x->add($mod);
		} else {
			return $x;
		}
	}
	static function max($this1, $that) {
		$tmp = thx__BigInt_BigInt_Impl_::greater($this1, $that);
		if($tmp) {
			return $this1;
		} else {
			return $that;
		}
	}
	static function min($this1, $that) {
		$tmp = thx__BigInt_BigInt_Impl_::less($this1, $that);
		if($tmp) {
			return $this1;
		} else {
			return $that;
		}
	}
	static function gcd($this1, $that) {
		$a = $this1->abs();
		$b = $that->abs();
		$tmp = null;
		$tmp1 = !thx__BigInt_BigInt_Impl_::equals($a, $b);
		if($tmp1) {
			$tmp = $a->isZero();
		} else {
			$tmp = true;
		}
		if($tmp) {
			return $b;
		}
		$tmp2 = $b->isZero();
		if($tmp2) {
			return $a;
		}
		$tmp3 = $a->isEven();
		if($tmp3) {
			$tmp4 = $b->isOdd();
			if($tmp4) {
				return thx__BigInt_BigInt_Impl_::gcd($a->divide(thx_bigint_Small::$two), $b);
			}
			$tmp5 = $a->divide(thx_bigint_Small::$two);
			$this2 = thx__BigInt_BigInt_Impl_::gcd($tmp5, $b->divide(thx_bigint_Small::$two));
			return $this2->multiply(thx_bigint_Small::$two);
		}
		$tmp6 = $b->isEven();
		if($tmp6) {
			return thx__BigInt_BigInt_Impl_::gcd($a, $b->divide(thx_bigint_Small::$two));
		}
		$tmp7 = thx__BigInt_BigInt_Impl_::greater($a, $b);
		if($tmp7) {
			$this3 = $a->subtract($b);
			$tmp8 = $this3->divide(thx_bigint_Small::$two);
			return thx__BigInt_BigInt_Impl_::gcd($tmp8, $b);
		}
		$this4 = $b->subtract($a);
		$tmp9 = $this4->divide(thx_bigint_Small::$two);
		return thx__BigInt_BigInt_Impl_::gcd($tmp9, $a);
	}
	static function lcm($this1, $that) {
		$a = $this1->abs();
		$b = $that->abs();
		$this2 = $a->multiply($b);
		$that1 = thx__BigInt_BigInt_Impl_::gcd($a, $b);
		return $this2->divide($that1);
	}
	static function greaterThan($this1, $that) {
		$tmp = $this1->compareTo($that);
		return $tmp > 0;
	}
	static function greater($self, $that) {
		$tmp = $self->compareTo($that);
		return $tmp > 0;
	}
	static function greaterEqualsTo($this1, $that) {
		$tmp = $this1->compareTo($that);
		return $tmp >= 0;
	}
	static function greaterEquals($self, $that) {
		$tmp = $self->compareTo($that);
		return $tmp >= 0;
	}
	static function lessThan($this1, $that) {
		$tmp = $this1->compareTo($that);
		return $tmp < 0;
	}
	static function less($self, $that) {
		$tmp = $self->compareTo($that);
		return $tmp < 0;
	}
	static function lessEqualsTo($this1, $that) {
		$tmp = $this1->compareTo($that);
		return $tmp <= 0;
	}
	static function lessEquals($self, $that) {
		$tmp = $self->compareTo($that);
		return $tmp <= 0;
	}
	static function equalsTo($this1, $that) {
		$tmp = $this1->compareTo($that);
		return $tmp === 0;
	}
	static function equals($self, $that) {
		$tmp = $self->compareTo($that);
		return $tmp === 0;
	}
	static function notEqualsTo($this1, $that) {
		$tmp = $this1->compareTo($that);
		return $tmp !== 0;
	}
	static function notEquals($self, $that) {
		$tmp = $self->compareTo($that);
		return $tmp !== 0;
	}
	static function add($this1, $that) {
		return $this1->add($that);
	}
	static function subtract($this1, $that) {
		return $this1->subtract($that);
	}
	static function preIncrement($this1) {
		$this1 = $this1->add(thx_bigint_Small::$one);
		return $this1;
	}
	static function postIncrement($this1) {
		$v = $this1;
		$this1 = $this1->add(thx_bigint_Small::$one);
		return $v;
	}
	static function preDecrement($this1) {
		$this1 = $this1->subtract(thx_bigint_Small::$one);
		return $this1;
	}
	static function postDecrement($this1) {
		$v = $this1;
		$this1 = $this1->subtract(thx_bigint_Small::$one);
		return $v;
	}
	static function negate($this1) {
		return $this1->negate();
	}
	static function multiply($this1, $that) {
		return $this1->multiply($that);
	}
	static function divide($this1, $that) {
		return $this1->divide($that);
	}
	static function modulo($this1, $that) {
		return $this1->modulo($that);
	}
	static function shiftLeft($this1, $that) {
		return $this1->shiftLeft($that);
	}
	static function shiftRight($this1, $that) {
		return $this1->shiftRight($that);
	}
	static function not($this1) {
		return $this1->not();
	}
	static function hand($this1, $that) {
		return $this1->hand($that);
	}
	static function hor($this1, $that) {
		return $this1->hor($that);
	}
	static function hxor($this1, $that) {
		return $this1->hxor($that);
	}
	static function divMod($this1, $that) {
		return $this1->divMod($that);
	}
	static function toInt($this1) {
		return $this1->toInt();
	}
	static function toFloat($this1) {
		return $this1->toFloat();
	}
	static function toInt64($this1) {
		return thx_bigint_Bigs::toInt64($this1);
	}
	static function toString($this1) {
		return $this1->toString();
	}
	static function toStringWithBase($this1, $base) {
		return $this1->toStringWithBase($base);
	}
	function __toString() { return 'thx._BigInt.BigInt_Impl_'; }
}
thx__BigInt_BigInt_Impl_::$zero = thx_bigint_Small::$zero;
thx__BigInt_BigInt_Impl_::$one = thx_bigint_Small::$one;
thx__BigInt_BigInt_Impl_::$two = thx_bigint_Small::$two;
thx__BigInt_BigInt_Impl_::$negativeOne = thx_bigint_Small::$negativeOne;
