<?php

// Generated by Haxe 3.3.0
class thx_bigint_Small implements thx_bigint_BigIntImpl{
	public function __construct($value) {
		if(!php_Boot::$skip_constructor) {
		$this->sign = $value < 0;
		$this->value = $value;
		$this->isSmall = true;
	}}
	public $value;
	public $sign;
	public $isSmall;
	public function add($that) {
		$tmp = $this->isZero();
		if($tmp) {
			return $that;
		}
		$tmp1 = $that->isZero();
		if($tmp1) {
			return $this;
		}
		$tmp2 = (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $that->sign : !_hx_equal($_t, $that->sign));
		if($tmp2) {
			$tmp3 = $that->negate();
			return $this->subtract($tmp3);
		}
		$tmp4 = $that->isSmall;
		if($tmp4) {
			return $this->addSmall($that);
		} else {
			return $this->addBig($that);
		}
	}
	public function addSmall($small) {
		$tmp = thx_bigint_Bigs::isPrecise($this->value + $small->value);
		if($tmp) {
			return new thx_bigint_Small($this->value + $small->value);
		} else {
			$v = $small->value;
			$tmp1 = null;
			if($v < 0) {
				$tmp1 = -$v;
			} else {
				$tmp1 = $v;
			}
			$tmp2 = thx_bigint_Bigs::smallToArray($tmp1);
			$v1 = $this->value;
			$tmp3 = null;
			if($v1 < 0) {
				$tmp3 = -$v1;
			} else {
				$tmp3 = $v1;
			}
			$tmp4 = thx_bigint_Bigs::addSmall($tmp2, $tmp3);
			return new thx_bigint_Big($tmp4, $this->sign);
		}
	}
	public function addBig($big) {
		$v = $this->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::addSmall($big->value, $tmp);
		return new thx_bigint_Big($tmp1, $this->sign);
	}
	public function subtract($that) {
		$tmp = $this->isZero();
		if($tmp) {
			return $that->negate();
		}
		$tmp1 = $that->isZero();
		if($tmp1) {
			return $this;
		}
		$tmp2 = (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $that->sign : !_hx_equal($_t, $that->sign));
		if($tmp2) {
			$tmp3 = $that->negate();
			return $this->add($tmp3);
		}
		$tmp4 = $that->isSmall;
		if($tmp4) {
			return $this->subtractSmall($that);
		} else {
			return $this->subtractBig($that);
		}
	}
	public function subtractSmall($small) {
		return new thx_bigint_Small($this->value - $small->value);
	}
	public function subtractBig($big) {
		$tmp = $big->compareToAbsSmall($this);
		if($tmp < 0) {
			$tmp1 = $this->value;
			$tmp2 = $big->toInt();
			return new thx_bigint_Small($tmp1 - $tmp2);
		}
		$v = $this->value;
		$tmp3 = null;
		if($v < 0) {
			$tmp3 = -$v;
		} else {
			$tmp3 = $v;
		}
		$tmp4 = $this->value >= 0;
		return thx_bigint_Bigs::subtractSmall($big->value, $tmp3, $tmp4);
	}
	public function divide($that) {
		return $this->divMod($that)->quotient;
	}
	public function divMod($that) {
		$tmp = $that->isZero();
		if($tmp) {
			throw new HException(new thx_Error("division by zero", null, _hx_anonymous(array("fileName" => "Small.hx", "lineNumber" => 77, "className" => "thx.bigint.Small", "methodName" => "divMod"))));
		}
		$tmp1 = $that->isSmall;
		if($tmp1) {
			return $this->divModSmall($that);
		} else {
			return $this->divModBig($that);
		}
	}
	public function divModSmall($small) {
		$value = $this->value / $small->value;
		$tmp = null;
		if($value < 0.0) {
			$tmp = Math::ceil($value);
		} else {
			$tmp = Math::floor($value);
		}
		$tmp1 = new thx_bigint_Small($tmp);
		return _hx_anonymous(array("quotient" => $tmp1, "remainder" => new thx_bigint_Small(_hx_mod($this->value, $small->value))));
	}
	public function divModBig($big) {
		$v = $this->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::smallToArray($tmp);
		$tmp2 = $this->value < 0;
		return _hx_deref(new thx_bigint_Big($tmp1, $tmp2))->divModBig($big);
	}
	public function multiply($that) {
		$tmp = $that->isSmall;
		if($tmp) {
			return $this->multiplySmall($that);
		} else {
			return $this->multiplyBig($that);
		}
	}
	public function multiplySmall($small) {
		if(thx_bigint_Bigs::isPrecise($this->value * $small->value)) {
			return new thx_bigint_Small($this->value * $small->value);
		}
		$v = $small->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$arr = thx_bigint_Bigs::smallToArray($tmp);
		$v1 = $this->value;
		$abs = null;
		if($v1 < 0) {
			$abs = -$v1;
		} else {
			$abs = $v1;
		}
		if($abs < 10000000) {
			$tmp1 = thx_bigint_Bigs::multiplySmall($arr, $abs);
			return new thx_bigint_Big($tmp1, (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $small->sign : !_hx_equal($_t, $small->sign)));
		} else {
			$tmp2 = thx_bigint_Bigs::smallToArray($abs);
			$tmp3 = thx_bigint_Bigs::multiplyLong($arr, $tmp2);
			return new thx_bigint_Big($tmp3, (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $small->sign : !_hx_equal($_t, $small->sign)));
		}
	}
	public function multiplyBig($big) {
		$v = $this->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::smallToArray($tmp);
		$tmp2 = thx_bigint_Bigs::multiplyLong($big->value, $tmp1);
		return new thx_bigint_Big($tmp2, (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $big->sign : !_hx_equal($_t, $big->sign)));
	}
	public function modulo($that) {
		return $this->divMod($that)->remainder;
	}
	public function random() {
		$tmp = Math::random();
		$tmp1 = $tmp * $this->value;
		$tmp2 = Std::int($tmp1);
		return thx_bigint_Bigs::fromInt($tmp2);
	}
	public function abs() {
		$v = $this->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		return new thx_bigint_Small($tmp);
	}
	public function negate() {
		return new thx_bigint_Small(-$this->value);
	}
	public function next() {
		return $this->addSmall(thx_bigint_Small::$one);
	}
	public function prev() {
		return $this->addSmall(thx_bigint_Small::$negativeOne);
	}
	public function pow($exp) {
		$tmp = $this->isZero();
		if($tmp) {
			$tmp1 = $exp->isZero();
			if($tmp1) {
				return thx_bigint_Small::$one;
			} else {
				return $this;
			}
		}
		$tmp2 = $this->isUnit();
		if($tmp2) {
			$tmp3 = $this->sign;
			if($tmp3) {
				$tmp4 = $exp->isEven();
				if($tmp4) {
					return thx_bigint_Small::$one;
				} else {
					return thx_bigint_Small::$negativeOne;
				}
			} else {
				return thx_bigint_Small::$one;
			}
		}
		if($exp->sign) {
			return thx_bigint_Small::$zero;
		}
		$tmp5 = !$exp->isSmall;
		if($tmp5) {
			$tmp6 = Std::string($exp);
			throw new HException(new thx_Error("The exponent " . _hx_string_or_null($tmp6) . " is too large.", null, _hx_anonymous(array("fileName" => "Small.hx", "lineNumber" => 141, "className" => "thx.bigint.Small", "methodName" => "pow"))));
		}
		$b = $exp->value;
		$tmp7 = thx_bigint_Bigs::canPower($this->value, $b);
		if($tmp7) {
			$tmp8 = Math::pow($this->value, $b);
			$tmp9 = Std::int($tmp8);
			return new thx_bigint_Small($tmp9);
		}
		$v = $this->value;
		$tmp10 = null;
		if($v < 0) {
			$tmp10 = -$v;
		} else {
			$tmp10 = $v;
		}
		$tmp11 = thx_bigint_Bigs::smallToArray($tmp10);
		return _hx_deref(new thx_bigint_Big($tmp11, $this->sign))->pow($exp);
	}
	public function shiftLeft($n) {
		if($n < 0) {
			return $this->shiftRight(-$n);
		}
		$tmp = null;
		if($n < 0) {
			$tmp = -$n;
		} else {
			$tmp = $n;
		}
		if($tmp > 10000000) {
			$tmp1 = thx_bigint_Bigs::fromInt($n);
			$tmp2 = thx_bigint_Small::$two->pow($tmp1);
			return $this->multiply($tmp2);
		}
		$result = $this;
		while($n >= thx_bigint_Bigs::$powers2Length) {
			$result = $result->multiply(thx_bigint_Bigs::$bigHighestPower2);
			$n -= thx_bigint_Bigs::$powers2Length - 1;
		}
		return $result->multiply(thx_bigint_Bigs::$bigPowersOfTwo[$n]);
	}
	public function shiftRight($n) {
		if($n < 0) {
			return $this->shiftLeft(-$n);
		}
		$remQuo = null;
		$tmp = null;
		if($n < 0) {
			$tmp = -$n;
		} else {
			$tmp = $n;
		}
		if($tmp > 10000000) {
			$tmp1 = thx_bigint_Bigs::fromInt($n);
			$tmp2 = thx_bigint_Small::$two->pow($tmp1);
			$remQuo = $this->divMod($tmp2);
			$tmp3 = $remQuo->remainder->sign;
			if($tmp3) {
				return $remQuo->quotient->prev();
			} else {
				return $remQuo->quotient;
			}
		}
		$result = $this;
		while($n >= thx_bigint_Bigs::$powers2Length) {
			$tmp4 = $result->isZero();
			if($tmp4) {
				return $result;
			}
			$remQuo = $result->divMod(thx_bigint_Bigs::$bigHighestPower2);
			$tmp5 = $remQuo->remainder->sign;
			if($tmp5) {
				$result = $remQuo->quotient->prev();
			} else {
				$result = $remQuo->quotient;
			}
			$n -= thx_bigint_Bigs::$powers2Length - 1;
			unset($tmp5,$tmp4);
		}
		$remQuo = $result->divMod(thx_bigint_Bigs::$bigPowersOfTwo[$n]);
		$tmp6 = $remQuo->remainder->sign;
		if($tmp6) {
			return $remQuo->quotient->prev();
		} else {
			return $remQuo->quotient;
		}
	}
	public function square() {
		if(thx_bigint_Bigs::isPrecise($this->value * $this->value)) {
			return new thx_bigint_Small($this->value * $this->value);
		}
		$v = $this->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::smallToArray($tmp);
		$tmp2 = thx_bigint_Bigs::square($tmp1);
		return new thx_bigint_Big($tmp2, false);
	}
	public function isEven() {
		return ($this->value & 1) === 0;
	}
	public function isOdd() {
		return ($this->value & 1) === 1;
	}
	public function isZero() {
		return $this->value === 0;
	}
	public function isUnit() {
		$v = $this->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		return $tmp === 1;
	}
	public function compareTo($that) {
		if((is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $that->sign : !_hx_equal($_t, $that->sign))) {
			if($this->sign) {
				return -1;
			} else {
				return 1;
			}
		}
		$tmp = $that->isSmall;
		if($tmp) {
			return $this->compareToSmall($that);
		} else {
			return $this->compareToBig($that);
		}
	}
	public function compareToSmall($small) {
		return $this->value - $small->value;
	}
	public function compareToBig($big) {
		$v = $this->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::smallToArray($tmp);
		$tmp2 = thx_bigint_Bigs::compareToAbs($tmp1, $big->value);
		$tmp3 = null;
		if($this->sign) {
			$tmp3 = -1;
		} else {
			$tmp3 = 1;
		}
		return $tmp2 * $tmp3;
	}
	public function compareToAbs($that) {
		$tmp = $that->isSmall;
		if($tmp) {
			return $this->compareToAbsSmall($that);
		} else {
			return $this->compareToAbsBig($that);
		}
	}
	public function compareToAbsSmall($small) {
		$v = $this->value;
		$a = null;
		if($v < 0) {
			$a = -$v;
		} else {
			$a = $v;
		}
		$v1 = $small->value;
		$b = null;
		if($v1 < 0) {
			$b = -$v1;
		} else {
			$b = $v1;
		}
		return $a - $b;
	}
	public function compareToAbsBig($big) {
		$v = $this->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::smallToArray($tmp);
		return thx_bigint_Bigs::compareToAbs($tmp1, $big->value);
	}
	public function not() {
		return $this->negate()->prev();
	}
	public function hand($that) {
		return thx_bigint_Bigs::bitwise($this, $that, array(new _hx_lambda(array(), "thx_bigint_Small_0"), 'execute'));
	}
	public function hor($that) {
		return thx_bigint_Bigs::bitwise($this, $that, array(new _hx_lambda(array(), "thx_bigint_Small_1"), 'execute'));
	}
	public function hxor($that) {
		return thx_bigint_Bigs::bitwise($this, $that, array(new _hx_lambda(array(), "thx_bigint_Small_2"), 'execute'));
	}
	public function toFloat() {
		return $this->value;
	}
	public function toInt() {
		return $this->value;
	}
	public function toString() {
		return "" . _hx_string_rec($this->value, "");
	}
	public function toStringWithBase($base) {
		return thx_Ints::toString($this->value, $base);
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $zero;
	static $one;
	static $two;
	static $ten;
	static $negativeOne;
	function __toString() { return $this->toString(); }
}
thx_bigint_Small::$zero = new thx_bigint_Small(0);
thx_bigint_Small::$one = new thx_bigint_Small(1);
thx_bigint_Small::$two = new thx_bigint_Small(2);
thx_bigint_Small::$ten = new thx_bigint_Small(10);
thx_bigint_Small::$negativeOne = new thx_bigint_Small(-1);
function thx_bigint_Small_0($a, $b) {
	{
		return $a & $b;
	}
}
function thx_bigint_Small_1($a, $b) {
	{
		return $a | $b;
	}
}
function thx_bigint_Small_2($a, $b) {
	{
		return $a ^ $b;
	}
}
