<?php

// Generated by Haxe 3.3.0
class thx__HashSet_HashSet_Impl_ {
	public function __construct(){}
	static function _new($map) {
		return $map;
	}
	static function create($arr = null) {
		$this1 = new haxe_ds__HashMap_HashMapData();
		$hashSet = $this1;
		if(null !== $arr) {
			thx__HashSet_HashSet_Impl_::pushMany($hashSet, $arr);
		}
		return $hashSet;
	}
	static function add($this1, $v) {
		$tmp = $v->hashCode();
		$tmp1 = $this1->values->exists($tmp);
		if($tmp1) {
			return false;
		} else {
			{
				$tmp2 = $v->hashCode();
				$this1->keys->set($tmp2, $v);
				$tmp3 = $v->hashCode();
				$this1->values->set($tmp3, true);
			}
			return true;
		}
	}
	static function copy($this1) {
		$inst = thx__HashSet_HashSet_Impl_::hempty($this1);
		{
			$tmp = $this1->keys->iterator();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$k = $tmp->next();
				$tmp2 = $k->hashCode();
				$inst->keys->set($tmp2, $k);
				$tmp3 = $k->hashCode();
				$inst->values->set($tmp3, true);
				unset($tmp3,$tmp2,$tmp1,$k);
			}
		}
		return $inst;
	}
	static function hempty($this1) {
		$tmp = Type::getClass($this1);
		$map = Type::createInstance($tmp, (new _hx_array(array())));
		return $map;
	}
	static function difference($this1, $set) {
		$result = thx__HashSet_HashSet_Impl_::copy($this1);
		{
			$tmp = thx__HashSet_HashSet_Impl_::iterator($set);
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$item = $tmp->next();
				$tmp2 = $item->hashCode();
				$result->values->remove($tmp2);
				$tmp3 = $item->hashCode();
				$result->keys->remove($tmp3);
				unset($tmp3,$tmp2,$tmp1,$item);
			}
		}
		return $result;
	}
	static function symmetricDifference($this1, $set) {
		$self = thx__HashSet_HashSet_Impl_::copy($this1);
		$newset = thx__HashSet_HashSet_Impl_::copy($self);
		{
			$tmp = thx__HashSet_HashSet_Impl_::iterator($set);
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$k = $tmp->next();
				$tmp2 = $k->hashCode();
				$newset->keys->set($tmp2, $k);
				$tmp3 = $k->hashCode();
				$newset->values->set($tmp3, true);
				unset($tmp3,$tmp2,$tmp1,$k);
			}
		}
		$this2 = $newset;
		$result = thx__HashSet_HashSet_Impl_::hempty($self);
		{
			$tmp4 = thx__HashSet_HashSet_Impl_::iterator($self);
			while(true) {
				$tmp5 = !$tmp4->hasNext();
				if($tmp5) {
					break;
				}
				$item = $tmp4->next();
				$tmp6 = $item->hashCode();
				$tmp7 = $set->values->exists($tmp6);
				if($tmp7) {
					$tmp8 = $item->hashCode();
					$result->keys->set($tmp8, $item);
					$tmp9 = $item->hashCode();
					$result->values->set($tmp9, true);
					unset($tmp9,$tmp8);
				}
				unset($tmp7,$tmp6,$tmp5,$item);
			}
		}
		$result1 = thx__HashSet_HashSet_Impl_::copy($this2);
		{
			$tmp10 = thx__HashSet_HashSet_Impl_::iterator($result);
			while(true) {
				$tmp11 = !$tmp10->hasNext();
				if($tmp11) {
					break;
				}
				$item1 = $tmp10->next();
				$tmp12 = $item1->hashCode();
				$result1->values->remove($tmp12);
				$tmp13 = $item1->hashCode();
				$result1->keys->remove($tmp13);
				unset($tmp13,$tmp12,$tmp11,$item1);
			}
		}
		return $result1;
	}
	static function exists($this1, $v) {
		$tmp = $v->hashCode();
		return $this1->values->exists($tmp);
	}
	static function remove($this1, $v) {
		$tmp = $v->hashCode();
		$this1->values->remove($tmp);
		$tmp1 = $v->hashCode();
		return $this1->keys->remove($tmp1);
	}
	static function intersection($this1, $set) {
		$result = thx__HashSet_HashSet_Impl_::hempty($this1);
		{
			$tmp = thx__HashSet_HashSet_Impl_::iterator($this1);
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$item = $tmp->next();
				$tmp2 = $item->hashCode();
				$tmp3 = $set->values->exists($tmp2);
				if($tmp3) {
					$tmp4 = $item->hashCode();
					$result->keys->set($tmp4, $item);
					$tmp5 = $item->hashCode();
					$result->values->set($tmp5, true);
					unset($tmp5,$tmp4);
				}
				unset($tmp3,$tmp2,$tmp1,$item);
			}
		}
		return $result;
	}
	static function push($this1, $v) {
		$tmp = $v->hashCode();
		$this1->keys->set($tmp, $v);
		$tmp1 = $v->hashCode();
		$this1->values->set($tmp1, true);
	}
	static function pushMany($this1, $values) {
		$tmp = $values->iterator();
		while(true) {
			$tmp1 = !$tmp->hasNext();
			if($tmp1) {
				break;
			}
			$value = $tmp->next();
			$tmp2 = $value->hashCode();
			$this1->keys->set($tmp2, $value);
			$tmp3 = $value->hashCode();
			$this1->values->set($tmp3, true);
			unset($value,$tmp3,$tmp2,$tmp1);
		}
	}
	static function iterator($this1) {
		return $this1->keys->iterator();
	}
	static function union($this1, $set) {
		$newset = thx__HashSet_HashSet_Impl_::copy($this1);
		{
			$tmp = thx__HashSet_HashSet_Impl_::iterator($set);
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$k = $tmp->next();
				$tmp2 = $k->hashCode();
				$newset->keys->set($tmp2, $k);
				$tmp3 = $k->hashCode();
				$newset->values->set($tmp3, true);
				unset($tmp3,$tmp2,$tmp1,$k);
			}
		}
		return $newset;
	}
	static function toArray($this1) {
		$arr = (new _hx_array(array()));
		{
			$tmp = $this1->keys->iterator();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$k = $tmp->next();
				$arr->push($k);
				unset($tmp1,$k);
			}
		}
		return $arr;
	}
	static function toString($this1) {
		$tmp = thx__HashSet_HashSet_Impl_::toArray($this1)->join(", ");
		return "{" . _hx_string_or_null($tmp) . "}";
	}
	static function get_length($this1) {
		$l = 0;
		{
			$tmp = $this1->values->iterator();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$tmp->next();
				++$l;
				unset($tmp1);
			}
		}
		return $l;
	}
	static $__properties__ = array("get_length" => "get_length");
	function __toString() { return 'thx._HashSet.HashSet_Impl_'; }
}
