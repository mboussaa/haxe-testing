<?php

// Generated by Haxe 3.3.0
class utest_ui_text_PlainTextReport implements utest_ui_common_IReport{
	public function __construct($runner, $outputHandler = null) {
		if(!php_Boot::$skip_constructor) {
		$this->aggregator = new utest_ui_common_ResultAggregator($runner, true);
		$runner->onStart->add((isset($this->start) ? $this->start: array($this, "start")));
		$this->aggregator->onComplete->add((isset($this->complete) ? $this->complete: array($this, "complete")));
		if(null !== $outputHandler) {
			$this->setHandler($outputHandler);
		}
		$this->displaySuccessResults = utest_ui_common_SuccessResultsDisplayMode::$AlwaysShowSuccessResults;
		$this->displayHeader = utest_ui_common_HeaderDisplayMode::$AlwaysShowHeader;
	}}
	public $displaySuccessResults;
	public $displayHeader;
	public $handler;
	public $aggregator;
	public $newline;
	public $indent;
	public function setHandler($handler) {
		$this->handler = $handler;
	}
	public $startTime;
	public function start($e) {
		$this->startTime = $this->getTime();
	}
	public function getTime() {
		return haxe_Timer::stamp();
	}
	public function indents($c) {
		$s = "";
		{
			$_g1 = 0;
			while($_g1 < $c) {
				++$_g1;
				$s .= _hx_string_or_null($this->indent);
			}
		}
		return $s;
	}
	public function dumpStack($stack) {
		if($stack->length === 0) {
			return "";
		}
		$parts = _hx_explode("\x0A", haxe_CallStack::toString($stack));
		$r = (new _hx_array(array()));
		{
			$_g = 0;
			while($_g < $parts->length) {
				$part = $parts[$_g];
				++$_g;
				$tmp = _hx_index_of($part, " utest.", null);
				if($tmp >= 0) {
					continue;
				}
				$r->push($part);
				unset($tmp,$part);
			}
		}
		return $r->join($this->newline);
	}
	public function addHeader($buf, $result) {
		if(!utest_ui_common_ReportTools::hasHeader($this, $result->stats)) {
			return;
		}
		$end = $this->getTime();
		$tmp = Sys::cpuTime();
		$tmp1 = Std::int($tmp * 1000);
		$scripttime = $tmp1 / 1000;
		$tmp2 = ($end - $this->startTime) * 1000;
		$tmp3 = Std::int($tmp2);
		$time = $tmp3 / 1000;
		$tmp4 = "\x0Aassertations: " . _hx_string_rec($result->stats->assertations, "") . _hx_string_or_null($this->newline);
		$buf->add($tmp4);
		$tmp5 = "successes: " . _hx_string_rec($result->stats->successes, "") . _hx_string_or_null($this->newline);
		$buf->add($tmp5);
		$tmp6 = "errors: " . _hx_string_rec($result->stats->errors, "") . _hx_string_or_null($this->newline);
		$buf->add($tmp6);
		$tmp7 = "failures: " . _hx_string_rec($result->stats->failures, "") . _hx_string_or_null($this->newline);
		$buf->add($tmp7);
		$tmp8 = "warnings: " . _hx_string_rec($result->stats->warnings, "") . _hx_string_or_null($this->newline);
		$buf->add($tmp8);
		$buf->add("execution time: " . _hx_string_rec($time, "") . _hx_string_or_null($this->newline));
		$buf->add("script time: " . _hx_string_rec($scripttime, "") . _hx_string_or_null($this->newline));
		$buf->add($this->newline);
		$tmp9 = null;
		if($result->stats->isOk) {
			$tmp9 = "ALL TESTS OK (success: true)";
		} else {
			$tmp9 = "SOME TESTS FAILURES (success: false)";
		}
		$buf->add("results: " . _hx_string_or_null($tmp9));
		$buf->add($this->newline);
	}
	public $result;
	public function getResults() {
		$buf = new StringBuf();
		$this->addHeader($buf, $this->result);
		{
			$_g = 0;
			$_g1 = $this->result->packageNames(null);
			while($_g < $_g1->length) {
				$pname = $_g1[$_g];
				++$_g;
				$pack = $this->result->getPackage($pname);
				if(utest_ui_common_ReportTools::skipResult($this, $pack->stats, $this->result->stats->isOk)) {
					continue;
				}
				{
					$_g2 = 0;
					$_g3 = $pack->classNames(null);
					while($_g2 < $_g3->length) {
						$cname = $_g3[$_g2];
						++$_g2;
						$cls = $pack->getClass($cname);
						if(utest_ui_common_ReportTools::skipResult($this, $cls->stats, $this->result->stats->isOk)) {
							continue;
						}
						$tmp = null;
						if($pname === "") {
							$tmp = "";
						} else {
							$tmp = _hx_string_or_null($pname) . ".";
						}
						$buf->add(_hx_string_or_null($tmp) . _hx_string_or_null($cname) . _hx_string_or_null($this->newline));
						{
							$_g4 = 0;
							$_g5 = $cls->methodNames(null);
							while($_g4 < $_g5->length) {
								$mname = $_g5[$_g4];
								++$_g4;
								$fix = $cls->get($mname);
								if(utest_ui_common_ReportTools::skipResult($this, $fix->stats, $this->result->stats->isOk)) {
									continue;
								}
								$tmp1 = $this->indents(1);
								$buf->add(_hx_string_or_null($tmp1) . _hx_string_or_null($mname) . ": ");
								$tmp2 = $fix->stats->isOk;
								if($tmp2) {
									$buf->add("OK ");
								} else {
									$tmp3 = $fix->stats->hasErrors;
									if($tmp3) {
										$buf->add("ERROR ");
									} else {
										$tmp4 = $fix->stats->hasFailures;
										if($tmp4) {
											$buf->add("FAILURE ");
										} else {
											$tmp5 = $fix->stats->hasWarnings;
											if($tmp5) {
												$buf->add("WARNING ");
											}
											unset($tmp5);
										}
										unset($tmp4);
									}
									unset($tmp3);
								}
								$messages = "";
								{
									$tmp6 = $fix->iterator();
									while(true) {
										$tmp7 = !$tmp6->hasNext();
										if($tmp7) {
											break;
										}
										$assertation = $tmp6->next();
										$tmp8 = $assertation->index;
										switch($tmp8) {
										case 0:{
											$buf->add(".");
										}break;
										case 1:{
											$buf->add("F");
											$tmp9 = $this->indents(2);
											$messages .= _hx_string_or_null($tmp9) . "line: " . _hx_string_rec(_hx_deref($assertation)->params[1]->lineNumber, "") . ", " . _hx_string_or_null(_hx_deref($assertation)->params[0]) . _hx_string_or_null($this->newline);
										}break;
										case 2:{
											$buf->add("E");
											$tmp10 = $this->indents(2);
											$tmp11 = Std::string(_hx_deref($assertation)->params[0]);
											$tmp12 = _hx_string_or_null($tmp10) . _hx_string_or_null($tmp11);
											$tmp13 = $this->dumpStack(_hx_deref($assertation)->params[1]);
											$messages .= _hx_string_or_null($tmp12) . _hx_string_or_null($tmp13) . _hx_string_or_null($this->newline);
										}break;
										case 3:{
											$buf->add("S");
											$tmp14 = $this->indents(2);
											$tmp15 = Std::string(_hx_deref($assertation)->params[0]);
											$tmp16 = _hx_string_or_null($tmp14) . _hx_string_or_null($tmp15);
											$tmp17 = $this->dumpStack(_hx_deref($assertation)->params[1]);
											$messages .= _hx_string_or_null($tmp16) . _hx_string_or_null($tmp17) . _hx_string_or_null($this->newline);
										}break;
										case 4:{
											$buf->add("T");
											$tmp18 = $this->indents(2);
											$tmp19 = Std::string(_hx_deref($assertation)->params[0]);
											$tmp20 = _hx_string_or_null($tmp18) . _hx_string_or_null($tmp19);
											$tmp21 = $this->dumpStack(_hx_deref($assertation)->params[1]);
											$messages .= _hx_string_or_null($tmp20) . _hx_string_or_null($tmp21) . _hx_string_or_null($this->newline);
										}break;
										case 5:{
											$buf->add("O");
											$tmp22 = $this->indents(2);
											$tmp23 = _hx_string_or_null($tmp22) . "missed async calls: " . _hx_string_rec(_hx_deref($assertation)->params[0], "");
											$tmp24 = $this->dumpStack(_hx_deref($assertation)->params[1]);
											$messages .= _hx_string_or_null($tmp23) . _hx_string_or_null($tmp24) . _hx_string_or_null($this->newline);
										}break;
										case 6:{
											$buf->add("A");
											$tmp25 = $this->indents(2);
											$tmp26 = Std::string(_hx_deref($assertation)->params[0]);
											$tmp27 = _hx_string_or_null($tmp25) . _hx_string_or_null($tmp26);
											$tmp28 = $this->dumpStack(_hx_deref($assertation)->params[1]);
											$messages .= _hx_string_or_null($tmp27) . _hx_string_or_null($tmp28) . _hx_string_or_null($this->newline);
										}break;
										case 7:{
											$buf->add("W");
											$tmp29 = $this->indents(2);
											$messages .= _hx_string_or_null($tmp29) . _hx_string_or_null(_hx_deref($assertation)->params[0]) . _hx_string_or_null($this->newline);
										}break;
										}
										unset($tmp8,$tmp7,$assertation);
									}
									unset($tmp6);
								}
								$buf->add($this->newline);
								$buf->add($messages);
								unset($tmp2,$tmp1,$mname,$messages,$fix);
							}
							unset($_g5,$_g4);
						}
						unset($tmp,$cname,$cls);
					}
					unset($_g3,$_g2);
				}
				unset($pname,$pack);
			}
		}
		return $buf->b;
	}
	public function complete($result) {
		$this->result = $result;
		$this->handler($this);
		$tmp = null;
		if($result->stats->isOk) {
			$tmp = 0;
		} else {
			$tmp = 1;
		}
		Sys::hexit($tmp);
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'utest.ui.text.PlainTextReport'; }
}
