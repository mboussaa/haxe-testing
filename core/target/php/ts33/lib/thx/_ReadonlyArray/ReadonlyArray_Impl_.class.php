<?php

// Generated by Haxe 3.3.0
class thx__ReadonlyArray_ReadonlyArray_Impl_ {
	public function __construct(){}
	static function hempty() {
		return (new _hx_array(array()));
	}
	static function flatten($array) {
		return thx_Arrays::reduce($array, array(new _hx_lambda(array(), "thx__ReadonlyArray_ReadonlyArray_Impl__0"), 'execute'), (new _hx_array(array())));
	}
	static function indexOf($this1, $el, $eq = null) {
		$tmp = null === $eq;
		if($tmp) {
			$eq = (isset(thx_Functions::$equality) ? thx_Functions::$equality: array("thx_Functions", "equality"));
		}
		{
			$_g1 = 0;
			$_g = $this1->length;
			while($_g1 < $_g) {
				$i = $_g1++;
				$tmp1 = call_user_func_array($eq, array($el, $this1[$i]));
				if($tmp1) {
					return $i;
				}
				unset($tmp1,$i);
			}
		}
		return -1;
	}
	static function lastIndexOf($this1, $el, $eq = null) {
		$tmp = null === $eq;
		if($tmp) {
			$eq = (isset(thx_Functions::$equality) ? thx_Functions::$equality: array("thx_Functions", "equality"));
		}
		$len = $this1->length;
		{
			$_g1 = 0;
			while($_g1 < $len) {
				$i = $_g1++;
				$tmp1 = call_user_func_array($eq, array($el, $this1[$len - $i - 1]));
				if($tmp1) {
					return $i;
				}
				unset($tmp1,$i);
			}
		}
		return -1;
	}
	static function get($this1, $index) {
		return $this1[$index];
	}
	static function head($this1) {
		return $this1[0];
	}
	static function tail($this1) {
		return $this1->slice(1, null);
	}
	static function reduce($this1, $arr, $f, $initial) {
		{
			$_g = 0;
			while($_g < $arr->length) {
				$v = $arr[$_g];
				++$_g;
				$initial = call_user_func_array($f, array($initial, $v));
				unset($v);
			}
		}
		return $initial;
	}
	static function reducei($array, $f, $initial) {
		{
			$_g1 = 0;
			$_g = $array->length;
			while($_g1 < $_g) {
				$i = $_g1++;
				$initial = call_user_func_array($f, array($initial, $array[$i], $i));
				unset($i);
			}
		}
		return $initial;
	}
	static function reverse($this1) {
		$arr = $this1->copy();
		$arr->reverse();
		return $arr;
	}
	static function toArray($this1) {
		return $this1->copy();
	}
	static function unsafe($this1) {
		return $this1;
	}
	static function concat($this1, $that) {
		return $this1->concat($that);
	}
	static function insertAt($this1, $pos, $el) {
		$tmp = $this1->slice(0, $pos)->concat((new _hx_array(array($el))));
		$tmp1 = $this1->slice($pos, null);
		return $tmp->concat($tmp1);
	}
	static function insertAfter($this1, $ref, $el, $eq = null) {
		$pos = thx__ReadonlyArray_ReadonlyArray_Impl_::indexOf($this1, $ref, $eq);
		$tmp = $pos < 0;
		if($tmp) {
			$pos = $this1->length - 1;
		}
		$pos1 = $pos + 1;
		$tmp1 = $this1->slice(0, $pos1)->concat((new _hx_array(array($el))));
		$tmp2 = $this1->slice($pos1, null);
		return $tmp1->concat($tmp2);
	}
	static function insertBefore($this1, $ref, $el, $eq = null) {
		$pos = thx__ReadonlyArray_ReadonlyArray_Impl_::indexOf($this1, $ref, $eq);
		$tmp = $this1->slice(0, $pos)->concat((new _hx_array(array($el))));
		$tmp1 = $this1->slice($pos, null);
		return $tmp->concat($tmp1);
	}
	static function replace($this1, $ref, $el, $eq = null) {
		$pos = thx__ReadonlyArray_ReadonlyArray_Impl_::indexOf($this1, $ref, $eq);
		if($pos < 0) {
			throw new HException(new thx_Error("unable to find reference element", null, _hx_anonymous(array("fileName" => "ReadonlyArray.hx", "lineNumber" => 91, "className" => "thx._ReadonlyArray.ReadonlyArray_Impl_", "methodName" => "replace"))));
		}
		$tmp = $this1->slice(0, $pos)->concat((new _hx_array(array($el))));
		$tmp1 = $this1->slice($pos + 1, null);
		return $tmp->concat($tmp1);
	}
	static function replaceAt($this1, $pos, $el) {
		$tmp = $this1->slice(0, $pos)->concat((new _hx_array(array($el))));
		$tmp1 = $this1->slice($pos + 1, null);
		return $tmp->concat($tmp1);
	}
	static function remove($this1, $el, $eq = null) {
		$pos = thx__ReadonlyArray_ReadonlyArray_Impl_::indexOf($this1, $el, $eq);
		$tmp = $this1->slice(0, $pos);
		$tmp1 = $this1->slice($pos + 1, null);
		return $tmp->concat($tmp1);
	}
	static function removeAt($this1, $pos) {
		$tmp = $this1->slice(0, $pos);
		$tmp1 = $this1->slice($pos + 1, null);
		return $tmp->concat($tmp1);
	}
	static function prepend($this1, $el) {
		return _hx_deref((new _hx_array(array($el))))->concat($this1);
	}
	static function append($this1, $el) {
		return $this1->concat((new _hx_array(array($el))));
	}
	static function unshift($this1, $el) {
		return _hx_deref((new _hx_array(array($el))))->concat($this1);
	}
	static function shift($this1) {
		if($this1->length === 0) {
			return _hx_anonymous(array("_0" => null, "_1" => $this1));
		}
		$value = $this1[0];
		$tmp = $this1->slice(0, 0);
		$tmp1 = $this1->slice(1, null);
		$array = $tmp->concat($tmp1);
		return _hx_anonymous(array("_0" => $value, "_1" => $array));
	}
	static function push($this1, $el) {
		return $this1->concat((new _hx_array(array($el))));
	}
	static function pop($this1) {
		if($this1->length === 0) {
			return _hx_anonymous(array("_0" => null, "_1" => $this1));
		}
		$value = $this1[$this1->length - 1];
		$pos = $this1->length - 1;
		$tmp = $this1->slice(0, $pos);
		$tmp1 = $this1->slice($pos + 1, null);
		$array = $tmp->concat($tmp1);
		return _hx_anonymous(array("_0" => $value, "_1" => $array));
	}
	function __toString() { return 'thx._ReadonlyArray.ReadonlyArray_Impl_'; }
}
function thx__ReadonlyArray_ReadonlyArray_Impl__0($acc, $element) {
	{
		return $acc->concat($element);
	}
}
