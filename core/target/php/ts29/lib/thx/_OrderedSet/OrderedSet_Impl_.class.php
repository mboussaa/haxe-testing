<?php

// Generated by Haxe 3.3.0
class thx__OrderedSet_OrderedSet_Impl_ {
	public function __construct(){}
	static function toOrderedSet($arr) {
		$set = (new _hx_array(array()));
		{
			$_g = 0;
			while($_g < $arr->length) {
				$v = $arr[$_g];
				++$_g;
				thx__OrderedSet_OrderedSet_Impl_::push($set, $v);
				unset($v);
			}
		}
		return $set;
	}
	static function arrayToOrderedSet($arr) {
		return thx__OrderedSet_OrderedSet_Impl_::toOrderedSet($arr);
	}
	static function create($arr = null) {
		if(null === $arr) {
			return (new _hx_array(array()));
		} else {
			return thx__OrderedSet_OrderedSet_Impl_::toOrderedSet($arr);
		}
	}
	static function _new($arr) {
		return $arr;
	}
	static function add($this1, $v) {
		if(thx__OrderedSet_OrderedSet_Impl_::exists($this1, $v)) {
			return false;
		} else {
			$this1->push($v);
			return true;
		}
	}
	static function copy($this1) {
		$arr = $this1->copy();
		return $arr;
	}
	static function difference($this1, $set) {
		$result = $this1->copy();
		{
			$tmp = $set->iterator();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$item = $tmp->next();
				$result->remove($item);
				unset($tmp1,$item);
			}
		}
		return $result;
	}
	static function exists($this1, $v) {
		{
			$_g = 0;
			while($_g < $this1->length) {
				$t = $this1[$_g];
				++$_g;
				if((is_object($_t = $t) && ($_t instanceof Enum) ? $_t == $v : _hx_equal($_t, $v))) {
					return true;
				}
				unset($t,$_t);
			}
		}
		return false;
	}
	static function get($this1, $index) {
		return $this1[$index];
	}
	static function intersection($this1, $set) {
		$result = (new _hx_array(array()));
		{
			$_g = 0;
			while($_g < $this1->length) {
				$item = $this1[$_g];
				++$_g;
				if(thx__OrderedSet_OrderedSet_Impl_::exists($set, $item)) {
					$result->push($item);
				}
				unset($item);
			}
		}
		return $result;
	}
	static function push($this1, $v) {
		thx__OrderedSet_OrderedSet_Impl_::add($this1, $v);
	}
	static function pushMany($this1, $values) {
		$tmp = $values->iterator();
		while(true) {
			$tmp1 = !$tmp->hasNext();
			if($tmp1) {
				break;
			}
			$value = $tmp->next();
			thx__OrderedSet_OrderedSet_Impl_::push($this1, $value);
			unset($value,$tmp1);
		}
	}
	static function slice($this1, $pos, $end = null) {
		$arr = $this1->slice($pos, $end);
		return $arr;
	}
	static function splice($this1, $pos, $len) {
		$arr = $this1->splice($pos, $len);
		return $arr;
	}
	static function union($this1, $set) {
		$tmp = thx__OrderedSet_OrderedSet_Impl_::toArray($set);
		$tmp1 = $this1->concat($tmp);
		return thx__OrderedSet_OrderedSet_Impl_::toOrderedSet($tmp1);
	}
	static function unionArray($this1, $set) {
		$tmp = $this1->concat($set);
		return thx__OrderedSet_OrderedSet_Impl_::toOrderedSet($tmp);
	}
	static function toArray($this1) {
		return $this1->copy();
	}
	static function setToArray($this1) {
		return thx__OrderedSet_OrderedSet_Impl_::toArray($this1);
	}
	static function toString($this1) {
		$tmp = $this1->join(", ");
		return "{" . _hx_string_or_null($tmp) . "}";
	}
	function __toString() { return 'thx._OrderedSet.OrderedSet_Impl_'; }
}
