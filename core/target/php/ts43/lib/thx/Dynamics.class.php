<?php

// Generated by Haxe 3.3.0
class thx_Dynamics {
	public function __construct(){}
	static function equals($a, $b) {
		$tmp = !thx_Types::sameType($a, $b);
		if($tmp) {
			return false;
		}
		if((is_object($_t = $a) && ($_t instanceof Enum) ? $_t == $b : _hx_equal($_t, $b))) {
			return true;
		}
		$_g = Type::typeof($a);
		$tmp1 = $_g->index;
		switch($tmp1) {
		case 0:case 1:case 2:case 3:{
			return false;
		}break;
		case 4:{
			$fa = Reflect::fields($a);
			$fb = Reflect::fields($b);
			{
				$_g1 = 0;
				while($_g1 < $fa->length) {
					$field = $fa[$_g1];
					++$_g1;
					$fb->remove($field);
					$tmp2 = !_hx_has_field($b, $field);
					if($tmp2) {
						return false;
					}
					$va = Reflect::field($a, $field);
					$tmp3 = Reflect::isFunction($va);
					if($tmp3) {
						continue;
					}
					$vb = Reflect::field($b, $field);
					$tmp4 = !thx_Dynamics::equals($va, $vb);
					if($tmp4) {
						return false;
					}
					unset($vb,$va,$tmp4,$tmp3,$tmp2,$field);
				}
			}
			if($fb->length > 0) {
				return false;
			}
			$t = false;
			$tmp5 = null;
			$t = thx_Iterators::isIterator($a);
			if(!$t) {
				$tmp5 = thx_Iterables::isIterable($a);
			} else {
				$tmp5 = true;
			}
			if($tmp5) {
				$tmp6 = null;
				if($t) {
					$tmp6 = !thx_Iterators::isIterator($b);
				} else {
					$tmp6 = false;
				}
				if($tmp6) {
					return false;
				}
				$tmp7 = null;
				if(!$t) {
					$tmp7 = !thx_Iterables::isIterable($b);
				} else {
					$tmp7 = false;
				}
				if($tmp7) {
					return false;
				}
				$aa = null;
				if($t) {
					$aa = thx_Iterators::toArray($a);
				} else {
					$tmp8 = $a->iterator();
					$aa = thx_Iterators::toArray($tmp8);
				}
				$ab = null;
				if($t) {
					$ab = thx_Iterators::toArray($b);
				} else {
					$tmp9 = $b->iterator();
					$ab = thx_Iterators::toArray($tmp9);
				}
				if($aa->length !== $ab->length) {
					return false;
				}
				{
					$_g11 = 0;
					$_g2 = $aa->length;
					while($_g11 < $_g2) {
						$i = $_g11++;
						$tmp10 = !thx_Dynamics::equals($aa[$i], $ab[$i]);
						if($tmp10) {
							return false;
						}
						unset($tmp10,$i);
					}
				}
				return true;
			}
			return true;
		}break;
		case 5:{
			return Reflect::compareMethods($a, $b);
		}break;
		case 6:{
			$c = _hx_deref($_g)->params[0];
			$ca = Type::getClassName($c);
			$tmp11 = Type::getClass($b);
			$cb = Type::getClassName($tmp11);
			if($ca !== $cb) {
				return false;
			}
			$tmp12 = Std::is($a, _hx_qtype("String"));
			if($tmp12) {
				return false;
			}
			$tmp13 = Std::is($a, _hx_qtype("Array"));
			if($tmp13) {
				$aa1 = $a;
				$ab1 = $b;
				if($aa1->length !== $ab1->length) {
					return false;
				}
				{
					$_g12 = 0;
					$_g3 = $aa1->length;
					while($_g12 < $_g3) {
						$i1 = $_g12++;
						$tmp14 = !thx_Dynamics::equals($aa1[$i1], $ab1[$i1]);
						if($tmp14) {
							return false;
						}
						unset($tmp14,$i1);
					}
				}
				return true;
			}
			$tmp15 = Std::is($a, _hx_qtype("Date"));
			if($tmp15) {
				$tmp16 = $a->getTime();
				$tmp17 = $b->getTime();
				return _hx_equal($tmp16, $tmp17);
			}
			$tmp18 = Std::is($a, _hx_qtype("haxe.IMap"));
			if($tmp18) {
				$ha = $a;
				$hb = $b;
				$tmp19 = $ha->keys();
				$ka = thx_Iterators::toArray($tmp19);
				$tmp20 = $hb->keys();
				$kb = thx_Iterators::toArray($tmp20);
				if($ka->length !== $kb->length) {
					return false;
				}
				{
					$_g4 = 0;
					while($_g4 < $ka->length) {
						$key = $ka[$_g4];
						++$_g4;
						$tmp21 = null;
						$tmp22 = !(!$hb->exists($key));
						if($tmp22) {
							$tmp23 = $ha->get($key);
							$tmp21 = !thx_Dynamics::equals($tmp23, $hb->get($key));
							unset($tmp23);
						} else {
							$tmp21 = true;
						}
						if($tmp21) {
							return false;
						}
						unset($tmp22,$tmp21,$key);
					}
				}
				return true;
			}
			$t1 = false;
			$tmp24 = null;
			$t1 = thx_Iterators::isIterator($a);
			if(!$t1) {
				$tmp24 = thx_Iterables::isIterable($a);
			} else {
				$tmp24 = true;
			}
			if($tmp24) {
				$va1 = null;
				if($t1) {
					$va1 = thx_Iterators::toArray($a);
				} else {
					$tmp25 = $a->iterator();
					$va1 = thx_Iterators::toArray($tmp25);
				}
				$vb1 = null;
				if($t1) {
					$vb1 = thx_Iterators::toArray($b);
				} else {
					$tmp26 = $b->iterator();
					$vb1 = thx_Iterators::toArray($tmp26);
				}
				if($va1->length !== $vb1->length) {
					return false;
				}
				{
					$_g13 = 0;
					$_g5 = $va1->length;
					while($_g13 < $_g5) {
						$i2 = $_g13++;
						$tmp27 = !thx_Dynamics::equals($va1[$i2], $vb1[$i2]);
						if($tmp27) {
							return false;
						}
						unset($tmp27,$i2);
					}
				}
				return true;
			}
			$f = null;
			$tmp28 = null;
			$tmp29 = _hx_has_field($a, "equals");
			if($tmp29) {
				$f = Reflect::field($a, "equals");
				$tmp28 = Reflect::isFunction($f);
			} else {
				$tmp28 = false;
			}
			if($tmp28) {
				return Reflect::callMethod($a, $f, (new _hx_array(array($b))));
			}
			$tmp30 = Type::getClass($a);
			$fields = Type::getInstanceFields($tmp30);
			{
				$_g6 = 0;
				while($_g6 < $fields->length) {
					$field1 = $fields[$_g6];
					++$_g6;
					$va2 = Reflect::field($a, $field1);
					$tmp31 = Reflect::isFunction($va2);
					if($tmp31) {
						continue;
					}
					$vb2 = Reflect::field($b, $field1);
					$tmp32 = !thx_Dynamics::equals($va2, $vb2);
					if($tmp32) {
						return false;
					}
					unset($vb2,$va2,$tmp32,$tmp31,$field1);
				}
			}
			return true;
		}break;
		case 7:{
			$e = _hx_deref($_g)->params[0];
			$ea = Type::getEnumName($e);
			$teb = Type::getEnum($b);
			$eb = Type::getEnumName($teb);
			if($ea !== $eb) {
				return false;
			}
			if($a->index !== $b->index) {
				return false;
			}
			$pa = Type::enumParameters($a);
			$pb = Type::enumParameters($b);
			{
				$_g14 = 0;
				$_g7 = $pa->length;
				while($_g14 < $_g7) {
					$i3 = $_g14++;
					$tmp33 = !thx_Dynamics::equals($pa[$i3], $pb[$i3]);
					if($tmp33) {
						return false;
					}
					unset($tmp33,$i3);
				}
			}
			return true;
		}break;
		case 8:{
			throw new HException("Unable to compare two unknown types");
		}break;
		}
	}
	static function hclone($v, $cloneInstances = null) {
		if($cloneInstances === null) {
			$cloneInstances = false;
		}
		$_g = Type::typeof($v);
		$tmp = $_g->index;
		switch($tmp) {
		case 0:{
			return null;
		}break;
		case 4:{
			return thx_Objects::copyTo($v, _hx_anonymous(array()), null);
		}break;
		case 6:{
			$c = _hx_deref($_g)->params[0];
			switch(Type::getClassName($c)) {
			case "Array":{
				return $v->map(array(new _hx_lambda(array(&$cloneInstances), "thx_Dynamics_0"), 'execute'));
			}break;
			case "Date":case "String":{
				return $v;
			}break;
			default:{
				if($cloneInstances) {
					$o = Type::createEmptyInstance($c);
					{
						$_g1 = 0;
						$_g11 = Type::getInstanceFields($c);
						while($_g1 < $_g11->length) {
							$field = $_g11[$_g1];
							++$_g1;
							{
								$tmp1 = Reflect::field($v, $field);
								$value = thx_Dynamics::hclone($tmp1, $cloneInstances);
								$o->{$field} = $value;
								unset($value,$tmp1);
							}
							unset($field);
						}
					}
					return $o;
				} else {
					return $v;
				}
			}break;
			}
		}break;
		case 1:case 2:case 3:case 5:case 7:case 8:{
			return $v;
		}break;
		}
	}
	static function compare($a, $b) {
		$tmp = null;
		if(null === $a) {
			$tmp = null === $b;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return 0;
		}
		if(null === $a) {
			return -1;
		}
		if(null === $b) {
			return 1;
		}
		$tmp1 = !thx_Types::sameType($a, $b);
		if($tmp1) {
			$tmp2 = Type::typeof($a);
			$a1 = thx_Types::toString($tmp2);
			$tmp3 = Type::typeof($b);
			$b1 = thx_Types::toString($tmp3);
			return haxe_Utf8::compare($a1, $b1);
		}
		$_g = Type::typeof($a);
		$tmp4 = $_g->index;
		switch($tmp4) {
		case 1:{
			return $a - $b;
		}break;
		case 2:{
			$a2 = $a;
			$b2 = $b;
			if($a2 < $b2) {
				return -1;
			} else {
				if($a2 > $b2) {
					return 1;
				} else {
					return 0;
				}
			}
		}break;
		case 3:{
			return thx_Bools::compare($a, $b);
		}break;
		case 4:{
			return thx_Objects::compare($a, $b);
		}break;
		case 6:{
			switch(Type::getClassName(_hx_deref($_g)->params[0])) {
			case "Array":{
				return thx_Arrays::compare($a, $b);
			}break;
			case "Date":{
				return thx_Dates::compare($a, $b);
			}break;
			case "String":{
				return haxe_Utf8::compare($a, $b);
			}break;
			default:{
				$tmp5 = _hx_has_field($a, "compare");
				if($tmp5) {
					$tmp6 = Reflect::field($a, "compare");
					return Reflect::callMethod($a, $tmp6, (new _hx_array(array($b))));
				} else {
					$tmp7 = Std::string($a);
					$tmp8 = Std::string($b);
					return haxe_Utf8::compare($tmp7, $tmp8);
				}
			}break;
			}
		}break;
		case 7:{
			$e = _hx_deref($_g)->params[0];
			return thx_Enums::compare($a, $b);
		}break;
		default:{
			return 0;
		}break;
		}
	}
	static function string($v) {
		$_g = Type::typeof($v);
		$tmp = $_g->index;
		switch($tmp) {
		case 0:{
			return "null";
		}break;
		case 1:case 2:case 3:{
			$tmp1 = Std::string($v);
			return "" . _hx_string_or_null($tmp1);
		}break;
		case 4:{
			return thx_Objects::string($v);
		}break;
		case 5:{
			return "<function>";
		}break;
		case 6:{
			switch(Type::getClassName(_hx_deref($_g)->params[0])) {
			case "Array":{
				return thx_Arrays::string($v);
			}break;
			case "Date":{
				return $v->toString();
			}break;
			case "String":{
				return $v;
			}break;
			default:{
				$tmp2 = Std::is($v, _hx_qtype("haxe.IMap"));
				if($tmp2) {
					return thx_Maps::string($v);
				} else {
					return Std::string($v);
				}
			}break;
			}
		}break;
		case 7:{
			return thx_Enums::string($v);
		}break;
		case 8:{
			return "<unknown>";
		}break;
		}
	}
	function __toString() { return 'thx.Dynamics'; }
}
function thx_Dynamics_0(&$cloneInstances, $v1) {
	{
		return thx_Dynamics::hclone($v1, $cloneInstances);
	}
}
