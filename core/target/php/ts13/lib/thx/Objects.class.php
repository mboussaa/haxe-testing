<?php

// Generated by Haxe 3.3.0
class thx_Objects {
	public function __construct(){}
	static function compare($a, $b) {
		$v = null;
		$fields = Reflect::fields($a);
		$tmp = Reflect::fields($b);
		$v = thx_Arrays::compare($fields, $tmp);
		if($v !== 0) {
			return $v;
		}
		{
			$_g = 0;
			while($_g < $fields->length) {
				$field = $fields[$_g];
				++$_g;
				$tmp1 = Reflect::field($a, $field);
				$tmp2 = Reflect::field($b, $field);
				$v = thx_Dynamics::compare($tmp1, $tmp2);
				if($v !== 0) {
					return $v;
				}
				unset($tmp2,$tmp1,$field);
			}
		}
		return 0;
	}
	static function isEmpty($o) {
		return Reflect::fields($o)->length === 0;
	}
	static function exists($o, $name) {
		return _hx_has_field($o, $name);
	}
	static function fields($o) {
		return Reflect::fields($o);
	}
	static function combine($first, $second) {
		$to = _hx_anonymous(array());
		{
			$_g = 0;
			$_g1 = Reflect::fields($first);
			while($_g < $_g1->length) {
				$field = $_g1[$_g];
				++$_g;
				{
					$value = Reflect::field($first, $field);
					$to->{$field} = $value;
					unset($value);
				}
				unset($field);
			}
		}
		{
			$_g2 = 0;
			$_g11 = Reflect::fields($second);
			while($_g2 < $_g11->length) {
				$field1 = $_g11[$_g2];
				++$_g2;
				{
					$value1 = Reflect::field($second, $field1);
					$to->{$field1} = $value1;
					unset($value1);
				}
				unset($field1);
			}
		}
		return $to;
	}
	static function assign($to, $from, $replacef = null) {
		$tmp = null === $replacef;
		if($tmp) {
			$replacef = array(new _hx_lambda(array(), "thx_Objects_0"), 'execute');
		}
		{
			$_g = 0;
			$_g1 = Reflect::fields($from);
			while($_g < $_g1->length) {
				$field1 = $_g1[$_g];
				++$_g;
				$newv1 = Reflect::field($from, $field1);
				$tmp1 = _hx_has_field($to, $field1);
				if($tmp1) {
					$tmp2 = Reflect::field($to, $field1);
					$value = call_user_func_array($replacef, array($field1, $tmp2, $newv1));
					$to->{$field1} = $value;
					unset($value,$tmp2);
				} else {
					$to->{$field1} = $newv1;
				}
				unset($tmp1,$newv1,$field1);
			}
		}
		return $to;
	}
	static function copyTo($src, $dst, $cloneInstances = null) {
		if($cloneInstances === null) {
			$cloneInstances = false;
		}
		{
			$_g = 0;
			$_g1 = Reflect::fields($src);
			while($_g < $_g1->length) {
				$field = $_g1[$_g];
				++$_g;
				$tmp = Reflect::field($src, $field);
				$sv = thx_Dynamics::hclone($tmp, $cloneInstances);
				$dv = Reflect::field($dst, $field);
				$tmp1 = null;
				$tmp2 = null;
				$tmp3 = Reflect::isObject($sv);
				if($tmp3) {
					$tmp4 = Type::getClass($sv);
					$tmp2 = null === $tmp4;
					unset($tmp4);
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$tmp5 = Reflect::isObject($dv);
					if($tmp5) {
						$tmp6 = Type::getClass($dv);
						$tmp1 = null === $tmp6;
						unset($tmp6);
					} else {
						$tmp1 = false;
					}
					unset($tmp5);
				} else {
					$tmp1 = false;
				}
				if($tmp1) {
					thx_Objects::copyTo($sv, $dv, null);
				} else {
					$dst->{$field} = $sv;
				}
				unset($tmp3,$tmp2,$tmp1,$tmp,$sv,$field,$dv);
			}
		}
		return $dst;
	}
	static function hclone($src, $cloneInstances = null) {
		if($cloneInstances === null) {
			$cloneInstances = false;
		}
		return thx_Dynamics::hclone($src, $cloneInstances);
	}
	static function toMap($o) {
		$tmp = thx_Objects::tuples($o);
		return thx_Arrays::reduce($tmp, array(new _hx_lambda(array(), "thx_Objects_1"), 'execute'), new haxe_ds_StringMap());
	}
	static function size($o) {
		return Reflect::fields($o)->length;
	}
	static function string($o) {
		$tmp = Reflect::fields($o)->map(array(new _hx_lambda(array(&$o), "thx_Objects_2"), 'execute'))->join(", ");
		return "{" . _hx_string_or_null($tmp) . "}";
	}
	static function stringImpl($o, $cache) {}
	static function values($o) {
		return Reflect::fields($o)->map(array(new _hx_lambda(array(&$o), "thx_Objects_3"), 'execute'));
	}
	static function tuples($o) {
		return Reflect::fields($o)->map(array(new _hx_lambda(array(&$o), "thx_Objects_4"), 'execute'));
	}
	static function hasPath($o, $path) {
		$paths = _hx_explode(".", $path);
		$current = $o;
		{
			$_g = 0;
			while($_g < $paths->length) {
				$currentPath = $paths[$_g];
				++$_g;
				$tmp = ctype_digit($currentPath);
				if($tmp) {
					$index = Std::parseInt($currentPath);
					$arr = Std::instance($current, _hx_qtype("Array"));
					$tmp1 = null;
					if(null !== $arr) {
						$tmp1 = $arr->length <= $index;
					} else {
						$tmp1 = true;
					}
					if($tmp1) {
						return false;
					}
					$current = $arr[$index];
					unset($tmp1,$index,$arr);
				} else {
					$tmp2 = _hx_has_field($current, $currentPath);
					if($tmp2) {
						$current = Reflect::field($current, $currentPath);
					} else {
						return false;
					}
					unset($tmp2);
				}
				unset($tmp,$currentPath);
			}
		}
		return true;
	}
	static function hasPathValue($o, $path) {
		$tmp = thx_Objects::getPath($o, $path);
		return $tmp !== null;
	}
	static function getPath($o, $path) {
		$paths = _hx_explode(".", $path);
		$current = $o;
		{
			$_g = 0;
			while($_g < $paths->length) {
				$currentPath = $paths[$_g];
				++$_g;
				$tmp = ctype_digit($currentPath);
				if($tmp) {
					$index = Std::parseInt($currentPath);
					$arr = Std::instance($current, _hx_qtype("Array"));
					if(null === $arr) {
						return null;
					}
					$current = $arr[$index];
					unset($index,$arr);
				} else {
					$tmp1 = _hx_has_field($current, $currentPath);
					if($tmp1) {
						$current = Reflect::field($current, $currentPath);
					} else {
						return null;
					}
					unset($tmp1);
				}
				unset($tmp,$currentPath);
			}
		}
		return $current;
	}
	static function getPathOption($o, $path) {
		$value = thx_Objects::getPath($o, $path);
		if(null === $value) {
			return haxe_ds_Option::$None;
		} else {
			return haxe_ds_Option::Some($value);
		}
	}
	static function getPathOr($o, $path, $alt) {
		$paths = _hx_explode(".", $path);
		$current = $o;
		{
			$_g = 0;
			while($_g < $paths->length) {
				$currentPath = $paths[$_g];
				++$_g;
				$tmp = ctype_digit($currentPath);
				if($tmp) {
					$index = Std::parseInt($currentPath);
					$arr = Std::instance($current, _hx_qtype("Array"));
					if(null === $arr) {
						return null;
					}
					$current = $arr[$index];
					unset($index,$arr);
				} else {
					$tmp1 = _hx_has_field($current, $currentPath);
					if($tmp1) {
						$current = Reflect::field($current, $currentPath);
					} else {
						return $alt;
					}
					unset($tmp1);
				}
				unset($tmp,$currentPath);
			}
		}
		return $current;
	}
	static function setPath($o, $path, $val) {
		$paths = _hx_explode(".", $path);
		$current = $o;
		{
			$_g1 = 0;
			$_g = $paths->length - 1;
			while($_g1 < $_g) {
				$i = $_g1++;
				$currentPath = $paths[$i];
				$nextPath = $paths[$i + 1];
				$tmp = null;
				$tmp1 = !ctype_digit($currentPath);
				if($tmp1) {
					$tmp = $currentPath === "*";
				} else {
					$tmp = true;
				}
				if($tmp) {
					$index = null;
					if($currentPath === "*") {
						$index = $current->length;
					} else {
						$index = Std::parseInt($currentPath);
					}
					if($current[$index] === null) {
						$tmp2 = null;
						$tmp3 = !ctype_digit($nextPath);
						if($tmp3) {
							$tmp2 = $nextPath === "*";
						} else {
							$tmp2 = true;
						}
						if($tmp2) {
							$current[$index] = (new _hx_array(array()));
						} else {
							$current[$index] = _hx_anonymous(array());
						}
						unset($tmp3,$tmp2);
					}
					$current = $current[$index];
					unset($index);
				} else {
					$tmp4 = !_hx_has_field($current, $currentPath);
					if($tmp4) {
						$tmp5 = null;
						$tmp6 = !ctype_digit($nextPath);
						if($tmp6) {
							$tmp5 = $nextPath === "*";
						} else {
							$tmp5 = true;
						}
						if($tmp5) {
							$current->{$currentPath} = (new _hx_array(array()));
						} else {
							$current->{$currentPath} = _hx_anonymous(array());
						}
						unset($tmp6,$tmp5);
					}
					$current = Reflect::field($current, $currentPath);
					unset($tmp4);
				}
				unset($tmp1,$tmp,$nextPath,$i,$currentPath);
			}
		}
		$p = $paths[$paths->length - 1];
		$tmp7 = ctype_digit($p);
		if($tmp7) {
			$index1 = Std::parseInt($p);
			$current[$index1] = $val;
		} else {
			if($p === "*") {
				$current->push($val);
			} else {
				$current->{$p} = $val;
			}
		}
		return $o;
	}
	static function removePath($o, $path) {
		$paths = _hx_explode(".", $path);
		$target = $paths->pop();
		try {
			$sub = thx_Arrays::reduce($paths, array(new _hx_lambda(array(), "thx_Objects_5"), 'execute'), $o);
			if(null !== $sub) {
				Reflect::deleteField($sub, $target);
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{}
		}
		return $o;
	}
	function __toString() { return 'thx.Objects'; }
}
function thx_Objects_0($field, $oldv, $newv) {
	{
		return $newv;
	}
}
function thx_Objects_1($map, $t) {
	{
		{
			$value = $t->_1;
			$map->set($t->_0, $value);
		}
		return $map;
	}
}
function thx_Objects_2(&$o, $key) {
	{
		$v = Reflect::field($o, $key);
		$s = null;
		$tmp1 = Std::is($v, _hx_qtype("String"));
		if($tmp1) {
			$s = thx_Strings::quote($v);
		} else {
			$s = thx_Dynamics::string($v);
		}
		return "" . _hx_string_or_null($key) . " : " . _hx_string_or_null($s);
	}
}
function thx_Objects_3(&$o, $key) {
	{
		return Reflect::field($o, $key);
	}
}
function thx_Objects_4(&$o, $key) {
	{
		$_1 = Reflect::field($o, $key);
		return _hx_anonymous(array("_0" => $key, "_1" => $_1));
	}
}
function thx_Objects_5($existing, $nextPath) {
	{
		if($nextPath === "*") {
			return $existing->pop();
		} else {
			$tmp = ctype_digit($nextPath);
			if($tmp) {
				$current = $existing;
				$index = Std::parseInt($nextPath);
				return $current[$index];
			} else {
				return Reflect::field($existing, $nextPath);
			}
		}
	}
}
