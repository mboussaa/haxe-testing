<?php

// Generated by Haxe 3.3.0
class thx_bigint_DecimalImpl {
	public function __construct($value, $scale) {
		if(!php_Boot::$skip_constructor) {
		$this->value = $value;
		$this->scale = $scale;
	}}
	public $value;
	public $scale;
	public function add($that) {
		$lhs = $this->matchScale($that);
		$rhs = $that->matchScale($this);
		$tmp = $lhs->value->add($rhs->value);
		return new thx_bigint_DecimalImpl($tmp, $lhs->scale);
	}
	public function subtract($that) {
		$lhs = $this->matchScale($that);
		$rhs = $that->matchScale($this);
		$tmp = $lhs->value->subtract($rhs->value);
		return new thx_bigint_DecimalImpl($tmp, $lhs->scale);
	}
	public function divide($that) {
		return $this->divideWithScale($that, thx_bigint_Decimals::$divisionExtraScale);
	}
	public function divideWithScale($that, $scale) {
		$tmp = $that->isZero();
		if($tmp) {
			throw new HException(new thx_Error("division by zero", null, _hx_anonymous(array("fileName" => "DecimalImpl.hx", "lineNumber" => 42, "className" => "thx.bigint.DecimalImpl", "methodName" => "divideWithScale"))));
		}
		$lhs = $this->matchScale($that);
		$rhs = $that->matchScale($this);
		$tmp1 = $rhs->scale + $scale;
		$tmp2 = thx_bigint_Bigs::fromInt($tmp1);
		$pow = thx_bigint_Small::$ten->pow($tmp2);
		$qr = $lhs->value->multiply($pow)->divMod($rhs->value);
		$nscale = $rhs->scale + $scale;
		return _hx_deref(new thx_bigint_DecimalImpl($qr->quotient, $nscale))->trim($nscale);
	}
	public function moduloWithScale($that, $scale) {
		$tmp = $that->isZero();
		if($tmp) {
			throw new HException(new thx_Error("modulo by zero", null, _hx_anonymous(array("fileName" => "DecimalImpl.hx", "lineNumber" => 53, "className" => "thx.bigint.DecimalImpl", "methodName" => "moduloWithScale"))));
		}
		$lhs = $this->matchScale($that);
		$rhs = $that->matchScale($this);
		$tmp1 = thx_bigint_Bigs::fromInt($scale);
		$pow = thx_bigint_Small::$ten->pow($tmp1);
		$tmp2 = $lhs->value->multiply($pow);
		$tmp3 = $rhs->value->multiply($pow);
		$qr = $tmp2->divMod($tmp3);
		$nscale = $lhs->scale + $scale;
		return _hx_deref(new thx_bigint_DecimalImpl($qr->remainder, $nscale))->trim($nscale);
	}
	public function multiply($that) {
		$tmp = $this->value->multiply($that->value);
		return new thx_bigint_DecimalImpl($tmp, $this->scale + $that->scale);
	}
	public function modulo($that) {
		return $this->moduloWithScale($that, thx_bigint_Decimals::$divisionExtraScale);
	}
	public function abs() {
		$tmp = $this->value->abs();
		return new thx_bigint_DecimalImpl($tmp, $this->scale);
	}
	public function negate() {
		$tmp = $this->value->negate();
		return new thx_bigint_DecimalImpl($tmp, $this->scale);
	}
	public function next() {
		return $this->add(thx_bigint_DecimalImpl::$one);
	}
	public function prev() {
		return $this->subtract(thx_bigint_DecimalImpl::$one);
	}
	public function pow($exp) {
		if($exp < 0) {
			$tmp = thx_bigint_Bigs::fromInt(-$exp);
			$i = $this->value->pow($tmp);
			$tmp1 = thx__Decimal_Decimal_Impl_::fromBigInt($i);
			$tmp2 = ($this->scale + 1) * -$exp;
			return thx__Decimal_Decimal_Impl_::$one->divideWithScale($tmp1, $tmp2);
		} else {
			$tmp3 = thx_bigint_Bigs::fromInt($exp);
			$i1 = $this->value->pow($tmp3);
			return new thx_bigint_DecimalImpl($i1, $this->scale * $exp);
		}
	}
	public function ceilTo($newscale) {
		$tmp = $this->isZero();
		if($tmp) {
			return $this;
		}
		$scaled = $this->scaleTo($newscale);
		$tmp1 = null;
		$tmp2 = $scaled->isZero();
		if($tmp2) {
			$tmp1 = thx_bigint_DecimalImpl::$one;
		} else {
			$tmp1 = $this->modulo($scaled);
		}
		$tmp3 = thx_bigint_DecimalImpl::$ten->pow($newscale);
		$f = $tmp1->multiply($tmp3)->toFloat();
		if($f <= 0) {
			return $scaled;
		} else {
			$tmp4 = $scaled->value->add(thx_bigint_Small::$one);
			return new thx_bigint_DecimalImpl($tmp4, $scaled->scale);
		}
	}
	public function floorTo($newscale) {
		return $this->scaleTo($newscale);
	}
	public function roundTo($newscale) {
		$tmp = $this->isZero();
		if($tmp) {
			return $this;
		}
		$scaled = $this->scaleTo($newscale);
		$tmp1 = null;
		$tmp2 = $scaled->isZero();
		if($tmp2) {
			$tmp1 = thx_bigint_DecimalImpl::$one;
		} else {
			$tmp1 = $this->modulo($scaled);
		}
		$tmp3 = thx_bigint_DecimalImpl::$ten->pow($newscale);
		$f = $tmp1->multiply($tmp3)->toFloat();
		if($f < 0.5) {
			return $scaled;
		} else {
			$tmp4 = $scaled->value->add(thx_bigint_Small::$one);
			return new thx_bigint_DecimalImpl($tmp4, $scaled->scale);
		}
	}
	public function scaleTo($newscale) {
		if($newscale === $this->scale) {
			return $this;
		}
		$tmp = $newscale > $this->scale;
		if($tmp) {
			$tmp1 = $newscale - $this->scale;
			$tmp2 = thx_bigint_Bigs::fromInt($tmp1);
			$mul = thx_bigint_Small::$ten->pow($tmp2);
			$tmp3 = $this->value->multiply($mul);
			return new thx_bigint_DecimalImpl($tmp3, $newscale);
		} else {
			$tmp4 = $this->scale - $newscale;
			$tmp5 = thx_bigint_Bigs::fromInt($tmp4);
			$div = thx_bigint_Small::$ten->pow($tmp5);
			$tmp6 = $this->value->divide($div);
			return new thx_bigint_DecimalImpl($tmp6, $newscale);
		}
	}
	public function square() {
		return $this->multiply($this);
	}
	public function isNegative() {
		return $this->value->sign;
	}
	public function isEven() {
		return $this->value->isEven();
	}
	public function isOdd() {
		return $this->value->isOdd();
	}
	public function isZero() {
		return $this->value->isZero();
	}
	public function compareTo($that) {
		$lhs = $this->matchScale($that);
		$rhs = $that->matchScale($this);
		return $lhs->value->compareTo($rhs->value);
	}
	public function compareToAbs($that) {
		$lhs = $this->matchScale($that);
		$rhs = $that->matchScale($this);
		return $lhs->value->compareToAbs($rhs->value);
	}
	public function trim($min = null) {
		if($min === null) {
			$min = 0;
		}
		if($this->scale === 0) {
			return $this;
		}
		$s = $this->toString();
		$parts = _hx_explode(".", $s);
		$tmp = thx_Strings::trimCharsRight($parts[1], "0");
		$dec = thx_Strings::rpad($tmp, "0", $min);
		if(strlen($dec) > 0) {
			$s = _hx_string_or_null($parts[0]) . "." . _hx_string_or_null($dec);
		} else {
			$s = $parts[0];
		}
		return thx_bigint_Decimals::parse($s);
	}
	public function toFloat() {
		$tmp = $this->toString();
		return Std::parseFloat($tmp);
	}
	public function toInt() {
		$tmp = thx_bigint_Bigs::fromInt($this->scale);
		$tmp1 = thx_bigint_Small::$ten->pow($tmp);
		$i = $this->value->divide($tmp1);
		return $i->toInt();
	}
	public function toString() {
		$sign = $this->value->sign;
		$tmp = null;
		if($sign) {
			$tmp = $this->value->negate();
		} else {
			$tmp = $this->value;
		}
		$i = $tmp->toString();
		$l = strlen($i);
		$tmp1 = $this->scale === 0;
		if($tmp1) {
			$tmp2 = null;
			if($sign) {
				$tmp2 = "-";
			} else {
				$tmp2 = "";
			}
			return _hx_string_or_null($tmp2) . _hx_string_or_null($i);
		} else {
			$tmp3 = strlen($i) <= $this->scale;
			if($tmp3) {
				$tmp4 = null;
				if($sign) {
					$tmp4 = "-";
				} else {
					$tmp4 = "";
				}
				$tmp5 = _hx_string_or_null($tmp4) . "0.";
				$tmp6 = thx_Strings::lpad($i, "0", $this->scale);
				return _hx_string_or_null($tmp5) . _hx_string_or_null($tmp6);
			} else {
				$tmp7 = null;
				if($sign) {
					$tmp7 = "-";
				} else {
					$tmp7 = "";
				}
				$tmp8 = $l - $this->scale;
				$tmp9 = _hx_substring($i, 0, $tmp8);
				$tmp10 = _hx_string_or_null($tmp7) . _hx_string_or_null($tmp9) . ".";
				$tmp11 = $l - $this->scale;
				$tmp12 = _hx_substring($i, $tmp11, null);
				return _hx_string_or_null($tmp10) . _hx_string_or_null($tmp12);
			}
		}
	}
	public function matchScale($that) {
		if($this->scale >= $that->scale) {
			return $this;
		}
		return $this->scaleTo($that->scale);
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $zero;
	static $one;
	static $ten;
	static function randomBetween($a, $b) {
		$lhs = $a->matchScale($b);
		$rhs = $b->matchScale($a);
		$tmp = thx__BigInt_BigInt_Impl_::randomBetween($lhs->value, $rhs->value);
		return new thx_bigint_DecimalImpl($tmp, $lhs->scale);
	}
	function __toString() { return $this->toString(); }
}
thx_bigint_DecimalImpl::$zero = thx_bigint_Decimals::fromInt(0);
thx_bigint_DecimalImpl::$one = thx_bigint_Decimals::fromInt(1);
thx_bigint_DecimalImpl::$ten = thx_bigint_Decimals::fromInt(10);
