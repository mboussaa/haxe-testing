<?php

// Generated by Haxe 3.3.0
class thx__Rational_Rational_Impl_ {
	public function __construct(){}
	static $zero;
	static function fromString($s) {
		$parts = _hx_explode("/", $s)->map((isset(StringTools::$trim) ? StringTools::$trim: array("StringTools", "trim")));
		$tmp = $parts->length > 2;
		if($tmp) {
			throw new HException(new thx_Error("string \"" . _hx_string_or_null($s) . "\" cannot be parsed to a Rational", null, _hx_anonymous(array("fileName" => "Rational.hx", "lineNumber" => 12, "className" => "thx._Rational.Rational_Impl_", "methodName" => "fromString"))));
		}
		$tmp1 = $parts->length === 1;
		if($tmp1) {
			return thx__Rational_Rational_Impl_::create(thx_bigint_Bigs::parseBase($parts[0], 10), thx__BigInt_BigInt_Impl_::$one);
		}
		$tmp2 = thx_bigint_Bigs::parseBase($parts[0], 10);
		return thx__Rational_Rational_Impl_::create($tmp2, thx_bigint_Bigs::parseBase($parts[1], 10));
	}
	static function fromBigInt($i) {
		return thx__Rational_Rational_Impl_::create($i, thx__BigInt_BigInt_Impl_::$one);
	}
	static function fromInt($i) {
		return thx__Rational_Rational_Impl_::create(thx_bigint_Bigs::fromInt($i), thx__BigInt_BigInt_Impl_::$one);
	}
	static function create($num, $den) {
		$tmp = thx__BigInt_BigInt_Impl_::equals($den, thx_bigint_Bigs::fromInt(0));
		if($tmp) {
			throw new HException(new thx_Error("division by zero", null, _hx_anonymous(array("fileName" => "Rational.hx", "lineNumber" => 26, "className" => "thx._Rational.Rational_Impl_", "methodName" => "create"))));
		}
		$tmp1 = $num->toInt();
		$g = thx_Ints::gcd($tmp1, $den->toInt());
		$that = thx_bigint_Bigs::fromInt($g);
		$this1 = $num->divide($that);
		$tmp2 = $this1->toInt();
		$value = Std::int($tmp2);
		$num = thx_bigint_Bigs::fromInt($value);
		$that1 = thx_bigint_Bigs::fromInt($g);
		$this2 = $den->divide($that1);
		$tmp3 = $this2->toInt();
		$value1 = Std::int($tmp3);
		$den = thx_bigint_Bigs::fromInt($value1);
		$tmp4 = thx__BigInt_BigInt_Impl_::less($den, thx_bigint_Bigs::fromInt(0));
		if($tmp4) {
			$num = $num->negate();
			$den = $den->negate();
		}
		$tmp5 = thx__BigInt_BigInt_Impl_::equals($num, thx_bigint_Bigs::fromInt(0));
		if($tmp5) {
			$den = thx_bigint_Bigs::fromInt(1);
		}
		$num1 = $num->toInt();
		$den1 = $den->toInt();
		$this3 = null;
		$tmp6 = thx_bigint_Bigs::fromInt($num1);
		$this3 = _hx_anonymous(array("num" => $tmp6, "den" => thx_bigint_Bigs::fromInt($den1)));
		return $this3;
	}
	static function _new($num, $den) {
		$this1 = null;
		$tmp = thx_bigint_Bigs::fromInt($num);
		$this1 = _hx_anonymous(array("num" => $tmp, "den" => thx_bigint_Bigs::fromInt($den)));
		return $this1;
	}
	static function abs($this1) {
		$this2 = $this1->num->abs();
		$num = $this2->toInt();
		$den = $this1->den->toInt();
		$this3 = null;
		$tmp = thx_bigint_Bigs::fromInt($num);
		$this3 = _hx_anonymous(array("num" => $tmp, "den" => thx_bigint_Bigs::fromInt($den)));
		return $this3;
	}
	static function negate($this1) {
		$this2 = $this1->num->negate();
		$num = $this2->toInt();
		$den = $this1->den->toInt();
		$this3 = null;
		$tmp = thx_bigint_Bigs::fromInt($num);
		$this3 = _hx_anonymous(array("num" => $tmp, "den" => thx_bigint_Bigs::fromInt($den)));
		return $this3;
	}
	static function add($this1, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($this1, thx__Rational_Rational_Impl_::$zero);
		if($tmp === 0) {
			return $that;
		}
		$tmp1 = thx__Rational_Rational_Impl_::compareTo($that, thx__Rational_Rational_Impl_::$zero);
		if($tmp1 === 0) {
			return $this1;
		}
		$tmp2 = $this1->num->toInt();
		$f = thx_Ints::gcd($tmp2, $that->num->toInt());
		$tmp3 = $this1->den->toInt();
		$g = thx_Ints::gcd($tmp3, $that->den->toInt());
		$that1 = thx_bigint_Bigs::fromInt($f);
		$this2 = $this1->num->divide($that1);
		$tmp4 = $this2->toInt();
		$tmp5 = Std::int($tmp4);
		$that2 = thx_bigint_Bigs::fromInt($g);
		$this3 = $that->den->divide($that2);
		$tmp6 = $this3->toInt();
		$tmp7 = Std::int($tmp6);
		$tmp8 = $tmp5 * $tmp7;
		$that3 = thx_bigint_Bigs::fromInt($f);
		$this4 = $that->num->divide($that3);
		$tmp9 = $this4->toInt();
		$tmp10 = Std::int($tmp9);
		$that4 = thx_bigint_Bigs::fromInt($g);
		$this5 = $this1->den->divide($that4);
		$tmp11 = $this5->toInt();
		$tmp12 = Std::int($tmp11);
		$tmp13 = thx_bigint_Bigs::fromInt($tmp8 + $tmp10 * $tmp12);
		$tmp14 = $this1->den->toInt();
		$value = thx_Ints::lcm($tmp14, $that->den->toInt());
		$tmp15 = thx_bigint_Bigs::fromInt($value);
		$s = thx__Rational_Rational_Impl_::create($tmp13, $tmp15);
		$that5 = thx_bigint_Bigs::fromInt($f);
		$tmp16 = $s->num->multiply($that5);
		$s->num = $tmp16;
		return $s;
	}
	static function subtract($this1, $that) {
		$tmp = thx__Rational_Rational_Impl_::negate($that);
		return thx__Rational_Rational_Impl_::add($this1, $tmp);
	}
	static function multiply($this1, $that) {
		$c = thx__Rational_Rational_Impl_::create($this1->num, $that->den);
		$d = thx__Rational_Rational_Impl_::create($that->num, $this1->den);
		$tmp = $c->num->multiply($d->num);
		return thx__Rational_Rational_Impl_::create($tmp, $c->den->multiply($d->den));
	}
	static function divide($this1, $that) {
		$tmp = thx__Rational_Rational_Impl_::reciprocal($that);
		return thx__Rational_Rational_Impl_::multiply($this1, $tmp);
	}
	static function reciprocal($this1) {
		return thx__Rational_Rational_Impl_::create($this1->den, $this1->num);
	}
	static function isZero($this1) {
		return $this1->num->isZero();
	}
	static function isNegative($this1) {
		return $this1->num->sign;
	}
	static function compareTo($this1, $that) {
		$lhs = $this1->num->multiply($that->den);
		$rhs = $this1->den->multiply($that->num);
		return $lhs->compareTo($rhs);
	}
	static function greaterThan($this1, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($this1, $that);
		return $tmp > 0;
	}
	static function greater($self, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($self, $that);
		return $tmp > 0;
	}
	static function greaterEqualsTo($this1, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($this1, $that);
		return $tmp >= 0;
	}
	static function greaterEquals($self, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($self, $that);
		return $tmp >= 0;
	}
	static function lessThan($this1, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($this1, $that);
		return $tmp < 0;
	}
	static function less($self, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($self, $that);
		return $tmp < 0;
	}
	static function lessEqualsTo($this1, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($this1, $that);
		return $tmp <= 0;
	}
	static function lessEquals($self, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($self, $that);
		return $tmp <= 0;
	}
	static function equalsTo($this1, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($this1, $that);
		return $tmp === 0;
	}
	static function equals($self, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($self, $that);
		return $tmp === 0;
	}
	static function notEqualsTo($this1, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($this1, $that);
		return $tmp !== 0;
	}
	static function notEquals($self, $that) {
		$tmp = thx__Rational_Rational_Impl_::compareTo($self, $that);
		return $tmp !== 0;
	}
	static function toFloat($this1) {
		$tmp = $this1->num->toFloat();
		$tmp1 = $this1->den->toFloat();
		return $tmp / $tmp1;
	}
	static function toDecimal($this1, $extraScale = null) {
		if($extraScale === null) {
			$extraScale = 0;
		}
		return thx__Decimal_Decimal_Impl_::fromBigInt($this1->num)->divide(thx__Decimal_Decimal_Impl_::fromBigInt($this1->den));
	}
	static function toString($this1) {
		$tmp = thx__BigInt_BigInt_Impl_::equals($this1->den, thx_bigint_Bigs::fromInt(1));
		if($tmp) {
			$tmp1 = $this1->num->toString();
			return "" . _hx_string_or_null($tmp1);
		} else {
			$tmp2 = $this1->num->toString();
			$tmp3 = "" . _hx_string_or_null($tmp2) . "/";
			$tmp4 = $this1->den->toString();
			return _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
		}
	}
	static function get_num($this1) {
		return $this1->num;
	}
	static function get_den($this1) {
		return $this1->den;
	}
	static $__properties__ = array("get_den" => "get_den","get_num" => "get_num");
	function __toString() { return 'thx._Rational.Rational_Impl_'; }
}
thx__Rational_Rational_Impl_::$zero = _hx_anonymous(array("num" => thx__BigInt_BigInt_Impl_::$one, "den" => thx__BigInt_BigInt_Impl_::$zero));
