<?php

// Generated by Haxe 3.3.0
class thx_Assert {
	public function __construct(){}
	static $behavior;
	static function contains($possibilities, $value, $msg = null, $pos = null) {
		$tmp = thx_Arrays::contains($possibilities, $value, null);
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp2 = Std::string($value);
				$tmp3 = "value " . _hx_string_or_null($tmp2) . " not found in the expected possibilities ";
				$tmp4 = Std::string($possibilities);
				$tmp1 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			} else {
				$tmp1 = $msg;
			}
			thx_Assert::fail($tmp1, $pos);
		}
	}
	static function equals($expected, $value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = Std::string($expected);
			$tmp1 = "expected " . _hx_string_or_null($tmp) . " but it is ";
			$tmp2 = Std::string($value);
			$msg = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
		}
		thx_Assert::isTrue(_hx_equal($expected, $value), $msg, $pos);
	}
	static function excludes($match, $values, $msg = null, $pos = null) {
		$tmp = !thx_Arrays::contains($values, $match, null);
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp2 = Std::string($values);
				$tmp3 = "values " . _hx_string_or_null($tmp2) . " do contain ";
				$tmp4 = Std::string($match);
				$tmp1 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			} else {
				$tmp1 = $msg;
			}
			thx_Assert::fail($tmp1, $pos);
		}
	}
	static function fail($msg = null, $pos = null) {
		if($msg === null) {
			$msg = "failure expected";
		}
		thx_Assert::isTrue(false, $msg, $pos);
	}
	static function isContainedIn($match, $values, $msg = null, $pos = null) {
		$tmp = thx_Arrays::contains($values, $match, null);
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp2 = Std::string($values);
				$tmp3 = "values " . _hx_string_or_null($tmp2) . " do not contain ";
				$tmp4 = Std::string($match);
				$tmp1 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			} else {
				$tmp1 = $msg;
			}
			thx_Assert::fail($tmp1, $pos);
		}
	}
	static function isFalse($value, $msg = null, $pos = null) {
		$tmp = null === $msg;
		if($tmp) {
			$msg = "expected false";
		}
		thx_Assert::isTrue($value === false, $msg, $pos);
	}
	static function is($value, $type, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = null;
			$tmp1 = Std::is($type, _hx_qtype("ValueType"));
			if($tmp1) {
				$tmp = thx_Types::toString($type);
			} else {
				$tmp2 = Std::is($type, _hx_qtype("Class"));
				if($tmp2) {
					$tmp = Type::getClassName($type);
				} else {
					$tmp3 = Std::is($type, _hx_qtype("Enum"));
					if($tmp3) {
						$tmp = Type::getEnumName($type);
					} else {
						$tmp4 = Type::typeof($type);
						$tmp = thx_Types::toString($tmp4);
					}
				}
			}
			$tmp5 = "expected type " . _hx_string_or_null($tmp) . " but it is ";
			$tmp6 = Type::typeof($value);
			$tmp7 = thx_Types::toString($tmp6);
			$msg = _hx_string_or_null($tmp5) . _hx_string_or_null($tmp7);
		}
		$tmp8 = Std::is($value, $type);
		thx_Assert::isTrue($tmp8, $msg, $pos);
	}
	static function isNull($value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = Std::string($value);
			$msg = "expected null but it is " . _hx_string_or_null($tmp);
		}
		thx_Assert::isTrue($value === null, $msg, $pos);
	}
	static function isTrue($cond, $msg = null, $pos = null) {
		if($cond) {
			thx_Assert::$behavior->success($pos);
		} else {
			thx_Assert::$behavior->fail($msg, $pos);
		}
	}
	static function matches($pattern, $value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = Std::string($value);
			$msg = "the value " . _hx_string_or_null($tmp) . " does not match the provided pattern";
		}
		$tmp1 = $pattern->match($value);
		thx_Assert::isTrue($tmp1, $msg, $pos);
	}
	static function nearEquals($expected, $value, $approx = null, $msg = null, $pos = null) {
		$tmp = $msg === null;
		if($tmp) {
			$msg = "expected " . _hx_string_rec($expected, "") . " but it is " . _hx_string_rec($value, "");
		}
		$tmp1 = thx_Floats::nearEquals($expected, $value, $approx);
		thx_Assert::isTrue($tmp1, $msg, $pos);
		return;
	}
	static function notEquals($expected, $value, $msg = null, $pos = null) {
		if($msg === null) {
			$tmp = Std::string($expected);
			$tmp1 = "expected " . _hx_string_or_null($tmp) . " and test value ";
			$tmp2 = Std::string($value);
			$msg = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2) . " should be different";
		}
		thx_Assert::isFalse(_hx_equal($expected, $value), $msg, $pos);
	}
	static function notNull($value, $msg = null, $pos = null) {
		$tmp = null === $msg;
		if($tmp) {
			$msg = "expected not null";
		}
		thx_Assert::isTrue($value !== null, $msg, $pos);
	}
	static function pass($msg = null, $pos = null) {
		if($msg === null) {
			$msg = "pass expected";
		}
		thx_Assert::isTrue(true, $msg, $pos);
	}
	static function raises($method, $type = null, $msgNotThrown = null, $msgWrongType = null, $pos = null) {
		try {
			call_user_func($method);
			if(null === $msgNotThrown) {
				$name = null;
				if(null === $type) {
					$name = "Dynamic";
				} else {
					$tmp = Std::is($type, _hx_qtype("ValueType"));
					if($tmp) {
						$name = thx_Types::toString($type);
					} else {
						$tmp1 = Std::is($type, _hx_qtype("Class"));
						if($tmp1) {
							$name = Type::getClassName($type);
						} else {
							$tmp2 = Std::is($type, _hx_qtype("Enum"));
							if($tmp2) {
								$name = Type::getEnumName($type);
							} else {
								$tmp3 = Type::typeof($type);
								$name = thx_Types::toString($tmp3);
							}
						}
					}
				}
				$msgNotThrown = "exception of type " . _hx_string_or_null($name) . " not raised";
			}
			thx_Assert::fail($msgNotThrown, $pos);
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$ex = $_ex_;
			{
				if(null === $type) {
					thx_Assert::pass(null, $pos);
				} else {
					if(null === $msgWrongType) {
						$name1 = null;
						$tmp4 = Std::is($type, _hx_qtype("ValueType"));
						if($tmp4) {
							$name1 = thx_Types::toString($type);
						} else {
							$tmp5 = Std::is($type, _hx_qtype("Class"));
							if($tmp5) {
								$name1 = Type::getClassName($type);
							} else {
								$tmp6 = Std::is($type, _hx_qtype("Enum"));
								if($tmp6) {
									$name1 = Type::getEnumName($type);
								} else {
									$tmp7 = Type::typeof($type);
									$name1 = thx_Types::toString($tmp7);
								}
							}
						}
						$tmp8 = "expected throw of type " . _hx_string_or_null($name1) . " but it is ";
						$tmp9 = Std::string($ex);
						$msgWrongType = _hx_string_or_null($tmp8) . _hx_string_or_null($tmp9);
					}
					$tmp10 = Std::is($ex, $type);
					thx_Assert::isTrue($tmp10, $msgWrongType, $pos);
				}
			}
		}
	}
	static function same($expected, $value, $recursive = null, $msg = null, $pos = null) {
		if($recursive === null) {
			$recursive = true;
		}
		$status = _hx_anonymous(array("recursive" => $recursive, "path" => "", "error" => null));
		$tmp = thx_Assert::sameAs($expected, $value, $status);
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp1 = null;
			if($msg === null) {
				$tmp1 = $status->error;
			} else {
				$tmp1 = $msg;
			}
			thx_Assert::fail($tmp1, $pos);
		}
	}
	static function stringContains($match, $value, $msg = null, $pos = null) {
		$tmp = null;
		if($value !== null) {
			$tmp1 = _hx_index_of($value, $match, null);
			$tmp = $tmp1 >= 0;
		} else {
			$tmp = false;
		}
		if($tmp) {
			thx_Assert::pass($msg, $pos);
		} else {
			$tmp2 = null;
			if($msg === null) {
				$tmp3 = thx_Strings::quote($value);
				$tmp4 = "value " . _hx_string_or_null($tmp3) . " does not contain ";
				$tmp5 = thx_Strings::quote($match);
				$tmp2 = _hx_string_or_null($tmp4) . _hx_string_or_null($tmp5);
			} else {
				$tmp2 = $msg;
			}
			thx_Assert::fail($tmp2, $pos);
		}
	}
	static function stringSequence($sequence, $value, $msg = null, $pos = null) {
		if(null === $value) {
			$tmp = null;
			if($msg === null) {
				$tmp = "null argument value";
			} else {
				$tmp = $msg;
			}
			thx_Assert::fail($tmp, $pos);
			return;
		}
		$p = 0;
		{
			$_g = 0;
			while($_g < $sequence->length) {
				$s = $sequence[$_g];
				++$_g;
				$p2 = _hx_index_of($value, $s, $p);
				if($p2 < 0) {
					if($msg === null) {
						$tmp1 = thx_Strings::quote($s);
						$msg = "expected " . _hx_string_or_null($tmp1) . " after ";
						if($p > 0) {
							$tmp2 = thx_Strings::ellipsis($value, 30, null);
							$tmp3 = thx_Strings::quote($tmp2);
							$msg .= " " . _hx_string_or_null($tmp3);
							unset($tmp3,$tmp2);
						} else {
							$msg .= " begin";
						}
						unset($tmp1);
					}
					thx_Assert::fail($msg, $pos);
					return;
				}
				$p = $p2 + strlen($s);
				unset($s,$p2);
			}
		}
		thx_Assert::pass($msg, $pos);
	}
	static function warn($msg, $pos = null) {
		thx_Assert::$behavior->warn($msg, $pos);
	}
	static function sameAs($expected, $value, $status) {
		$withPath = array(new _hx_lambda(array(&$status), "thx_Assert_0"), 'execute');
		$tmp1 = !thx_Types::sameType($expected, $value);
		if($tmp1) {
			$tmp2 = Type::typeof($expected);
			$texpected = thx_Types::toString($tmp2);
			$tmp3 = Type::typeof($value);
			$tvalue = thx_Types::toString($tmp3);
			$status->error = call_user_func_array($withPath, array("expected type " . _hx_string_or_null($texpected) . " but it is " . _hx_string_or_null($tvalue)));
			return false;
		}
		$_g = Type::typeof($expected);
		$tmp4 = $_g->index;
		switch($tmp4) {
		case 0:case 1:case 3:{
			if(!_hx_equal($expected, $value)) {
				$tmp5 = Std::string($expected);
				$tmp6 = "expected " . _hx_string_or_null($tmp5) . " but it is ";
				$tmp7 = Std::string($value);
				$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp6) . _hx_string_or_null($tmp7)));
				return false;
			}
			return true;
		}break;
		case 2:{
			$tmp8 = !thx_Floats::nearEquals($expected, $value, null);
			if($tmp8) {
				$tmp9 = Std::string($expected);
				$tmp10 = "expected " . _hx_string_or_null($tmp9) . " but it is ";
				$tmp11 = Std::string($value);
				$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp10) . _hx_string_or_null($tmp11)));
				return false;
			}
			return true;
		}break;
		case 4:{
			$tmp12 = null;
			if(!$status->recursive) {
				$tmp12 = $status->path === "";
			} else {
				$tmp12 = true;
			}
			if($tmp12) {
				$tfields = Reflect::fields($value);
				$fields = Reflect::fields($expected);
				$path = $status->path;
				{
					$_g1 = 0;
					while($_g1 < $fields->length) {
						$field = $fields[$_g1];
						++$_g1;
						$tfields->remove($field);
						$tmp13 = null;
						if($path === "") {
							$tmp13 = $field;
						} else {
							$tmp13 = "" . _hx_string_or_null($path) . "." . _hx_string_or_null($field);
						}
						$status->path = $tmp13;
						$tmp14 = !_hx_has_field($value, $field);
						if($tmp14) {
							$tmp15 = "expected field " . _hx_string_or_null($status->path) . " does not exist in ";
							$tmp16 = Std::string($value);
							$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp15) . _hx_string_or_null($tmp16)));
							return false;
							unset($tmp16,$tmp15);
						}
						$e = Reflect::field($expected, $field);
						$tmp17 = Reflect::isFunction($e);
						if($tmp17) {
							continue;
						}
						$v = Reflect::field($value, $field);
						$tmp18 = !thx_Assert::sameAs($e, $v, $status);
						if($tmp18) {
							return false;
						}
						unset($v,$tmp18,$tmp17,$tmp14,$tmp13,$field,$e);
					}
				}
				$tmp19 = $tfields->length > 0;
				if($tmp19) {
					$tmp20 = $tfields->join(", ");
					$status->error = call_user_func_array($withPath, array("the tested object has extra field(s) (" . _hx_string_or_null($tmp20) . ") not included in the expected ones"));
					return false;
				}
			}
			$tmp21 = thx_Iterators::isIterator($expected);
			if($tmp21) {
				$tmp22 = !thx_Iterators::isIterator($value);
				if($tmp22) {
					$status->error = call_user_func_array($withPath, array("expected an Iterable"));
					return false;
				}
				$tmp23 = null;
				if(!$status->recursive) {
					$tmp23 = $status->path === "";
				} else {
					$tmp23 = true;
				}
				if($tmp23) {
					$evalues = thx_Iterators::toArray($expected);
					$vvalues = thx_Iterators::toArray($value);
					$tmp24 = $evalues->length !== $vvalues->length;
					if($tmp24) {
						$tmp25 = "expected " . _hx_string_rec($evalues->length, "") . " values in Iterator but they are " . _hx_string_rec($vvalues->length, "");
						$status->error = call_user_func_array($withPath, array($tmp25));
						return false;
					}
					$path1 = $status->path;
					{
						$_g11 = 0;
						$_g2 = $evalues->length;
						while($_g11 < $_g2) {
							$i = $_g11++;
							$tmp26 = null;
							if($path1 === "") {
								$tmp26 = "iterator[" . _hx_string_rec($i, "") . "]";
							} else {
								$tmp26 = _hx_string_or_null($path1) . _hx_string_or_null(("[" . _hx_string_rec($i, "") . "]"));
							}
							$status->path = $tmp26;
							$tmp27 = !thx_Assert::sameAs($evalues[$i], $vvalues[$i], $status);
							if($tmp27) {
								$tmp28 = Std::string($expected);
								$tmp29 = "expected " . _hx_string_or_null($tmp28) . " but it is ";
								$tmp30 = Std::string($value);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp29) . _hx_string_or_null($tmp30)));
								return false;
								unset($tmp30,$tmp29,$tmp28);
							}
							unset($tmp27,$tmp26,$i);
						}
					}
				}
				return true;
			}
			$tmp31 = thx_Iterables::isIterable($expected);
			if($tmp31) {
				$tmp32 = !thx_Iterables::isIterable($value);
				if($tmp32) {
					$status->error = call_user_func_array($withPath, array("expected an Iterator"));
					return false;
				}
				$tmp33 = null;
				if(!$status->recursive) {
					$tmp33 = $status->path === "";
				} else {
					$tmp33 = true;
				}
				if($tmp33) {
					$tmp34 = $expected->iterator();
					$evalues1 = thx_Iterators::toArray($tmp34);
					$tmp35 = $value->iterator();
					$vvalues1 = thx_Iterators::toArray($tmp35);
					$tmp36 = $evalues1->length !== $vvalues1->length;
					if($tmp36) {
						$tmp37 = "expected " . _hx_string_rec($evalues1->length, "") . " values in Iterable but they are " . _hx_string_rec($vvalues1->length, "");
						$status->error = call_user_func_array($withPath, array($tmp37));
						return false;
					}
					$path2 = $status->path;
					{
						$_g12 = 0;
						$_g3 = $evalues1->length;
						while($_g12 < $_g3) {
							$i1 = $_g12++;
							$tmp38 = null;
							if($path2 === "") {
								$tmp38 = "iterable[" . _hx_string_rec($i1, "") . "]";
							} else {
								$tmp38 = _hx_string_or_null($path2) . _hx_string_or_null(("[" . _hx_string_rec($i1, "") . "]"));
							}
							$status->path = $tmp38;
							$tmp39 = !thx_Assert::sameAs($evalues1[$i1], $vvalues1[$i1], $status);
							if($tmp39) {
								return false;
							}
							unset($tmp39,$tmp38,$i1);
						}
					}
				}
				return true;
			}
			return true;
		}break;
		case 5:{
			$tmp40 = !Reflect::compareMethods($expected, $value);
			if($tmp40) {
				$status->error = call_user_func_array($withPath, array("expected same function reference"));
				return false;
			}
			return true;
		}break;
		case 6:{
			$c = _hx_deref($_g)->params[0];
			$tmp41 = null;
			$tmp42 = Std::is($expected, _hx_qtype("String"));
			if($tmp42) {
				$tmp41 = !_hx_equal($expected, $value);
			} else {
				$tmp41 = false;
			}
			if($tmp41) {
				$tmp43 = thx_Strings::quote($expected);
				$tmp44 = "expected " . _hx_string_or_null($tmp43) . " but it is ";
				$tmp45 = thx_Strings::quote($value);
				$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp44) . _hx_string_or_null($tmp45)));
				return false;
			}
			$tmp46 = Std::is($expected, _hx_qtype("Array"));
			if($tmp46) {
				$tmp47 = null;
				if(!$status->recursive) {
					$tmp47 = $status->path === "";
				} else {
					$tmp47 = true;
				}
				if($tmp47) {
					$tmp48 = !_hx_equal(_hx_len($expected), _hx_len($value));
					if($tmp48) {
						$tmp49 = Std::string(_hx_len($expected));
						$tmp50 = "expected " . _hx_string_or_null($tmp49) . " elements but they are ";
						$tmp51 = Std::string(_hx_len($value));
						$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp50) . _hx_string_or_null($tmp51)));
						return false;
					}
					$path3 = $status->path;
					{
						$_g13 = 0;
						$_g4 = _hx_len($expected);
						while($_g13 < $_g4) {
							$i2 = $_g13++;
							$tmp52 = null;
							if($path3 === "") {
								$tmp52 = "array[" . _hx_string_rec($i2, "") . "]";
							} else {
								$tmp52 = _hx_string_or_null($path3) . _hx_string_or_null(("[" . _hx_string_rec($i2, "") . "]"));
							}
							$status->path = $tmp52;
							$tmp53 = !thx_Assert::sameAs($expected[$i2], $value[$i2], $status);
							if($tmp53) {
								$tmp54 = Std::string($expected[$i2]);
								$tmp55 = "expected " . _hx_string_or_null($tmp54) . " but it is ";
								$tmp56 = Std::string($value[$i2]);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp55) . _hx_string_or_null($tmp56)));
								return false;
								unset($tmp56,$tmp55,$tmp54);
							}
							unset($tmp53,$tmp52,$i2);
						}
					}
				}
				return true;
			}
			$tmp57 = Std::is($expected, _hx_qtype("Date"));
			if($tmp57) {
				$tmp58 = $expected->getTime();
				$tmp59 = $value->getTime();
				if($tmp58 !== $tmp59) {
					$tmp60 = Std::string($expected);
					$tmp61 = "expected " . _hx_string_or_null($tmp60) . " but it is ";
					$tmp62 = Std::string($value);
					$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp61) . _hx_string_or_null($tmp62)));
					return false;
				}
				return true;
			}
			$tmp63 = Std::is($expected, _hx_qtype("haxe.io.Bytes"));
			if($tmp63) {
				$tmp64 = null;
				if(!$status->recursive) {
					$tmp64 = $status->path === "";
				} else {
					$tmp64 = true;
				}
				if($tmp64) {
					$ebytes = $expected;
					$vbytes = $value;
					if($ebytes->length !== $vbytes->length) {
						return false;
					}
					{
						$_g14 = 0;
						$_g5 = $ebytes->length;
						while($_g14 < $_g5) {
							$i3 = $_g14++;
							$tmp65 = ord($ebytes->b->s[$i3]);
							$tmp66 = ord($vbytes->b->s[$i3]);
							if($tmp65 !== $tmp66) {
								$tmp67 = ord($ebytes->b->s[$i3]);
								$tmp68 = "expected byte " . _hx_string_rec($tmp67, "") . " but it is ";
								$tmp69 = ord($vbytes->b->s[$i3]);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp68) . _hx_string_rec($tmp69, "")));
								return false;
								unset($tmp69,$tmp68,$tmp67);
							}
							unset($tmp66,$tmp65,$i3);
						}
					}
				}
				return true;
			}
			$tmp70 = Std::is($expected, _hx_qtype("haxe.IMap"));
			if($tmp70) {
				$tmp71 = null;
				if(!$status->recursive) {
					$tmp71 = $status->path === "";
				} else {
					$tmp71 = true;
				}
				if($tmp71) {
					$map = $expected;
					$vmap = $value;
					$_g6 = (new _hx_array(array()));
					{
						$tmp72 = $map->keys();
						while(true) {
							$tmp73 = !$tmp72->hasNext();
							if($tmp73) {
								break;
							}
							$k = $tmp72->next();
							$_g6->push($k);
							unset($tmp73,$k);
						}
					}
					$keys = $_g6;
					$_g15 = (new _hx_array(array()));
					{
						$tmp74 = $vmap->keys();
						while(true) {
							$tmp75 = !$tmp74->hasNext();
							if($tmp75) {
								break;
							}
							$k1 = $tmp74->next();
							$_g15->push($k1);
							unset($tmp75,$k1);
						}
					}
					$vkeys = $_g15;
					$tmp76 = $keys->length !== $vkeys->length;
					if($tmp76) {
						$tmp77 = "expected " . _hx_string_rec($keys->length, "") . " keys but they are " . _hx_string_rec($vkeys->length, "");
						$status->error = call_user_func_array($withPath, array($tmp77));
						return false;
					}
					$path4 = $status->path;
					{
						$_g21 = 0;
						while($_g21 < $keys->length) {
							$key = $keys[$_g21];
							++$_g21;
							$tmp78 = null;
							if($path4 === "") {
								$tmp79 = Std::string($key);
								$tmp78 = "hash[" . _hx_string_or_null($tmp79) . "]";
								unset($tmp79);
							} else {
								$tmp80 = Std::string($key);
								$tmp78 = _hx_string_or_null($path4) . _hx_string_or_null(("[" . _hx_string_or_null($tmp80) . "]"));
								unset($tmp80);
							}
							$status->path = $tmp78;
							$tmp81 = $map->get($key);
							$tmp82 = $vmap->get($key);
							$tmp83 = !thx_Assert::sameAs($tmp81, $tmp82, $status);
							if($tmp83) {
								$tmp84 = Std::string($expected);
								$tmp85 = "expected " . _hx_string_or_null($tmp84) . " but it is ";
								$tmp86 = Std::string($value);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp85) . _hx_string_or_null($tmp86)));
								return false;
								unset($tmp86,$tmp85,$tmp84);
							}
							unset($tmp83,$tmp82,$tmp81,$tmp78,$key);
						}
					}
				}
				return true;
			}
			$tmp87 = thx_Iterators::isIterator($expected);
			if($tmp87) {
				$tmp88 = null;
				if(!$status->recursive) {
					$tmp88 = $status->path === "";
				} else {
					$tmp88 = true;
				}
				if($tmp88) {
					$evalues2 = thx_Iterators::toArray($expected);
					$vvalues2 = thx_Iterators::toArray($value);
					$tmp89 = $evalues2->length !== $vvalues2->length;
					if($tmp89) {
						$tmp90 = "expected " . _hx_string_rec($evalues2->length, "") . " values in Iterator but they are " . _hx_string_rec($vvalues2->length, "");
						$status->error = call_user_func_array($withPath, array($tmp90));
						return false;
					}
					$path5 = $status->path;
					{
						$_g16 = 0;
						$_g7 = $evalues2->length;
						while($_g16 < $_g7) {
							$i4 = $_g16++;
							$tmp91 = null;
							if($path5 === "") {
								$tmp91 = "iterator[" . _hx_string_rec($i4, "") . "]";
							} else {
								$tmp91 = _hx_string_or_null($path5) . _hx_string_or_null(("" . _hx_string_or_null($path5) . "[" . _hx_string_rec($i4, "") . "]"));
							}
							$status->path = $tmp91;
							$tmp92 = !thx_Assert::sameAs($evalues2[$i4], $vvalues2[$i4], $status);
							if($tmp92) {
								$tmp93 = Std::string($expected);
								$tmp94 = "expected " . _hx_string_or_null($tmp93) . " but it is ";
								$tmp95 = Std::string($value);
								$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp94) . _hx_string_or_null($tmp95)));
								return false;
								unset($tmp95,$tmp94,$tmp93);
							}
							unset($tmp92,$tmp91,$i4);
						}
					}
				}
				return true;
			}
			$tmp96 = thx_Iterables::isIterable($expected);
			if($tmp96) {
				$tmp97 = null;
				if(!$status->recursive) {
					$tmp97 = $status->path === "";
				} else {
					$tmp97 = true;
				}
				if($tmp97) {
					$tmp98 = $expected->iterator();
					$evalues3 = thx_Iterators::toArray($tmp98);
					$tmp99 = $value->iterator();
					$vvalues3 = thx_Iterators::toArray($tmp99);
					$tmp100 = $evalues3->length !== $vvalues3->length;
					if($tmp100) {
						$tmp101 = "expected " . _hx_string_rec($evalues3->length, "") . " values in Iterable but they are " . _hx_string_rec($vvalues3->length, "");
						$status->error = call_user_func_array($withPath, array($tmp101));
						return false;
					}
					$path6 = $status->path;
					{
						$_g17 = 0;
						$_g8 = $evalues3->length;
						while($_g17 < $_g8) {
							$i5 = $_g17++;
							$tmp102 = null;
							if($path6 === "") {
								$tmp102 = "iterable[" . _hx_string_rec($i5, "") . "]";
							} else {
								$tmp102 = _hx_string_or_null($path6) . _hx_string_or_null(("[" . _hx_string_rec($i5, "") . "]"));
							}
							$status->path = $tmp102;
							$tmp103 = !thx_Assert::sameAs($evalues3[$i5], $vvalues3[$i5], $status);
							if($tmp103) {
								return false;
							}
							unset($tmp103,$tmp102,$i5);
						}
					}
				}
				return true;
			}
			$tmp104 = null;
			if(!$status->recursive) {
				$tmp104 = $status->path === "";
			} else {
				$tmp104 = true;
			}
			if($tmp104) {
				$tmp105 = Type::getClass($expected);
				$fields1 = Type::getInstanceFields($tmp105);
				$path7 = $status->path;
				{
					$_g9 = 0;
					while($_g9 < $fields1->length) {
						$field1 = $fields1[$_g9];
						++$_g9;
						$tmp106 = null;
						if($path7 === "") {
							$tmp106 = $field1;
						} else {
							$tmp106 = "" . _hx_string_or_null($path7) . "." . _hx_string_or_null($field1);
						}
						$status->path = $tmp106;
						$e1 = Reflect::field($expected, $field1);
						$tmp107 = Reflect::isFunction($e1);
						if($tmp107) {
							continue;
						}
						$v1 = Reflect::field($value, $field1);
						$tmp108 = !thx_Assert::sameAs($e1, $v1, $status);
						if($tmp108) {
							return false;
						}
						unset($v1,$tmp108,$tmp107,$tmp106,$field1,$e1);
					}
				}
			}
			return true;
		}break;
		case 7:{
			$eexpected = Type::getEnumName(_hx_deref($_g)->params[0]);
			$tmp109 = Type::getEnum($value);
			$evalue = Type::getEnumName($tmp109);
			if($eexpected !== $evalue) {
				$status->error = call_user_func_array($withPath, array("expected enumeration of " . _hx_string_or_null($eexpected) . " but it is " . _hx_string_or_null($evalue)));
				return false;
			}
			$tmp110 = null;
			if(!$status->recursive) {
				$tmp110 = $status->path === "";
			} else {
				$tmp110 = true;
			}
			if($tmp110) {
				$tmp111 = $expected->index !== $value->index;
				if($tmp111) {
					$status->error = call_user_func_array($withPath, array("expected " . _hx_string_or_null(Type::enumConstructor($expected)) . " but it is " . _hx_string_or_null(Type::enumConstructor($value))));
					return false;
				}
				$eparams = Type::enumParameters($expected);
				$vparams = Type::enumParameters($value);
				$path8 = $status->path;
				{
					$_g18 = 0;
					$_g10 = $eparams->length;
					while($_g18 < $_g10) {
						$i6 = $_g18++;
						$tmp112 = null;
						if($path8 === "") {
							$tmp112 = "enum[" . _hx_string_rec($i6, "") . "]";
						} else {
							$tmp112 = _hx_string_or_null($path8) . _hx_string_or_null(("[" . _hx_string_rec($i6, "") . "]"));
						}
						$status->path = $tmp112;
						$tmp113 = !thx_Assert::sameAs($eparams[$i6], $vparams[$i6], $status);
						if($tmp113) {
							$tmp114 = Std::string($expected);
							$tmp115 = "expected " . _hx_string_or_null($tmp114) . " but it is ";
							$tmp116 = Std::string($value);
							$status->error = call_user_func_array($withPath, array(_hx_string_or_null($tmp115) . _hx_string_or_null($tmp116)));
							return false;
							unset($tmp116,$tmp115,$tmp114);
						}
						unset($tmp113,$tmp112,$i6);
					}
				}
			}
			return true;
		}break;
		case 8:{
			throw new HException("Unable to compare two unknown types");
		}break;
		}
	}
	function __toString() { return 'thx.Assert'; }
}
thx_Assert::$behavior = new thx_DefaultAssertBehavior();
function thx_Assert_0(&$status, $msg) {
	{
		$tmp = null;
		if(thx_Strings::isEmpty($status->path)) {
			$tmp = "";
		} else {
			$tmp = " at " . _hx_string_or_null($status->path);
		}
		return _hx_string_or_null($msg) . _hx_string_or_null($tmp);
	}
}
