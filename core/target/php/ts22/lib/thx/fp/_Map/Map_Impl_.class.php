<?php

// Generated by Haxe 3.3.0
class thx_fp__Map_Map_Impl_ {
	public function __construct(){}
	static function hempty() {
		return thx_fp_MapImpl::$Tip;
	}
	static function singleton($k, $v) {
		return thx_fp_MapImpl::Bin(1, $k, $v, thx_fp_MapImpl::$Tip, thx_fp_MapImpl::$Tip);
	}
	static function bin($k, $v, $lhs, $rhs) {
		return thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($lhs) + thx_fp__Map_Map_Impl_::size($rhs) + 1, $k, $v, $lhs, $rhs);
	}
	static function fromNative($map, $comparator) {
		$r = thx_fp_MapImpl::$Tip;
		{
			$tmp = $map->keys();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$key = $tmp->next();
				$tmp2 = $map->get($key);
				$r = thx_fp__Map_Map_Impl_::insert($r, $key, $tmp2, $comparator);
				unset($tmp2,$tmp1,$key);
			}
		}
		return $r;
	}
	static function lookup($this1, $key, $comparator) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return haxe_ds_Option::$None;
		}break;
		case 1:{
			$rhs = _hx_deref($this1)->params[4];
			$lhs = _hx_deref($this1)->params[3];
			$xvalue = _hx_deref($this1)->params[2];
			$c = call_user_func_array($comparator, array($key, _hx_deref($this1)->params[1]));
			$tmp1 = $c->index;
			switch($tmp1) {
			case 0:{
				return thx_fp__Map_Map_Impl_::lookup($lhs, $key, $comparator);
			}break;
			case 1:{
				return thx_fp__Map_Map_Impl_::lookup($rhs, $key, $comparator);
			}break;
			case 2:{
				return haxe_ds_Option::Some($xvalue);
			}break;
			}
		}break;
		}
	}
	static function lookupTuple($this1, $key, $comparator) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return haxe_ds_Option::$None;
		}break;
		case 1:{
			$rhs = _hx_deref($this1)->params[4];
			$lhs = _hx_deref($this1)->params[3];
			$xvalue = _hx_deref($this1)->params[2];
			$xkey = _hx_deref($this1)->params[1];
			$c = call_user_func_array($comparator, array($key, $xkey));
			$tmp1 = $c->index;
			switch($tmp1) {
			case 0:{
				return thx_fp__Map_Map_Impl_::lookupTuple($lhs, $key, $comparator);
			}break;
			case 1:{
				return thx_fp__Map_Map_Impl_::lookupTuple($rhs, $key, $comparator);
			}break;
			case 2:{
				return haxe_ds_Option::Some(_hx_anonymous(array("_0" => $xkey, "_1" => $xvalue)));
			}break;
			}
		}break;
		}
	}
	static function delete($this1, $key, $comparator) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return thx_fp_MapImpl::$Tip;
		}break;
		case 1:{
			$rhs = _hx_deref($this1)->params[4];
			$lhs = _hx_deref($this1)->params[3];
			$x = _hx_deref($this1)->params[2];
			$kx = _hx_deref($this1)->params[1];
			$_g = call_user_func_array($comparator, array($key, $kx));
			$tmp1 = $_g->index;
			switch($tmp1) {
			case 0:{
				$tmp2 = thx_fp__Map_Map_Impl_::delete($lhs, $key, $comparator);
				return thx_fp__Map_Map_Impl_::balance($kx, $x, $tmp2, $rhs);
			}break;
			case 1:{
				$tmp3 = thx_fp__Map_Map_Impl_::delete($rhs, $key, $comparator);
				return thx_fp__Map_Map_Impl_::balance($kx, $x, $lhs, $tmp3);
			}break;
			case 2:{
				return thx_fp__Map_Map_Impl_::glue($lhs, $rhs);
			}break;
			}
		}break;
		}
	}
	static function insert($this1, $kx, $x, $comparator) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return thx_fp_MapImpl::Bin(1, $kx, $x, thx_fp_MapImpl::$Tip, thx_fp_MapImpl::$Tip);
		}break;
		case 1:{
			$rhs = _hx_deref($this1)->params[4];
			$lhs = _hx_deref($this1)->params[3];
			$y = _hx_deref($this1)->params[2];
			$ky = _hx_deref($this1)->params[1];
			$sz = _hx_deref($this1)->params[0];
			$_g = call_user_func_array($comparator, array($kx, $ky));
			$tmp1 = $_g->index;
			switch($tmp1) {
			case 0:{
				$tmp2 = thx_fp__Map_Map_Impl_::insert($lhs, $kx, $x, $comparator);
				return thx_fp__Map_Map_Impl_::balance($ky, $y, $tmp2, $rhs);
			}break;
			case 1:{
				$tmp3 = thx_fp__Map_Map_Impl_::insert($rhs, $kx, $x, $comparator);
				return thx_fp__Map_Map_Impl_::balance($ky, $y, $lhs, $tmp3);
			}break;
			case 2:{
				return thx_fp_MapImpl::Bin($sz, $kx, $x, $lhs, $rhs);
			}break;
			}
		}break;
		}
	}
	static function foldLeft($this1, $b, $f) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return $b;
		}break;
		case 1:{
			$r = _hx_deref($this1)->params[4];
			$l = _hx_deref($this1)->params[3];
			$tmp1 = call_user_func_array($f, array($b, _hx_deref($this1)->params[2]));
			$tmp2 = thx_fp__Map_Map_Impl_::foldLeft($l, $tmp1, $f);
			return thx_fp__Map_Map_Impl_::foldLeft($r, $tmp2, $f);
		}break;
		}
	}
	static function map($this1, $f) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return thx_fp_MapImpl::$Tip;
		}break;
		case 1:{
			$rhs = _hx_deref($this1)->params[4];
			$lhs = _hx_deref($this1)->params[3];
			$y = _hx_deref($this1)->params[2];
			$ky = _hx_deref($this1)->params[1];
			$sz = _hx_deref($this1)->params[0];
			$tmp1 = call_user_func_array($f, array($y));
			$tmp2 = thx_fp__Map_Map_Impl_::map($lhs, $f);
			$tmp3 = thx_fp__Map_Map_Impl_::map($rhs, $f);
			return thx_fp_MapImpl::Bin($sz, $ky, $tmp1, $tmp2, $tmp3);
		}break;
		}
	}
	static function values($this1) {
		return thx_fp__Map_Map_Impl_::foldLeft($this1, (new _hx_array(array())), array(new _hx_lambda(array(), "thx_fp__Map_Map_Impl__0"), 'execute'));
	}
	static function foldLeftKeys($this1, $b, $f) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return $b;
		}break;
		case 1:{
			$r = _hx_deref($this1)->params[4];
			$l = _hx_deref($this1)->params[3];
			$tmp1 = call_user_func_array($f, array($b, _hx_deref($this1)->params[1]));
			$tmp2 = thx_fp__Map_Map_Impl_::foldLeftKeys($l, $tmp1, $f);
			return thx_fp__Map_Map_Impl_::foldLeftKeys($r, $tmp2, $f);
		}break;
		}
	}
	static function foldLeftAll($this1, $b, $f) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return $b;
		}break;
		case 1:{
			$r = _hx_deref($this1)->params[4];
			$l = _hx_deref($this1)->params[3];
			$tmp1 = call_user_func_array($f, array($b, _hx_deref($this1)->params[1], _hx_deref($this1)->params[2]));
			$tmp2 = thx_fp__Map_Map_Impl_::foldLeftAll($l, $tmp1, $f);
			return thx_fp__Map_Map_Impl_::foldLeftAll($r, $tmp2, $f);
		}break;
		}
	}
	static function foldLeftTuples($this1, $b, $f) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return $b;
		}break;
		case 1:{
			$r = _hx_deref($this1)->params[4];
			$l = _hx_deref($this1)->params[3];
			$tmp1 = call_user_func_array($f, array($b, _hx_anonymous(array("_0" => _hx_deref($this1)->params[1], "_1" => _hx_deref($this1)->params[2]))));
			$tmp2 = thx_fp__Map_Map_Impl_::foldLeftTuples($l, $tmp1, $f);
			return thx_fp__Map_Map_Impl_::foldLeftTuples($r, $tmp2, $f);
		}break;
		}
	}
	static function size($this1) {
		switch($this1->index) {
		case 0:{
			return 0;
		}break;
		case 1:{
			return _hx_deref($this1)->params[0];
		}break;
		}
	}
	static $delta = 5;
	static $ratio = 2;
	static function balance($k, $x, $lhs, $rhs) {
		$ls = thx_fp__Map_Map_Impl_::size($lhs);
		$rs = thx_fp__Map_Map_Impl_::size($rhs);
		$xs = $ls + $rs + 1;
		if($ls + $rs <= 1) {
			return thx_fp_MapImpl::Bin($xs, $k, $x, $lhs, $rhs);
		} else {
			if($rs >= 5 * $ls) {
				return thx_fp__Map_Map_Impl_::rotateLeft($k, $x, $lhs, $rhs);
			} else {
				if($ls >= 5 * $rs) {
					return thx_fp__Map_Map_Impl_::rotateRight($k, $x, $lhs, $rhs);
				} else {
					return thx_fp_MapImpl::Bin($xs, $k, $x, $lhs, $rhs);
				}
			}
		}
	}
	static function glue($this1, $that) {
		$tmp = $this1->index === 0;
		if($tmp) {
			return $that;
		} else {
			$tmp1 = $that->index === 0;
			if($tmp1) {
				return $this1;
			} else {
				if(thx_fp__Map_Map_Impl_::size($this1) > thx_fp__Map_Map_Impl_::size($that)) {
					$t = thx_fp__Map_Map_Impl_::deleteFindMax($this1);
					return thx_fp__Map_Map_Impl_::balance($t->k, $t->x, $t->t, $that);
				} else {
					$t1 = thx_fp__Map_Map_Impl_::deleteFindMin($that);
					return thx_fp__Map_Map_Impl_::balance($t1->k, $t1->x, $this1, $t1->t);
				}
			}
		}
	}
	static function deleteFindMin($map) {
		$tmp = $map->index;
		switch($tmp) {
		case 0:{
			throw new HException(new thx_Error("can not return the minimal element of an empty map", null, _hx_anonymous(array("fileName" => "Map.hx", "lineNumber" => 161, "className" => "thx.fp._Map.Map_Impl_", "methodName" => "deleteFindMin"))));
		}break;
		case 1:{
			$tmp1 = _hx_deref($map)->params[3]->index === 0;
			if($tmp1) {
				$r = _hx_deref($map)->params[4];
				$k = _hx_deref($map)->params[1];
				$x = _hx_deref($map)->params[2];
				return _hx_anonymous(array("k" => $k, "x" => $x, "t" => $r));
			} else {
				$r1 = _hx_deref($map)->params[4];
				$k1 = _hx_deref($map)->params[1];
				$x1 = _hx_deref($map)->params[2];
				$l = _hx_deref($map)->params[3];
				$t = thx_fp__Map_Map_Impl_::deleteFindMin($l);
				$tmp2 = thx_fp__Map_Map_Impl_::balance($k1, $x1, $t->t, $r1);
				return _hx_anonymous(array("k" => $t->k, "x" => $t->x, "t" => $tmp2));
			}
		}break;
		}
	}
	static function deleteFindMax($map) {
		$tmp = $map->index;
		switch($tmp) {
		case 0:{
			throw new HException(new thx_Error("can not return the maximal element of an empty map", null, _hx_anonymous(array("fileName" => "Map.hx", "lineNumber" => 171, "className" => "thx.fp._Map.Map_Impl_", "methodName" => "deleteFindMax"))));
		}break;
		case 1:{
			$tmp1 = _hx_deref($map)->params[4]->index === 0;
			if($tmp1) {
				$k = _hx_deref($map)->params[1];
				$x = _hx_deref($map)->params[2];
				$l = _hx_deref($map)->params[3];
				return _hx_anonymous(array("k" => $k, "x" => $x, "t" => $l));
			} else {
				$k1 = _hx_deref($map)->params[1];
				$x1 = _hx_deref($map)->params[2];
				$l1 = _hx_deref($map)->params[3];
				$r = _hx_deref($map)->params[4];
				$t = thx_fp__Map_Map_Impl_::deleteFindMax($r);
				$tmp2 = thx_fp__Map_Map_Impl_::balance($k1, $x1, $l1, $t->t);
				return _hx_anonymous(array("k" => $t->k, "x" => $t->x, "t" => $tmp2));
			}
		}break;
		}
	}
	static function rotateLeft($k, $x, $lhs, $rhs) {
		$tmp = $rhs->index === 1;
		if($tmp) {
			$ry = _hx_deref($rhs)->params[4];
			$ly = _hx_deref($rhs)->params[3];
			if(thx_fp__Map_Map_Impl_::size($ly) < 2 * thx_fp__Map_Map_Impl_::size($ry)) {
				return thx_fp__Map_Map_Impl_::singleLeft($k, $x, $lhs, $rhs);
			} else {
				return thx_fp__Map_Map_Impl_::doubleLeft($k, $x, $lhs, $rhs);
			}
		} else {
			return thx_fp__Map_Map_Impl_::doubleLeft($k, $x, $lhs, $rhs);
		}
	}
	static function rotateRight($k, $x, $lhs, $rhs) {
		$tmp = $lhs->index === 1;
		if($tmp) {
			$ry = _hx_deref($lhs)->params[4];
			$ly = _hx_deref($lhs)->params[3];
			if(thx_fp__Map_Map_Impl_::size($ry) < 2 * thx_fp__Map_Map_Impl_::size($ly)) {
				return thx_fp__Map_Map_Impl_::singleRight($k, $x, $lhs, $rhs);
			} else {
				return thx_fp__Map_Map_Impl_::doubleRight($k, $x, $lhs, $rhs);
			}
		} else {
			return thx_fp__Map_Map_Impl_::doubleRight($k, $x, $lhs, $rhs);
		}
	}
	static function singleLeft($k1, $x1, $t1, $rhs) {
		$tmp = $rhs->index === 1;
		if($tmp) {
			$t3 = _hx_deref($rhs)->params[4];
			$t2 = _hx_deref($rhs)->params[3];
			$x2 = _hx_deref($rhs)->params[2];
			$k2 = _hx_deref($rhs)->params[1];
			$lhs = thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($t1) + thx_fp__Map_Map_Impl_::size($t2) + 1, $k1, $x1, $t1, $t2);
			return thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($lhs) + thx_fp__Map_Map_Impl_::size($t3) + 1, $k2, $x2, $lhs, $t3);
		} else {
			throw new HException(new thx_Error("damn it, this should never happen", null, _hx_anonymous(array("fileName" => "Map.hx", "lineNumber" => 193, "className" => "thx.fp._Map.Map_Impl_", "methodName" => "singleLeft"))));
		}
	}
	static function singleRight($k1, $x1, $lhs, $t3) {
		$tmp = $lhs->index === 1;
		if($tmp) {
			$t2 = _hx_deref($lhs)->params[4];
			$t1 = _hx_deref($lhs)->params[3];
			$x2 = _hx_deref($lhs)->params[2];
			$k2 = _hx_deref($lhs)->params[1];
			$rhs = thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($t2) + thx_fp__Map_Map_Impl_::size($t3) + 1, $k1, $x1, $t2, $t3);
			return thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($t1) + thx_fp__Map_Map_Impl_::size($rhs) + 1, $k2, $x2, $t1, $rhs);
		} else {
			throw new HException(new thx_Error("damn it, this should never happen", null, _hx_anonymous(array("fileName" => "Map.hx", "lineNumber" => 199, "className" => "thx.fp._Map.Map_Impl_", "methodName" => "singleRight"))));
		}
	}
	static function doubleLeft($k1, $x1, $t1, $rhs) {
		$tmp = $rhs->index === 1;
		if($tmp) {
			$tmp1 = _hx_deref($rhs)->params[3]->index === 1;
			if($tmp1) {
				$t4 = _hx_deref($rhs)->params[4];
				$k2 = _hx_deref($rhs)->params[1];
				$x2 = _hx_deref($rhs)->params[2];
				$t3 = _hx_deref(_hx_deref($rhs)->params[3])->params[4];
				$t2 = _hx_deref(_hx_deref($rhs)->params[3])->params[3];
				$x3 = _hx_deref(_hx_deref($rhs)->params[3])->params[2];
				$k3 = _hx_deref(_hx_deref($rhs)->params[3])->params[1];
				$lhs = thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($t1) + thx_fp__Map_Map_Impl_::size($t2) + 1, $k1, $x1, $t1, $t2);
				$rhs1 = thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($t3) + thx_fp__Map_Map_Impl_::size($t4) + 1, $k2, $x2, $t3, $t4);
				return thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($lhs) + thx_fp__Map_Map_Impl_::size($rhs1) + 1, $k3, $x3, $lhs, $rhs1);
			} else {
				throw new HException(new thx_Error("damn it, this should never happen", null, _hx_anonymous(array("fileName" => "Map.hx", "lineNumber" => 206, "className" => "thx.fp._Map.Map_Impl_", "methodName" => "doubleLeft"))));
			}
		} else {
			throw new HException(new thx_Error("damn it, this should never happen", null, _hx_anonymous(array("fileName" => "Map.hx", "lineNumber" => 206, "className" => "thx.fp._Map.Map_Impl_", "methodName" => "doubleLeft"))));
		}
	}
	static function doubleRight($k1, $x1, $lhs, $t4) {
		$tmp = $lhs->index === 1;
		if($tmp) {
			$tmp1 = _hx_deref($lhs)->params[4]->index === 1;
			if($tmp1) {
				$k2 = _hx_deref($lhs)->params[1];
				$x2 = _hx_deref($lhs)->params[2];
				$t1 = _hx_deref($lhs)->params[3];
				$t3 = _hx_deref(_hx_deref($lhs)->params[4])->params[4];
				$t2 = _hx_deref(_hx_deref($lhs)->params[4])->params[3];
				$x3 = _hx_deref(_hx_deref($lhs)->params[4])->params[2];
				$k3 = _hx_deref(_hx_deref($lhs)->params[4])->params[1];
				$lhs1 = thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($t1) + thx_fp__Map_Map_Impl_::size($t2) + 1, $k2, $x2, $t1, $t2);
				$rhs = thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($t3) + thx_fp__Map_Map_Impl_::size($t4) + 1, $k1, $x1, $t3, $t4);
				return thx_fp_MapImpl::Bin(thx_fp__Map_Map_Impl_::size($lhs1) + thx_fp__Map_Map_Impl_::size($rhs) + 1, $k3, $x3, $lhs1, $rhs);
			} else {
				throw new HException(new thx_Error("damn it, this should never happen", null, _hx_anonymous(array("fileName" => "Map.hx", "lineNumber" => 213, "className" => "thx.fp._Map.Map_Impl_", "methodName" => "doubleRight"))));
			}
		} else {
			throw new HException(new thx_Error("damn it, this should never happen", null, _hx_anonymous(array("fileName" => "Map.hx", "lineNumber" => 213, "className" => "thx.fp._Map.Map_Impl_", "methodName" => "doubleRight"))));
		}
	}
	function __toString() { return 'thx.fp._Map.Map_Impl_'; }
}
function thx_fp__Map_Map_Impl__0($acc, $v) {
	{
		$acc->push($v);
		return $acc;
	}
}
