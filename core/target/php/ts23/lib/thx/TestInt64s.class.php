<?php

// Generated by Haxe 3.3.0
class thx_TestInt64s {
	public function __construct($i) {
		if(!php_Boot::$skip_constructor) {
		$this->x = $i;
	}}
	public $x;
	public function testRounding() {
		$_g1 = 0;
		$_g = $this->x;
		while($_g1 < $_g) {
			++$_g1;
			$tests = (new _hx_array(array(_hx_anonymous(array("roundUp" => 3, "roundDown" => 2, "round" => 3, "num" => 5, "div" => 2, "pos" => _hx_anonymous(array("fileName" => "TestInt64s.hx", "lineNumber" => 21, "className" => "thx.TestInt64s", "methodName" => "testRounding")))), _hx_anonymous(array("roundUp" => 0, "roundDown" => 0, "round" => 0, "num" => 0, "div" => 2, "pos" => _hx_anonymous(array("fileName" => "TestInt64s.hx", "lineNumber" => 22, "className" => "thx.TestInt64s", "methodName" => "testRounding")))), _hx_anonymous(array("roundUp" => 1, "roundDown" => 0, "round" => 0, "num" => 1, "div" => 4, "pos" => _hx_anonymous(array("fileName" => "TestInt64s.hx", "lineNumber" => 23, "className" => "thx.TestInt64s", "methodName" => "testRounding")))), _hx_anonymous(array("roundUp" => -2, "roundDown" => -3, "round" => -2, "num" => -5, "div" => 2, "pos" => _hx_anonymous(array("fileName" => "TestInt64s.hx", "lineNumber" => 25, "className" => "thx.TestInt64s", "methodName" => "testRounding")))), _hx_anonymous(array("roundUp" => 0, "roundDown" => -1, "round" => 0, "num" => -1, "div" => 4, "pos" => _hx_anonymous(array("fileName" => "TestInt64s.hx", "lineNumber" => 26, "className" => "thx.TestInt64s", "methodName" => "testRounding")))), _hx_anonymous(array("roundUp" => 0, "roundDown" => 0, "round" => 0, "num" => 0, "div" => -2, "pos" => _hx_anonymous(array("fileName" => "TestInt64s.hx", "lineNumber" => 28, "className" => "thx.TestInt64s", "methodName" => "testRounding")))), _hx_anonymous(array("roundUp" => -2, "roundDown" => -3, "round" => -2, "num" => 5, "div" => -2, "pos" => _hx_anonymous(array("fileName" => "TestInt64s.hx", "lineNumber" => 29, "className" => "thx.TestInt64s", "methodName" => "testRounding")))), _hx_anonymous(array("roundUp" => 0, "roundDown" => -1, "round" => 0, "num" => 1, "div" => -4, "pos" => _hx_anonymous(array("fileName" => "TestInt64s.hx", "lineNumber" => 30, "className" => "thx.TestInt64s", "methodName" => "testRounding")))))));
			$up = null;
			$down = null;
			$round = null;
			$num = null;
			$div = null;
			{
				$_g2 = 0;
				while($_g2 < $tests->length) {
					$test = $tests[$_g2];
					++$_g2;
					$x = $test->roundUp;
					$x1 = new haxe__Int64____Int64($x >> 31, $x);
					$up = $x1;
					$x2 = $test->roundDown;
					$x3 = new haxe__Int64____Int64($x2 >> 31, $x2);
					$down = $x3;
					$x4 = $test->round;
					$x5 = new haxe__Int64____Int64($x4 >> 31, $x4);
					$round = $x5;
					$x6 = $test->num;
					$x7 = new haxe__Int64____Int64($x6 >> 31, $x6);
					$num = $x7;
					$x8 = $test->div;
					$x9 = new haxe__Int64____Int64($x8 >> 31, $x8);
					$div = $x9;
					$b = thx_Int64s::divRound($num, $div);
					$tmp = null;
					if($round->high === $b->high) {
						$tmp = $round->low === $b->low;
					} else {
						$tmp = false;
					}
					$tmp1 = haxe__Int64_Int64_Impl_::toString($round);
					$tmp2 = "expected " . _hx_string_or_null($tmp1) . " but got ";
					$tmp3 = thx_Int64s::divRound($num, $div);
					$tmp4 = haxe__Int64_Int64_Impl_::toString($tmp3);
					$tmp5 = _hx_string_or_null($tmp2) . _hx_string_or_null($tmp4) . " from ";
					$tmp6 = haxe__Int64_Int64_Impl_::toString($num);
					$tmp7 = _hx_string_or_null($tmp5) . _hx_string_or_null($tmp6) . ".divRound(";
					$tmp8 = haxe__Int64_Int64_Impl_::toString($div);
					utest_Assert::isTrue($tmp, _hx_string_or_null($tmp7) . _hx_string_or_null($tmp8) . ")", $test->pos);
					$b1 = thx_Int64s::divCeil($num, $div);
					$tmp9 = null;
					if($up->high === $b1->high) {
						$tmp9 = $up->low === $b1->low;
					} else {
						$tmp9 = false;
					}
					$tmp10 = haxe__Int64_Int64_Impl_::toString($up);
					$tmp11 = "expected " . _hx_string_or_null($tmp10) . " but got ";
					$tmp12 = thx_Int64s::divCeil($num, $div);
					$tmp13 = haxe__Int64_Int64_Impl_::toString($tmp12);
					$tmp14 = _hx_string_or_null($tmp11) . _hx_string_or_null($tmp13) . " from ";
					$tmp15 = haxe__Int64_Int64_Impl_::toString($num);
					$tmp16 = _hx_string_or_null($tmp14) . _hx_string_or_null($tmp15) . ".divCeil(";
					$tmp17 = haxe__Int64_Int64_Impl_::toString($div);
					utest_Assert::isTrue($tmp9, _hx_string_or_null($tmp16) . _hx_string_or_null($tmp17) . ")", $test->pos);
					$b2 = thx_Int64s::divFloor($num, $div);
					$tmp18 = null;
					if($down->high === $b2->high) {
						$tmp18 = $down->low === $b2->low;
					} else {
						$tmp18 = false;
					}
					$tmp19 = haxe__Int64_Int64_Impl_::toString($down);
					$tmp20 = "expected " . _hx_string_or_null($tmp19) . " but got ";
					$tmp21 = thx_Int64s::divFloor($num, $div);
					$tmp22 = haxe__Int64_Int64_Impl_::toString($tmp21);
					$tmp23 = _hx_string_or_null($tmp20) . _hx_string_or_null($tmp22) . " from ";
					$tmp24 = haxe__Int64_Int64_Impl_::toString($num);
					$tmp25 = _hx_string_or_null($tmp23) . _hx_string_or_null($tmp24) . ".divFloor(";
					$tmp26 = haxe__Int64_Int64_Impl_::toString($div);
					utest_Assert::isTrue($tmp18, _hx_string_or_null($tmp25) . _hx_string_or_null($tmp26) . ")", $test->pos);
					unset($x9,$x8,$x7,$x6,$x5,$x4,$x3,$x2,$x1,$x,$tmp9,$tmp8,$tmp7,$tmp6,$tmp5,$tmp4,$tmp3,$tmp26,$tmp25,$tmp24,$tmp23,$tmp22,$tmp21,$tmp20,$tmp2,$tmp19,$tmp18,$tmp17,$tmp16,$tmp15,$tmp14,$tmp13,$tmp12,$tmp11,$tmp10,$tmp1,$tmp,$test,$b2,$b1,$b);
				}
				unset($_g2);
			}
			unset($up,$tests,$round,$num,$down,$div);
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function here($pos = null) {
		return $pos;
	}
	function __toString() { return 'thx.TestInt64s'; }
}
