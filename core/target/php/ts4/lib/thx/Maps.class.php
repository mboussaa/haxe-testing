<?php

// Generated by Haxe 3.3.0
class thx_Maps {
	public function __construct(){}
	static function copyTo($src, $dst) {
		{
			$tmp = $src->keys();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$key = $tmp->next();
				$tmp2 = $src->get($key);
				$dst->set($key, $tmp2);
				unset($tmp2,$tmp1,$key);
			}
		}
		return $dst;
	}
	static function tuples($map) {
		$tmp = $map->keys();
		return thx_Iterators::map($tmp, array(new _hx_lambda(array(&$map), "thx_Maps_0"), 'execute'));
	}
	static function mapValues($map, $f, $acc) {
		return thx_Maps::reduce($map, array(new _hx_lambda(array(&$f), "thx_Maps_1"), 'execute'), $acc);
	}
	static function reduce($map, $f, $acc) {
		$tmp = thx_Maps::tuples($map);
		return thx_Arrays::reduce($tmp, $f, $acc);
	}
	static function values($map) {
		$tmp = $map->keys();
		return thx_Iterators::map($tmp, array(new _hx_lambda(array(&$map), "thx_Maps_2"), 'execute'));
	}
	static function foldLeftWithKeys($map, $f, $acc) {
		$tmp = $map->keys();
		return thx_Iterators::reduce($tmp, array(new _hx_lambda(array(&$f, &$map), "thx_Maps_3"), 'execute'), $acc);
	}
	static function getOption($map, $key) {
		$value = $map->get($key);
		if(null === $value) {
			return haxe_ds_Option::$None;
		} else {
			return haxe_ds_Option::Some($value);
		}
	}
	static function toObject($map) {
		$tmp = thx_Maps::tuples($map);
		return thx_Arrays::reduce($tmp, array(new _hx_lambda(array(), "thx_Maps_4"), 'execute'), _hx_anonymous(array()));
	}
	static function getAlt($map, $key, $alt) {
		$v = $map->get($key);
		if(null === $v) {
			return $alt;
		} else {
			return $v;
		}
	}
	static function isMap($v) {
		return Std::is($v, _hx_qtype("haxe.IMap"));
	}
	static function string($m) {
		$tmp = thx_Maps::tuples($m)->map(array(new _hx_lambda(array(), "thx_Maps_5"), 'execute'))->join(", ");
		return "[" . _hx_string_or_null($tmp) . "]";
	}
	static function merge($dest, $sources) {
		return thx_Arrays::reduce($sources, array(new _hx_lambda(array(), "thx_Maps_6"), 'execute'), $dest);
	}
	function __toString() { return 'thx.Maps'; }
}
function thx_Maps_0(&$map, $key) {
	{
		$_1 = $map->get($key);
		return _hx_anonymous(array("_0" => $key, "_1" => $_1));
	}
}
function thx_Maps_1(&$f, $m, $t) {
	{
		{
			$value = call_user_func_array($f, array($t->_1));
			$m->set($t->_0, $value);
		}
		return $m;
	}
}
function thx_Maps_2(&$map, $key) {
	{
		return $map->get($key);
	}
}
function thx_Maps_3(&$f, &$map, $acc1, $k) {
	{
		return call_user_func_array($f, array($acc1, $k, $map->get($k)));
	}
}
function thx_Maps_4($o, $t) {
	{
		$o->{$t->_0} = $t->_1;
		return $o;
	}
}
function thx_Maps_5($t) {
	{
		$tmp1 = thx_Dynamics::string($t->_0);
		$tmp2 = _hx_string_or_null($tmp1) . " => ";
		$tmp3 = thx_Dynamics::string($t->_1);
		return _hx_string_or_null($tmp2) . _hx_string_or_null($tmp3);
	}
}
function thx_Maps_6($result, $source) {
	{
		$tmp = $source->keys();
		return thx_Iterators::reduce($tmp, array(new _hx_lambda(array(&$source), "thx_Maps_7"), 'execute'), $result);
	}
}
function thx_Maps_7(&$source, $result1, $key) {
	{
		$tmp1 = $source->get($key);
		$result1->set($key, $tmp1);
		return $result1;
	}
}
