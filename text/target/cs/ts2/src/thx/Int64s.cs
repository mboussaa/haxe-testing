// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx {
	public class Int64s : global::haxe.lang.HxObject {
		
		static Int64s() {
			unchecked {
				global::thx.Int64s.one = ((long) (( ((long) (( ((long) (0) ) << 32 )) ) | ((long) (( ((long) (1) ) & 0xffffffffL )) ) )) );
				global::thx.Int64s.two = ((long) (2) );
				global::thx.Int64s.zero = ((long) (( ((long) (( ((long) (0) ) << 32 )) ) | ((long) (( ((long) (0) ) & 0xffffffffL )) ) )) );
				global::thx.Int64s.ten = ((long) (10) );
				global::thx.Int64s.maxValue = ((long) (( ((long) (( ((long) (2147483647) ) << 32 )) ) | ((long) (( ((long) (-1) ) & 0xffffffffL )) ) )) );
				global::thx.Int64s.minValue = ((long) (( ((long) (( ((long) (-2147483648) ) << 32 )) ) | ((long) (( ((long) (1) ) & 0xffffffffL )) ) )) );
				global::thx.Int64s.min = ((long) (( ((long) (( ((long) (-2147483648) ) << 32 )) ) | ((long) (( ((long) (0) ) & 0xffffffffL )) ) )) );
			}
		}
		
		
		public Int64s(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Int64s() {
			global::thx.Int64s.__hx_ctor_thx_Int64s(this);
		}
		
		
		public static void __hx_ctor_thx_Int64s(global::thx.Int64s __temp_me120) {
		}
		
		
		public static long one;
		
		public static long two;
		
		public static long zero;
		
		public static long ten;
		
		public static long maxValue;
		
		public static long minValue;
		
		public static long abs(long @value) {
			if (((bool) (( ((long) (@value) ) < ((long) (global::thx.Int64s.zero) ) )) )) {
				return global::haxe._Int64.Int64_Impl_.neg(@value);
			}
			else {
				return @value;
			}
			
		}
		
		
		public static int compare(long a, long b) {
			unchecked {
				if (((bool) (( ((long) (a) ) > ((long) (b) ) )) )) {
					return 1;
				}
				else if (((bool) (( ((long) (a) ) < ((long) (b) ) )) )) {
					return -1;
				}
				else {
					return 0;
				}
				
			}
		}
		
		
		public static long parse(string s) {
			unchecked {
				bool sIsNegative = false;
				long multiplier = ((long) (1) );
				long current = ((long) (0) );
				if (string.Equals(global::haxe.lang.StringExt.charAt(s, 0), "-")) {
					sIsNegative = true;
					s = global::haxe.lang.StringExt.substring(s, 1, new global::haxe.lang.Null<int>(s.Length, true));
				}
				
				int len = s.Length;
				{
					int _g1 = 0;
					while (( _g1 < len )) {
						int digitInt = ( (global::haxe.lang.StringExt.charCodeAt(s, ( ( len - 1 ) - _g1++ ))).@value - 48 );
						if (( ( digitInt < 0 ) || ( digitInt > 9 ) )) {
							throw global::haxe.lang.HaxeException.wrap(new global::thx.Error("String should only contain digits (and an optional - sign)", null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"parse", "thx.Int64s", "Int64s.hx"}, new int[]{1981972957}, new double[]{((double) (71) )})));
						}
						
						long digit = ((long) (digitInt) );
						if (sIsNegative) {
							current = ((long) (( ((long) (current) ) - ((long) (( ((long) (multiplier) ) * ((long) (digit) ) )) ) )) );
							if ( ! ((((bool) (( ((long) (current) ) < 0 )) ))) ) {
								throw global::haxe.lang.HaxeException.wrap(new global::thx.Error("Int64 parsing error: Underflow", null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"parse", "thx.Int64s", "Int64s.hx"}, new int[]{1981972957}, new double[]{((double) (77) )})));
							}
							
						}
						else {
							current = ((long) (( ((long) (current) ) + ((long) (( ((long) (multiplier) ) * ((long) (digit) ) )) ) )) );
							if (((bool) (( ((long) (current) ) < 0 )) )) {
								throw global::haxe.lang.HaxeException.wrap(new global::thx.Error("Int64 parsing error: Overflow", null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"parse", "thx.Int64s", "Int64s.hx"}, new int[]{1981972957}, new double[]{((double) (81) )})));
							}
							
						}
						
						multiplier = ((long) (( ((long) (multiplier) ) * ((long) (global::thx.Int64s.ten) ) )) );
					}
					
				}
				
				return current;
			}
		}
		
		
		public static long toInt64(string s) {
			return global::thx.Int64s.parse(s);
		}
		
		
		public static long divRound(long num, long div) {
			unchecked {
				if (( ((long) (num) ) == 0 )) {
					return global::thx.Int64s.zero;
				}
				
				if (( ((long) (div) ) == 0 )) {
					throw global::haxe.lang.HaxeException.wrap(new global::thx.Error("Int64s.divRound division by zero", null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"divRound", "thx.Int64s", "Int64s.hx"}, new int[]{1981972957}, new double[]{((double) (98) )})));
				}
				
				if (( ((bool) (( ((long) (num) ) < 0 )) ) == ((bool) (( ((long) (div) ) < 0 )) ) )) {
					return ((long) (( (((long) (( ((long) (num) ) + ((long) (( ((long) (div) ) / ((long) (global::thx.Int64s.two) ) )) ) )) )) / ((long) (div) ) )) );
				}
				else if (((bool) (( ((long) (div) ) < 0 )) )) {
					return ((long) (( (((long) (( ((long) (( ((long) (global::haxe._Int64.Int64_Impl_.neg(num)) ) + ((long) (global::thx.Int64s.one) ) )) ) + ((long) (( ((long) (div) ) / ((long) (global::thx.Int64s.two) ) )) ) )) )) / ((long) (global::haxe._Int64.Int64_Impl_.neg(div)) ) )) );
				}
				else {
					return ((long) (( (((long) (( ((long) (( ((long) (num) ) + ((long) (global::thx.Int64s.one) ) )) ) - ((long) (( ((long) (div) ) / ((long) (global::thx.Int64s.two) ) )) ) )) )) / ((long) (div) ) )) );
				}
				
			}
		}
		
		
		public static long divFloor(long num, long div) {
			unchecked {
				if (( ((long) (num) ) == 0 )) {
					return global::thx.Int64s.zero;
				}
				
				if (( ((long) (div) ) == 0 )) {
					throw global::haxe.lang.HaxeException.wrap(new global::thx.Error("Int64s.divFloor division by zero", null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"divFloor", "thx.Int64s", "Int64s.hx"}, new int[]{1981972957}, new double[]{((double) (112) )})));
				}
				
				return ((long) (( ((long) (( ((long) (num) ) / ((long) (div) ) )) ) - ((long) (( (( ((bool) (( ((long) (num) ) < 0 )) ) != ((bool) (( ((long) (div) ) < 0 )) ) )) ? (1) : (0) )) ) )) );
			}
		}
		
		
		public static long divCeil(long num, long div) {
			unchecked {
				if (( ((long) (num) ) == 0 )) {
					return global::thx.Int64s.zero;
				}
				
				if (( ((long) (div) ) == 0 )) {
					throw global::haxe.lang.HaxeException.wrap(new global::thx.Error("Int64s.divCeil division by zero", null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"divCeil", "thx.Int64s", "Int64s.hx"}, new int[]{1981972957}, new double[]{((double) (120) )})));
				}
				
				long r_quotient = ((long) (( ((long) (num) ) / ((long) (div) ) )) );
				long r_modulus = ((long) (( ((long) (num) ) % ((long) (div) ) )) );
				if (( ( ((bool) (( ((long) (num) ) < 0 )) ) == ((bool) (( ((long) (div) ) < 0 )) ) ) && ( ((long) (r_modulus) ) != 0 ) )) {
					return ((long) (( ((long) (r_quotient) ) + ((long) (global::thx.Int64s.one) ) )) );
				}
				else {
					return r_quotient;
				}
				
			}
		}
		
		
		public static long min;
		
		public static double toFloat(long i) {
			unchecked {
				bool isNegative = false;
				if (((bool) (( ((long) (i) ) < ((long) (0) ) )) )) {
					if (((bool) (( ((long) (i) ) < ((long) (global::thx.Int64s.min) ) )) )) {
						return -9223372036854775808.0;
					}
					
					isNegative = true;
					i = global::haxe._Int64.Int64_Impl_.neg(i);
				}
				
				double multiplier = 1.0;
				double ret = 0.0;
				{
					int _g = 0;
					while (( _g < 64 )) {
						 ++ _g;
						if (( (((long) (( ((long) (i) ) & ((long) (global::thx.Int64s.one) ) )) )) != ((long) (global::thx.Int64s.zero) ) )) {
							ret += multiplier;
						}
						
						multiplier *= 2.0;
						i = ((long) (( ((long) (i) ) >> 1 )) );
					}
					
				}
				
				return ( (( (isNegative) ? (-1) : (1) )) * ret );
			}
		}
		
		
		public static long fromFloat(double f) {
			unchecked {
				if (( global::System.Double.IsNaN(((double) (f) )) ||  ! (((  ! (global::System.Double.IsInfinity(((double) (f) )))  &&  ! (global::System.Double.IsNaN(((double) (f) )))  )))  )) {
					throw global::haxe.lang.HaxeException.wrap(new global::thx.Error("Conversion to Int64 failed. Number is NaN or Infinite", null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"fromFloat", "thx.Int64s", "Int64s.hx"}, new int[]{1981972957}, new double[]{((double) (163) )})));
				}
				
				double noFractions = ( f - ( f % 1 ) );
				if (( noFractions > 9007199254740991.0 )) {
					throw global::haxe.lang.HaxeException.wrap(new global::thx.Error("Conversion to Int64 failed. Conversion overflow", null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"fromFloat", "thx.Int64s", "Int64s.hx"}, new int[]{1981972957}, new double[]{((double) (169) )})));
				}
				
				if (( noFractions < -9007199254740991.0 )) {
					throw global::haxe.lang.HaxeException.wrap(new global::thx.Error("Conversion to Int64 failed. Conversion underflow", null, new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"fromFloat", "thx.Int64s", "Int64s.hx"}, new int[]{1981972957}, new double[]{((double) (171) )})));
				}
				
				long result = global::thx.Int64s.zero;
				bool neg = ( noFractions < 0.0 );
				double rest = ( (neg) ? ( - (noFractions) ) : (noFractions) );
				int i = 0;
				double curr = default(double);
				while (( rest >= 1 )) {
					curr = ( rest % 2 );
					rest /= ((double) (2) );
					if (( curr >= 1 )) {
						result = ((long) (( ((long) (result) ) + (((long) (( ((long) (1) ) << i )) )) )) );
					}
					
					 ++ i;
				}
				
				if (neg) {
					return global::haxe._Int64.Int64_Impl_.neg(result);
				}
				else {
					return result;
				}
				
			}
		}
		
		
		public static new object __hx_createEmpty() {
			return new global::thx.Int64s(global::haxe.lang.EmptyObject.EMPTY);
		}
		
		
		public static new object __hx_create(global::Array arr) {
			return new global::thx.Int64s();
		}
		
		
	}
}


