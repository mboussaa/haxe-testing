// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::haxe.lang.FieldLookup.length = ( global::haxe.lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{98, 101, 102, 104, 105, 107, 109, 113, 116, 120, 21233, 21234, 21235, 21236, 21237, 21238, 1821933, 4745537, 4846113, 4849249, 4947370, 4948032, 4949376, 5144726, 5193562, 5343647, 5393365, 5442204, 5594513, 5594516, 5693978, 5695307, 5741474, 5745035, 24046298, 26061316, 33113266, 38537191, 39622016, 41050500, 42740551, 45312342, 52644165, 57219237, 63559312, 67859554, 67859999, 69051697, 69718249, 72452854, 74822897, 76061764, 78447857, 86600534, 87367608, 96903864, 99632527, 103479213, 106319913, 109574339, 114759225, 116192081, 121725540, 121872280, 142301684, 142895325, 143865495, 156956385, 159136996, 160217260, 177600534, 182695950, 193384655, 193568515, 195885713, 212244564, 214711673, 222029606, 238607874, 240155668, 244830897, 253833312, 255781545, 265544154, 270118404, 282949586, 286437776, 288025444, 288368849, 302437830, 302979532, 307312293, 311921353, 314003042, 328878574, 334695532, 354602035, 359333139, 399964207, 407283053, 409871691, 414504008, 417121083, 418482770, 426240778, 437335495, 439732138, 440996547, 451001976, 452737314, 453240570, 454622881, 460255224, 478746067, 480756972, 482248426, 484018937, 486005488, 501039929, 506461556, 509857466, 520590566, 523288192, 528448451, 529765024, 530261339, 533831917, 554059097, 561678025, 563316893, 584411450, 588953930, 589699876, 596483356, 596496232, 602680035, 614073432, 623100778, 625308696, 631673605, 635699692, 639476402, 641357653, 641535602, 647756354, 652148892, 653824046, 665670594, 667371489, 674203586, 691754853, 694450483, 695528738, 696274684, 697941195, 698919538, 699988920, 724060212, 726839840, 726843185, 735026061, 735461151, 742587063, 767112783, 783564643, 784837008, 788933708, 799214217, 801488835, 813808006, 815911746, 816375999, 822857114, 834174833, 836180395, 843587180, 845339077, 872071561, 872279826, 883188921, 887574448, 888960333, 890150099, 891567758, 897845290, 908638873, 910198946, 917429597, 922671056, 927738905, 931922363, 932382472, 934297389, 943771534, 943871192, 946786476, 959399230, 961866285, 971992536, 974131605, 980455379, 985194240, 987476920, 988222866, 990364012, 992442663, 993950564, 995006396, 999967216, 1002257126, 1014900378, 1041537810, 1046660463, 1049813055, 1050456214, 1055554178, 1059250339, 1067353468, 1067492012, 1071652316, 1072885311, 1079146715, 1084792286, 1091627025, 1098871740, 1099121107, 1100620564, 1102421591, 1102913954, 1103409453, 1103411251, 1103412149, 1111933837, 1112096333, 1113806382, 1114501250, 1126920507, 1148382810, 1152408707, 1154932936, 1155848147, 1157765830, 1158359328, 1169453134, 1170141094, 1170148173, 1170148174, 1170195731, 1171632074, 1172057283, 1181037546, 1184891690, 1191633396, 1202619922, 1202718727, 1202920542, 1204816148, 1213952397, 1224901875, 1225397154, 1232990044, 1241997557, 1245800482, 1246877401, 1246881189, 1247723251, 1247875320, 1247875546, 1247983110, 1265217698, 1269755426, 1269757209, 1271070480, 1273207865, 1273872862, 1275922997, 1280549057, 1280845662, 1280891594, 1281091404, 1281093634, 1282943179, 1285332817, 1287892547, 1291299698, 1292432058, 1293712380, 1293935487, 1313416818, 1324904599, 1324905541, 1329111435, 1337394146, 1350392273, 1352786672, 1357975336, 1362533066, 1365803947, 1378618123, 1395555037, 1413779326, 1428431209, 1428901784, 1429408506, 1429887281, 1437940672, 1443572157, 1447008734, 1457436259, 1461654312, 1484698101, 1492589217, 1503837296, 1504438184, 1510669659, 1516540973, 1523302113, 1528104702, 1530353339, 1531583505, 1531979784, 1532710347, 1536427801, 1537812987, 1542735027, 1543554379, 1547539107, 1548166113, 1553877950, 1568593144, 1604324540, 1610611779, 1610714396, 1620824029, 1621420777, 1622659719, 1623148745, 1623621641, 1639293562, 1640272491, 1640327725, 1644018940, 1648581351, 1660995221, 1669413332, 1675742188, 1677577253, 1692511090, 1700034528, 1705629508, 1711229592, 1723805383, 1747840398, 1768164316, 1768548618, 1771130534, 1781145963, 1798631236, 1800886518, 1801622666, 1802291657, 1804873517, 1809462285, 1812362308, 1813879407, 1825405726, 1830310359, 1831018813, 1861441745, 1864494649, 1864919677, 1867552145, 1870897157, 1876741424, 1880264788, 1891834246, 1894671199, 1901958747, 1913895454, 1914813385, 1915412854, 1916009602, 1924918689, 1926178603, 1932118984, 1933241730, 1954547906, 1954691124, 1960170514, 1963056639, 1981972957, 1991497501, 2013154798, 2014410004, 2015207816, 2022294396, 2025055113, 2037785099, 2043087382, 2048392659, 2049845887, 2049945213, 2058605085, 2062500402, 2065762231, 2077556658, 2082663554, 2083500811, 2084789794, 2113364337, 2123232567, 2126516472, 2127021138, 2140014923, 2143813817};
		
		protected static string[] fields = new string[]{"b", "e", "f", "h", "i", "k", "m", "q", "t", "x", "_0", "_1", "_2", "_3", "_4", "_5", "isGlobal", "__a", "add", "arr", "cls", "col", "cur", "get", "has", "key", "len", "map", "pop", "pos", "row", "run", "set", "sum", "split", "teardown", "spanRight", "height", "compareTo", "symbolPermille", "flags", "patternNegativeCurrency", "match", "compare", "addSuccesses", "start", "stats", "style", "failures", "executeMethod", "successes", "remove", "packageName", "render", "filter", "merge", "startTime", "progress", "nameCalendar", "hasSetup", "symbolPositiveInfinity", "target", "setCell", "setChar", "resize", "result", "warnings", "method", "matched", "addErrors", "signPositive", "table", "paintBlock", "separatorGroupNumber", "set_minWidth", "newline", "separatorDecimalPercent", "setLoop", "get_nameDisplayEnglish", "stackToString", "compareArg", "patternNegativePercent", "processContents", "append", "onPrecheck", "signNegative", "getPackage", "assertations", "string", "_trace", "methodName", "hasErrors", "symbolCurrency", "packageNames", "iterator", "indent", "patternUniversalSortable", "lastIndexOf", "totals", "hasNext", "onAddFailures", "setHandler", "pickRight", "innerError", "formatter", "message", "getLine", "onStart", "keysLoop", "reverse", "patternDateTimeFull", "get_rowIndex", "testPaintBorder", "expireson", "nOccupied", "onTestComplete", "onAddWarnings", "get_minHeight", "insert", "dumpStack", "dispatch", "length", "reduceWidth", "getTime", "nameCalendarNative", "addAsync", "set_formatter", "calendarWeekRuleName", "number", "allOk", "patternDateLong", "getCol", "getRow", "balance", "setupName", "patternDateTimeSortable", "matchedRight", "hasTeardownError", "nextRun", "get_nameDisplayNative", "nameDaysShortest", "colIndex", "displaySuccessResults", "methods", "nameNative", "patternPositivePercent", "nameDisplayNative", "firstDayOfWeekName", "nameMonthGenitives", "getClass", "addPackage", "separatorDate", "ensureCol", "ensureRow", "get_maxWidth", "aligner", "nameMonthGenitivesAbbreviated", "replace", "designatorAm", "designatorPm", "onAddErrors", "setTimeout", "nameDaysAbbreviated", "onAddSuccesses", "separatorList", "pickBottomRight", "spanDown", "get_aligner", "setAlign", "testIdentityOfCellsCreatedFromTable", "onTimeout", "patternTimeShort", "patternPositiveCurrency", "value", "maxHeight", "asyncStack", "precheck", "aggregator", "separatorTime", "nameDisplayEnglish", "onTested", "block", "pickBottomLeft", "addHeader", "addFailures", "patternTimeLong", "compareArgs", "halign", "cachedIndex", "checkTested", "firstDayOfWeekIndex", "pickTopRight", "globalPattern", "set_maxHeight", "canvas", "toString", "identity", "packages", "addWarnings", "set_aligner", "patternYearMonth", "getResults", "testIdentityOfCellsCreatedFromCol", "testIdentityOfCellsCreatedFromRow", "patternMonthDay", "methodNames", "priority", "hashes", "runner", "hasAsyncError", "toObject", "index", "displayHeader", "set_maxWidth", "nameRegionNative", "nameDays", "_set", "splice", "pickBottom", "exists", "equals", "nameMonthsAbbreviated", "addResult", "base", "get_cols", "getFixture", "minWidth", "addClass", "cell", "code", "cols", "copy", "bindHandler", "symbolPercent", "date", "done", "matchSub", "expand", "upperMatch", "removeLoop", "minBinding", "testCellResizeTable", "head", "ietf", "isOk", "iso2", "iso3", "item", "handler", "getOrCreateClass", "join", "paintBorder", "keys", "lcid", "left", "list", "concat", "clear", "next", "noop", "hasTestError", "combineChar", "flattenPackage", "pack", "path", "prev", "pure", "push", "width", "get_rows", "root", "rows", "matchedPos", "current", "nameMonths", "execute", "size", "sort", "span", "step", "stop", "quicksort", "nameRegionEnglish", "get_type", "recursive", "type", "groupSizesNumber", "testStyle", "vals", "win3", "wire", "completed", "values", "padding", "spliceVoid", "zero", "testCanvas", "errors", "getProperty", "cachedKey", "hasTeardown", "handlers", "stackItems", "equality", "tested", "decimalDigitsNumber", "paintBottomLine", "runNext", "hasFailures", "oneCell", "symbolNegativeInfinity", "timeout", "classNames", "addFixture", "dateTime", "createFixture", "get_formatter", "patternDateShort", "get_colIndex", "hasWarnings", "decimalDigitsCurrency", "concatNative", "minHeight", "nBuckets", "testSequence", "separatorGroupPercent", "className", "hasTimeoutError", "runFixture", "onComplete", "existsClass", "symbolNaN", "symbolPos", "__unsafe_get", "__unsafe_set", "indents", "indexOf", "parents", "lookup", "isMethod", "reduceHeight", "set_minHeight", "fileName", "separatorDecimalNumber", "unbindHandler", "onProgress", "nameEnglish", "iteratorLoop", "patternRfc1123", "toDynamic", "rowIndex", "regex", "patternNegativeNumber", "right", "existsPackage", "classes", "__hx_constructs", "groupSizesCurrency", "results", "fixtures", "checkMethod", "getClassName", "colWidths", "calendarWeekRuleIndex", "teardownName", "unwire", "customParams", "testTableSize", "getOrCreatePackage", "addEvent", "isNeutral", "onTestStart", "hasSetupError", "set_cols", "isRightToLeft", "_height", "getPosition", "pickTopLeft", "toArray", "fixture", "__get", "__set", "typeToBorder", "testComplete", "error", "get_maxHeight", "maxWidth", "pickTop", "_cols", "lines", "lineNumber", "get_minWidth", "decimalDigitsPercent", "subtract", "pickLeft", "upperBound", "unshift", "separatorGroupCurrency", "set_rows", "_keys", "combine", "setup", "separatorDecimalCurrency", "groupSizesPercent", "set_type", "rowHeights", "shift", "matchedLeft", "__hx_createEmpty", "addCase", "removeMinBinding", "_rows", "slice", "_handler", "complete"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::haxe.lang.FieldLookup.fieldIds;
				string[] cfields = global::haxe.lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::haxe.lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Different fields length: ", global::haxe.lang.Runtime.toString(nlen)), " and "), global::haxe.lang.Runtime.toString(( nfields as global::System.Array ).Length)));
				}
				
				bool needsChange = false;
				{
					int[] _g_arr = nids;
					uint _g_idx = ((uint) (0) );
					while (((bool) (( _g_idx < ( _g_arr as global::System.Array ).Length )) )) {
						if (( global::haxe.lang.FieldLookup.findHash(((int) (_g_arr[((int) (_g_idx++) )]) ), cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::haxe.lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( ( ci < clen ) && ( ni < nlen ) ))) ) {
								break;
							}
							
							if (( cids[ci] < nids[ni] )) {
								ansIds[ansi] = cids[ci];
								ansFields[ansi] = cfields[ci];
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = nids[ni];
								ansFields[ansi] = nfields[ni];
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::haxe.lang.FieldLookup.fieldIds = ansIds;
						global::haxe.lang.FieldLookup.fields = ansFields;
						global::haxe.lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ((int) (( (( max - min )) / 2 )) ) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return global::haxe.lang.FieldLookup.fields[mid];
					}
					
				}
				
				throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat("Field not found for hash ", global::haxe.lang.Runtime.toString(key)));
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (string.Equals(s, null)) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				string[] fld = global::haxe.lang.FieldLookup.fields;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				int len = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						if ( ! (string.Equals(fld[mid], s)) ) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::haxe.lang.FieldLookup)){
					if (( len != global::haxe.lang.FieldLookup.length )) {
						return global::haxe.lang.FieldLookup.hash(s);
					}
					
					global::haxe.lang.FieldLookup.insert<int>(ref global::haxe.lang.FieldLookup.fieldIds, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((int) (key) ));
					global::haxe.lang.FieldLookup.insert<string>(ref global::haxe.lang.FieldLookup.fields, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((string) (s) ));
					 ++ global::haxe.lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ((int) (( (( max + min )) / 2 )) );
					int imid = hashs[mid];
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void @remove<T>(T[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = default(T);
			}
		}
		
		
		public static void insert<T>(ref T[] a, int length, int pos, T x) {
			unchecked {
				int capacity = ( a as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						T[] newarr = new T[( (( length << 1 )) + 1 )];
						( a as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a = ((T[]) (newarr) );
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						T[] newarr1 = new T[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a = ((T[]) (newarr1) );
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					T[] newarr2 = new T[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a = ((T[]) (newarr2) );
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a[pos] = x;
			}
		}
		
		
	}
}


