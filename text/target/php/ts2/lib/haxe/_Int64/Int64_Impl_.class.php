<?php

// Generated by Haxe 3.3.0
class haxe__Int64_Int64_Impl_ {
	public function __construct(){}
	static function toString($this1) {
		$i = $this1;
		$x = new haxe__Int64____Int64(0, 0);
		$b = $x;
		$tmp = null;
		if($i->high === $b->high) {
			$tmp = $i->low === $b->low;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return "0";
		}
		$str = "";
		$neg = false;
		if($i->high < 0) {
			$neg = true;
		}
		$x1 = new haxe__Int64____Int64(0, 10);
		$ten = $x1;
		while(true) {
			$x2 = new haxe__Int64____Int64(0, 0);
			$b1 = $x2;
			$tmp1 = null;
			if(!($i->high !== $b1->high)) {
				$tmp1 = $i->low !== $b1->low;
			} else {
				$tmp1 = true;
			}
			if(!$tmp1) {
				break;
			}
			$r = haxe__Int64_Int64_Impl_::divMod($i, $ten);
			if($r->modulus->high < 0) {
				$x3 = $r->modulus;
				$high = ~$x3->high;
				$low = -$x3->low;
				if($low === 0) {
					++$high;
					$tmp2 = $high << haxe__Int32_Int32_Impl_::$extraBits;
					$high = $tmp2 >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($tmp2);
				}
				$x4 = new haxe__Int64____Int64($high, $low);
				$str = _hx_string_rec($x4->low, "") . _hx_string_or_null($str);
				$x5 = $r->quotient;
				$high1 = ~$x5->high;
				$low1 = -$x5->low;
				if($low1 === 0) {
					++$high1;
					$tmp3 = $high1 << haxe__Int32_Int32_Impl_::$extraBits;
					$high1 = $tmp3 >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($tmp3);
				}
				$x6 = new haxe__Int64____Int64($high1, $low1);
				$i = $x6;
				unset($x6,$x5,$x4,$x3,$low1,$low,$high1,$high);
			} else {
				$str = _hx_string_rec($r->modulus->low, "") . _hx_string_or_null($str);
				$i = $r->quotient;
			}
			unset($x2,$tmp1,$r,$b1);
		}
		if($neg) {
			$str = "-" . _hx_string_or_null($str);
		}
		return $str;
	}
	static function divMod($dividend, $divisor) {
		if($divisor->high === 0) {
			switch($divisor->low) {
			case 0:{
				throw new HException("divide by zero");
			}break;
			case 1:{
				$x = new haxe__Int64____Int64($dividend->high, $dividend->low);
				$tmp = $x;
				$x1 = new haxe__Int64____Int64(0, 0);
				return _hx_anonymous(array("quotient" => $tmp, "modulus" => $x1));
			}break;
			}
		}
		$divSign = (is_object($_t = $dividend->high < 0) && ($_t instanceof Enum) ? $_t != $divisor->high < 0 : !_hx_equal($_t, $divisor->high < 0));
		$modulus = null;
		if($dividend->high < 0) {
			$high = ~$dividend->high;
			$low = -$dividend->low;
			if($low === 0) {
				++$high;
				$tmp1 = $high << haxe__Int32_Int32_Impl_::$extraBits;
				$high = $tmp1 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x2 = new haxe__Int64____Int64($high, $low);
			$modulus = $x2;
		} else {
			$x3 = new haxe__Int64____Int64($dividend->high, $dividend->low);
			$modulus = $x3;
		}
		$tmp2 = $divisor->high < 0;
		if($tmp2) {
			$high1 = ~$divisor->high;
			$low1 = -$divisor->low;
			if($low1 === 0) {
				++$high1;
				$tmp3 = $high1 << haxe__Int32_Int32_Impl_::$extraBits;
				$high1 = $tmp3 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x4 = new haxe__Int64____Int64($high1, $low1);
			$divisor = $x4;
		} else {
			$divisor = $divisor;
		}
		$x5 = new haxe__Int64____Int64(0, 0);
		$quotient = $x5;
		$x6 = new haxe__Int64____Int64(0, 1);
		$mask = $x6;
		while(!($divisor->high < 0)) {
			$v = haxe__Int32_Int32_Impl_::ucompare($divisor->high, $modulus->high);
			$cmp = null;
			if($v !== 0) {
				$cmp = $v;
			} else {
				$cmp = haxe__Int32_Int32_Impl_::ucompare($divisor->low, $modulus->low);
			}
			{
				$x7 = new haxe__Int64____Int64($divisor->high << 1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($divisor->low, 31), $divisor->low << 1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits);
				$divisor = $x7;
				unset($x7);
			}
			{
				$x8 = new haxe__Int64____Int64($mask->high << 1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($mask->low, 31), $mask->low << 1 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits);
				$mask = $x8;
				unset($x8);
			}
			if($cmp >= 0) {
				break;
			}
			unset($v,$cmp);
		}
		while(true) {
			$x9 = new haxe__Int64____Int64(0, 0);
			$b = $x9;
			$tmp4 = null;
			if(!($mask->high !== $b->high)) {
				$tmp4 = $mask->low !== $b->low;
			} else {
				$tmp4 = true;
			}
			if(!$tmp4) {
				break;
			}
			$v1 = haxe__Int32_Int32_Impl_::ucompare($modulus->high, $divisor->high);
			$tmp5 = null;
			if($v1 !== 0) {
				$tmp5 = $v1;
			} else {
				$tmp5 = haxe__Int32_Int32_Impl_::ucompare($modulus->low, $divisor->low);
			}
			if($tmp5 >= 0) {
				$x10 = new haxe__Int64____Int64($quotient->high | $mask->high, $quotient->low | $mask->low);
				$quotient = $x10;
				$high2 = $modulus->high - $divisor->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low2 = $modulus->low - $divisor->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($modulus->low, $divisor->low) < 0) {
					--$high2;
					$tmp6 = $high2 << haxe__Int32_Int32_Impl_::$extraBits;
					$high2 = $tmp6 >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($tmp6);
				}
				$x11 = new haxe__Int64____Int64($high2, $low2);
				$modulus = $x11;
				unset($x11,$x10,$low2,$high2);
			}
			{
				$x12 = new haxe__Int64____Int64(_hx_shift_right($mask->high, 1), $mask->high << 31 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($mask->low, 1));
				$mask = $x12;
				unset($x12);
			}
			{
				$x13 = new haxe__Int64____Int64(_hx_shift_right($divisor->high, 1), $divisor->high << 31 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($divisor->low, 1));
				$divisor = $x13;
				unset($x13);
			}
			unset($x9,$v1,$tmp5,$tmp4,$b);
		}
		if($divSign) {
			$high3 = ~$quotient->high;
			$low3 = -$quotient->low;
			if($low3 === 0) {
				++$high3;
				$tmp7 = $high3 << haxe__Int32_Int32_Impl_::$extraBits;
				$high3 = $tmp7 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x14 = new haxe__Int64____Int64($high3, $low3);
			$quotient = $x14;
		}
		if($dividend->high < 0) {
			$high4 = ~$modulus->high;
			$low4 = -$modulus->low;
			if($low4 === 0) {
				++$high4;
				$tmp8 = $high4 << haxe__Int32_Int32_Impl_::$extraBits;
				$high4 = $tmp8 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x15 = new haxe__Int64____Int64($high4, $low4);
			$modulus = $x15;
		}
		return _hx_anonymous(array("quotient" => $quotient, "modulus" => $modulus));
	}
	function __toString() { return 'haxe._Int64.Int64_Impl_'; }
}
