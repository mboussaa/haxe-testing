<?php

// Generated by Haxe 3.3.0
class thx_format_NumberFormat {
	public function __construct(){}
	static function binary($f, $significantDigits = null, $culture = null) {
		if($significantDigits === null) {
			$significantDigits = 1;
		}
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$tmp2 = null;
		if($significantDigits === 0) {
			$tmp2 = _hx_equal($f, 0);
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			return "";
		} else {
			$tmp3 = Std::int($f);
			$s = thx_format_NumberFormat::toBase($tmp3, 2, $culture);
			$tmp4 = null;
			if(strlen("0") !== 0) {
				$tmp4 = strlen($s) >= $significantDigits;
			} else {
				$tmp4 = true;
			}
			if($tmp4) {
				return $s;
			} else {
				return str_pad($s, Math::ceil(($significantDigits - strlen($s)) / strlen("0")) * strlen("0") + strlen($s), "0", STR_PAD_LEFT);
			}
		}
	}
	static function currency($f, $precision = null, $symbol = null, $culture = null) {
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$pattern = null;
		if($f < 0) {
			$pattern = thx_culture_Pattern::$currencyNegatives[$nf->patternNegativeCurrency];
		} else {
			$pattern = thx_culture_Pattern::$currencyPositives[$nf->patternPositiveCurrency];
		}
		$_0 = $precision;
		$t = null;
		if(null === $_0) {
			$t = null;
		} else {
			$t = $_0;
		}
		$tmp2 = null;
		if($t !== null) {
			$tmp2 = $t;
		} else {
			$tmp2 = $nf->decimalDigitsCurrency;
		}
		$formatted = thx_format_NumberFormat::value($f, $tmp2, $nf->groupSizesCurrency, $nf->separatorGroupCurrency, $nf->separatorDecimalCurrency);
		$s = str_replace("n", $formatted, $pattern);
		$_01 = $symbol;
		$t1 = null;
		if(null === $_01) {
			$t1 = null;
		} else {
			$t1 = $_01;
		}
		$by = null;
		if($t1 !== null) {
			$by = $t1;
		} else {
			$by = $nf->symbolCurrency;
		}
		return str_replace("\$", $by, $s);
	}
	static function customFormat($f, $pattern, $culture = null) {
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$isCurrency = thx_format_NumberFormat::hasSymbols($pattern, "\$");
		$isPercent = null;
		if(!$isCurrency) {
			$isPercent = thx_format_NumberFormat::hasSymbols($pattern, "%â€°");
		} else {
			$isPercent = false;
		}
		$groups = thx_format_NumberFormat::splitPattern($pattern, ";");
		if($groups->length > 3) {
			throw new HException("invalid number of sections in \"" . _hx_string_or_null($pattern) . "\"");
		}
		if($f < 0) {
			if(null !== $groups[1]) {
				return thx_format_NumberFormat::customFormatF(-$f, $groups[1], $nf, $isCurrency, $isPercent);
			} else {
				return thx_format_NumberFormat::customFormatF(-$f, "-" . _hx_string_or_null($groups[0]), $nf, $isCurrency, $isPercent);
			}
		} else {
			if($f > 0) {
				return thx_format_NumberFormat::customFormatF($f, $groups[0], $nf, $isCurrency, $isPercent);
			} else {
				$t = null;
				if(null === $groups) {
					$t = null;
				} else {
					$_1 = $groups[2];
					if(null === $_1) {
						$t = null;
					} else {
						$t = $_1;
					}
				}
				$tmp2 = null;
				if($t !== null) {
					$tmp2 = $t;
				} else {
					$tmp2 = $groups[0];
				}
				return thx_format_NumberFormat::customFormatF(0, $tmp2, $nf, $isCurrency, $isPercent);
			}
		}
	}
	static function decimal($f, $significantDigits = null, $culture = null) {
		if($significantDigits === null) {
			$significantDigits = 1;
		}
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$formatted = thx_format_NumberFormat::value($f, 0, (new _hx_array(array(0))), "", "");
		$tmp2 = null;
		if($f < 0) {
			$tmp2 = $nf->signNegative;
		} else {
			$tmp2 = "";
		}
		$tmp3 = null;
		$tmp4 = null;
		if(strlen("0") !== 0) {
			$tmp4 = strlen($formatted) >= $significantDigits;
		} else {
			$tmp4 = true;
		}
		if($tmp4) {
			$tmp3 = $formatted;
		} else {
			$tmp3 = str_pad($formatted, Math::ceil(($significantDigits - strlen($formatted)) / strlen("0")) * strlen("0") + strlen($formatted), "0", STR_PAD_LEFT);
		}
		return _hx_string_or_null($tmp2) . _hx_string_or_null($tmp3);
	}
	static function exponential($f, $precision = null, $digits = null, $symbol = null, $culture = null) {
		if($symbol === null) {
			$symbol = "e";
		}
		if($digits === null) {
			$digits = 3;
		}
		if($precision === null) {
			$precision = 6;
		}
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$info = thx_format_NumberFormat::exponentialInfo($f);
		$tmp2 = thx_format_NumberFormat::number($info->f, $precision, $culture);
		$tmp3 = _hx_string_or_null($tmp2) . _hx_string_or_null($symbol);
		$tmp4 = null;
		if($info->e < 0) {
			$tmp4 = $nf->signNegative;
		} else {
			$tmp4 = $nf->signPositive;
		}
		$tmp5 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
		$v = $info->e;
		$tmp6 = null;
		if($v < 0) {
			$tmp6 = -$v;
		} else {
			$tmp6 = $v;
		}
		$s = "" . _hx_string_rec($tmp6, "");
		$tmp7 = null;
		$tmp8 = null;
		if(strlen("0") !== 0) {
			$tmp8 = strlen($s) >= $digits;
		} else {
			$tmp8 = true;
		}
		if($tmp8) {
			$tmp7 = $s;
		} else {
			$tmp7 = str_pad($s, Math::ceil(($digits - strlen($s)) / strlen("0")) * strlen("0") + strlen($s), "0", STR_PAD_LEFT);
		}
		return _hx_string_or_null($tmp5) . _hx_string_or_null($tmp7);
	}
	static function fixed($f, $precision = null, $culture = null) {
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$pattern = null;
		if($f < 0) {
			$pattern = thx_culture_Pattern::$numberNegatives[$nf->patternNegativeNumber];
		} else {
			$pattern = "n";
		}
		$_0 = $precision;
		$t = null;
		if(null === $_0) {
			$t = null;
		} else {
			$t = $_0;
		}
		$tmp2 = null;
		if($t !== null) {
			$tmp2 = $t;
		} else {
			$tmp2 = $nf->decimalDigitsNumber;
		}
		$formatted = thx_format_NumberFormat::value($f, $tmp2, (new _hx_array(array(0))), "", $nf->separatorDecimalNumber);
		return str_replace("n", $formatted, $pattern);
	}
	static function format($f, $pattern, $culture = null) {
		$specifier = _hx_substring($pattern, 0, 1);
		$tmp = _hx_substring($pattern, 1, null);
		$param = thx_format_NumberFormat::paramOrNull($tmp);
		switch($specifier) {
		case "%":{
			return thx_format_NumberFormat::printf($f, $pattern, $culture);
		}break;
		case "C":case "c":{
			return thx_format_NumberFormat::currency($f, $param, null, $culture);
		}break;
		case "E":{
			return thx_format_NumberFormat::exponential($f, $param, null, null, $culture);
		}break;
		case "G":{
			return thx_format_NumberFormat::general($f, $param, $culture);
		}break;
		case "P":case "p":{
			return thx_format_NumberFormat::percent($f, $param, $culture);
		}break;
		case "X":{
			return strtoupper(thx_format_NumberFormat::hex($f, $param, $culture));
		}break;
		case "D":case "d":{
			return thx_format_NumberFormat::decimal($f, $param, $culture);
		}break;
		case "e":{
			return strtolower(thx_format_NumberFormat::exponential($f, $param, null, null, $culture));
		}break;
		case "F":case "f":{
			return thx_format_NumberFormat::fixed($f, $param, $culture);
		}break;
		case "g":{
			return strtolower(thx_format_NumberFormat::general($f, $param, $culture));
		}break;
		case "N":case "n":{
			return thx_format_NumberFormat::number($f, $param, $culture);
		}break;
		case "R":case "r":{
			return "" . _hx_string_rec($f, "");
		}break;
		case "x":{
			return thx_format_NumberFormat::hex($f, $param, $culture);
		}break;
		default:{
			return thx_format_NumberFormat::customFormat($f, $pattern, $culture);
		}break;
		}
	}
	static function general($f, $significantDigits = null, $culture = null) {
		$e = thx_format_NumberFormat::exponential($f, $significantDigits, null, null, $culture);
		$f1 = thx_format_NumberFormat::fixed($f, $significantDigits, $culture);
		if(strlen($e) < strlen($f1)) {
			return $e;
		} else {
			return $f1;
		}
	}
	static function hex($f, $significantDigits = null, $culture = null) {
		if($significantDigits === null) {
			$significantDigits = 1;
		}
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$tmp2 = null;
		if($significantDigits === 0) {
			$tmp2 = _hx_equal($f, 0);
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			return "";
		} else {
			$tmp3 = Std::int($f);
			$s = thx_format_NumberFormat::toBase($tmp3, 16, $culture);
			$tmp4 = null;
			if(strlen("0") !== 0) {
				$tmp4 = strlen($s) >= $significantDigits;
			} else {
				$tmp4 = true;
			}
			if($tmp4) {
				return $s;
			} else {
				return str_pad($s, Math::ceil(($significantDigits - strlen($s)) / strlen("0")) * strlen("0") + strlen($s), "0", STR_PAD_LEFT);
			}
		}
	}
	static function integer($f, $culture = null) {
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		return thx_format_NumberFormat::number($f, 0, $culture);
	}
	static function number($f, $precision = null, $culture = null) {
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$pattern = null;
		if($f < 0) {
			$pattern = thx_culture_Pattern::$numberNegatives[$nf->patternNegativeNumber];
		} else {
			$pattern = "n";
		}
		$_0 = $precision;
		$t = null;
		if(null === $_0) {
			$t = null;
		} else {
			$t = $_0;
		}
		$tmp2 = null;
		if($t !== null) {
			$tmp2 = $t;
		} else {
			$tmp2 = $nf->decimalDigitsNumber;
		}
		$formatted = thx_format_NumberFormat::value($f, $tmp2, $nf->groupSizesNumber, $nf->separatorGroupNumber, $nf->separatorDecimalNumber);
		return str_replace("n", $formatted, $pattern);
	}
	static function octal($f, $significantDigits = null, $culture = null) {
		if($significantDigits === null) {
			$significantDigits = 1;
		}
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$tmp2 = null;
		if($significantDigits === 0) {
			$tmp2 = _hx_equal($f, 0);
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			return "";
		} else {
			$tmp3 = Std::int($f);
			$s = thx_format_NumberFormat::toBase($tmp3, 8, $culture);
			$tmp4 = null;
			if(strlen("0") !== 0) {
				$tmp4 = strlen($s) >= $significantDigits;
			} else {
				$tmp4 = true;
			}
			if($tmp4) {
				return $s;
			} else {
				return str_pad($s, Math::ceil(($significantDigits - strlen($s)) / strlen("0")) * strlen("0") + strlen($s), "0", STR_PAD_LEFT);
			}
		}
	}
	static function percent($f, $decimals = null, $culture = null) {
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$tmp2 = $f * 100;
		$t = null;
		if(null === $decimals) {
			$t = null;
		} else {
			$t = $decimals;
		}
		$tmp3 = null;
		if($t !== null) {
			$tmp3 = $t;
		} else {
			$tmp3 = $nf->decimalDigitsPercent;
		}
		return thx_format_NumberFormat::unit($tmp2, $tmp3, $nf->symbolPercent, $culture);
	}
	static function permille($f, $decimals = null, $culture = null) {
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$tmp2 = $f * 1000;
		$t = null;
		if(null === $decimals) {
			$t = null;
		} else {
			$t = $decimals;
		}
		$tmp3 = null;
		if($t !== null) {
			$tmp3 = $t;
		} else {
			$tmp3 = $nf->decimalDigitsPercent;
		}
		return thx_format_NumberFormat::unit($tmp2, $tmp3, $nf->symbolPermille, $culture);
	}
	static function printf($f, $pattern, $culture = null) {
		$tmp = !StringTools::startsWith($pattern, "%");
		if($tmp) {
			throw new HException("invalid printf term \"" . _hx_string_or_null($pattern) . "\"");
		}
		$tmp1 = strlen($pattern) - 1;
		$specifier = _hx_substring($pattern, $tmp1, null);
		$tmp2 = strlen($pattern) - 1;
		$p = _hx_explode(".", _hx_substring($pattern, 1, $tmp2));
		$precision = null;
		$tmp3 = null;
		if(null !== $p[1]) {
			$tmp3 = "" === $p[1];
		} else {
			$tmp3 = true;
		}
		if($tmp3) {
			$precision = null;
		} else {
			$precision = Std::parseInt($p[1]);
		}
		$justifyRight = true;
		$negativeSignOnly = true;
		$emptySpaceForSign = false;
		$prefix = false;
		$padding = " ";
		$width = 0;
		$flags = $p[0];
		while(strlen($flags) > 0) {
			{
				$_g = _hx_substring($flags, 0, 1);
				switch($_g) {
				case " ":{
					$emptySpaceForSign = true;
				}break;
				case "#":{
					$prefix = true;
				}break;
				case "+":{
					$negativeSignOnly = false;
				}break;
				case "-":{
					$justifyRight = false;
				}break;
				case "0":{
					$padding = "0";
				}break;
				default:{
					$tmp4 = thx_Ints::canParse($_g);
					if($tmp4) {
						$width = thx_Ints::parse($flags, null);
						$flags = "";
						continue 2;
					} else {
						throw new HException("invalid flags " . _hx_string_or_null($flags));
					}
				}break;
				}
				unset($_g);
			}
			$flags = _hx_substring($flags, 1, null);
		}
		$decorate = array(new _hx_lambda(array(&$emptySpaceForSign, &$justifyRight, &$negativeSignOnly, &$padding, &$prefix, &$width), "thx_format_NumberFormat_0"), 'execute');
		$nf = thx_format_NumberFormat::numberFormat($culture);
		switch($specifier) {
		case "%":{
			return call_user_func_array($decorate, array("%", 1, "", "", ""));
		}break;
		case "B":{
			$v = Std::int($f);
			$tmp7 = null;
			if($v < 0) {
				$tmp7 = -$v;
			} else {
				$tmp7 = $v;
			}
			$tmp8 = thx_Ints::toString($tmp7, 2);
			return call_user_func_array($decorate, array($tmp8, 1, "B", "", ""));
		}break;
		case "E":{
			$tmp9 = Math::abs($f);
			$tmp10 = thx_format_NumberFormat::exponential($tmp9, $precision, 0, "E", $culture);
			return call_user_func_array($decorate, array($tmp10, $f, "", $nf->signNegative, $nf->signPositive));
		}break;
		case "G":{
			$e = thx_format_NumberFormat::printf($f, "E", $culture);
			$f2 = thx_format_NumberFormat::printf($f, "f", $culture);
			if(strlen($e) < strlen($f2)) {
				return $e;
			} else {
				return $f2;
			}
		}break;
		case "X":{
			$tmp11 = Math::abs($f);
			$tmp12 = thx_format_NumberFormat::hex($tmp11, $precision, $culture);
			return call_user_func_array($decorate, array($tmp12, $f, "0X", $nf->signNegative, $nf->signPositive));
		}break;
		case "b":{
			$v1 = Std::int($f);
			$tmp13 = null;
			if($v1 < 0) {
				$tmp13 = -$v1;
			} else {
				$tmp13 = $v1;
			}
			$tmp14 = thx_Ints::toString($tmp13, 2);
			return call_user_func_array($decorate, array($tmp14, 1, "b", "", ""));
		}break;
		case "c":{
			$v2 = Std::int($f);
			$tmp15 = null;
			if($v2 < 0) {
				$tmp15 = -$v2;
			} else {
				$tmp15 = $v2;
			}
			return call_user_func_array($decorate, array(chr($tmp15), 1, "", "", ""));
		}break;
		case "d":case "i":{
			$tmp16 = Math::round($f);
			$s1 = "" . _hx_string_rec($tmp16, "");
			$_0 = $precision;
			$t = null;
			if(null === $_0) {
				$t = null;
			} else {
				$t = $_0;
			}
			$l = null;
			if($t !== null) {
				$l = $t;
			} else {
				$l = 0;
			}
			$tmp17 = null;
			$tmp18 = null;
			if(strlen("0") !== 0) {
				$tmp18 = strlen($s1) >= $l;
			} else {
				$tmp18 = true;
			}
			if($tmp18) {
				$tmp17 = $s1;
			} else {
				$tmp17 = str_pad($s1, Math::ceil(($l - strlen($s1)) / strlen("0")) * strlen("0") + strlen($s1), "0", STR_PAD_LEFT);
			}
			return call_user_func_array($decorate, array($tmp17, $f, "", $nf->signNegative, $nf->signPositive));
		}break;
		case "e":{
			$tmp19 = Math::abs($f);
			$tmp20 = thx_format_NumberFormat::exponential($tmp19, $precision, 0, "e", $culture);
			return call_user_func_array($decorate, array($tmp20, $f, "", $nf->signNegative, $nf->signPositive));
		}break;
		case "f":{
			$tmp21 = Math::abs($f);
			$tmp22 = thx_format_NumberFormat::fixed($tmp21, $precision, $culture);
			return call_user_func_array($decorate, array($tmp22, $f, "", $nf->signNegative, $nf->signPositive));
		}break;
		case "g":{
			$e1 = thx_format_NumberFormat::printf($f, "e", $culture);
			$f3 = thx_format_NumberFormat::printf($f, "f", $culture);
			if(strlen($e1) < strlen($f3)) {
				return $e1;
			} else {
				return $f3;
			}
		}break;
		case "o":{
			$tmp23 = Math::abs($f);
			$tmp24 = thx_format_NumberFormat::octal($tmp23, $precision, $culture);
			return call_user_func_array($decorate, array($tmp24, $f, "0", $nf->signNegative, $nf->signPositive));
		}break;
		case "u":{
			$tmp25 = Math::abs($f);
			return thx_format_NumberFormat::printf($tmp25, "d", $culture);
		}break;
		case "x":{
			$tmp26 = Math::abs($f);
			$tmp27 = thx_format_NumberFormat::hex($tmp26, $precision, $culture);
			return call_user_func_array($decorate, array($tmp27, $f, "0x", $nf->signNegative, $nf->signPositive));
		}break;
		default:{
			throw new HException("invalid pattern \"" . _hx_string_or_null($pattern) . "\"");
		}break;
		}
	}
	static function toBase($value, $base, $culture = null) {
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = null;
		if($base >= 2) {
			$tmp = $base > strlen(thx_format_NumberFormat::$BASE);
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException("invalid base " . _hx_string_rec($base, "") . ", it must be between 2 and " . _hx_string_rec(strlen(thx_format_NumberFormat::$BASE), ""));
		}
		$tmp1 = null;
		if($base !== 10) {
			$tmp1 = $value === 0;
		} else {
			$tmp1 = true;
		}
		if($tmp1) {
			return "" . _hx_string_rec($value, "");
		}
		$buf = "";
		$abs = null;
		if($value < 0) {
			$abs = -$value;
		} else {
			$abs = $value;
		}
		while($abs > 0) {
			$tmp2 = _hx_char_at(thx_format_NumberFormat::$BASE, _hx_mod($abs, $base));
			$buf = _hx_string_or_null($tmp2) . _hx_string_or_null($buf);
			$abs = Std::int($abs / $base);
			unset($tmp2);
		}
		$tmp3 = null;
		if($value < 0) {
			$tmp3 = $nf->signNegative;
		} else {
			$tmp3 = "";
		}
		return _hx_string_or_null($tmp3) . _hx_string_or_null($buf);
	}
	static function unit($f, $decimals, $unitSymbol, $culture = null) {
		$nf = thx_format_NumberFormat::numberFormat($culture);
		$tmp = Math::isNaN($f);
		if($tmp) {
			return $nf->symbolNaN;
		}
		$tmp1 = !Math::isFinite($f);
		if($tmp1) {
			if($f < 0) {
				return $nf->symbolNegativeInfinity;
			} else {
				return $nf->symbolPositiveInfinity;
			}
		}
		$pattern = null;
		if($f < 0) {
			$pattern = thx_culture_Pattern::$percentNegatives[$nf->patternNegativePercent];
		} else {
			$pattern = thx_culture_Pattern::$percentPositives[$nf->patternPositivePercent];
		}
		$formatted = thx_format_NumberFormat::value($f, $decimals, $nf->groupSizesPercent, $nf->separatorGroupPercent, $nf->separatorDecimalPercent);
		$s = str_replace("n", $formatted, $pattern);
		return str_replace("%", $unitSymbol, $s);
	}
	static $BASE = "0123456789abcdefghijklmnopqrstuvwxyz";
	static function countSymbols($pattern, $symbols) {
		$i = 0;
		$quote = 0;
		$count = 0;
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					$tmp = $quote;
					switch($tmp) {
					case 0:{
						$quote = 2;
					}break;
					case 2:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "'":{
					$tmp1 = $quote;
					switch($tmp1) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "\\":{
					++$i;
				}break;
				default:{
					if($quote === 0) {
						$tmp2 = null;
						if($_g !== "") {
							$tmp3 = _hx_index_of($symbols, $_g, null);
							$tmp2 = $tmp3 >= 0;
						} else {
							$tmp2 = true;
						}
						if($tmp2) {
							++$count;
						}
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		return $count;
	}
	static function customFormatDecimalFraction($d, $pattern, $nf) {
		$buf = "";
		$i = 0;
		$quote = 0;
		$p = thx_Strings::toArray($d);
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					$tmp = $quote;
					switch($tmp) {
					case 0:{
						$quote = 2;
					}break;
					case 1:{
						$buf .= _hx_string_or_null($_g);
					}break;
					case 2:{
						$quote = 0;
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "#":{
					switch($quote) {
					case 0:{
						$tmp1 = null;
						$tmp2 = $p->length === 0;
						if($tmp2) {
							$tmp1 = "";
						} else {
							$tmp1 = $p->shift();
						}
						$buf .= _hx_string_or_null($tmp1);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "\$":{
					switch($quote) {
					case 0:{
						$buf .= _hx_string_or_null($nf->symbolCurrency);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "%":{
					switch($quote) {
					case 0:{
						$buf .= _hx_string_or_null($nf->symbolPercent);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "'":{
					$tmp3 = $quote;
					switch($tmp3) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
					}break;
					case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "0":{
					switch($quote) {
					case 0:{
						$tmp4 = null;
						$tmp5 = $p->length === 0;
						if($tmp5) {
							$tmp4 = "0";
						} else {
							$tmp4 = $p->shift();
						}
						$buf .= _hx_string_or_null($tmp4);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "\\":{
					++$i;
					$tmp6 = _hx_substring($pattern, $i, $i + 1);
					$buf .= _hx_string_or_null($tmp6);
				}break;
				case "â€°":{
					switch($quote) {
					case 0:{
						$buf .= _hx_string_or_null($nf->symbolPermille);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				default:{
					switch($quote) {
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		return $buf;
	}
	static function customFormatF($f, $pattern, $nf, $isCurrency, $isPercent) {
		if($isPercent) {
			$tmp = null;
			$tmp1 = thx_format_NumberFormat::hasSymbols($pattern, "â€°");
			if($tmp1) {
				$tmp = 1000;
			} else {
				$tmp = 100;
			}
			$f *= $tmp;
		}
		$exp = thx_format_NumberFormat::splitPattern($pattern, "eE");
		$tmp2 = $exp->length > 1;
		if($tmp2) {
			$info = thx_format_NumberFormat::exponentialInfo($f);
			$tmp3 = strlen($exp[0]);
			$tmp4 = strlen($exp[0]) + 1;
			$symbol = _hx_substring($pattern, $tmp3, $tmp4);
			$forceSign = StringTools::startsWith($exp[1], "+");
			$tmp5 = null;
			if(!$forceSign) {
				$tmp5 = StringTools::startsWith($exp[1], "-");
			} else {
				$tmp5 = true;
			}
			if($tmp5) {
				$tmp6 = _hx_substring($exp[1], 1, null);
				$exp[1] = $tmp6;
			}
			$tmp7 = $info->f;
			$tmp8 = thx_format_NumberFormat::customIntegerAndFraction($tmp7, $exp[0], $nf, $isCurrency, $isPercent);
			$tmp9 = _hx_string_or_null($tmp8) . _hx_string_or_null($symbol);
			$tmp10 = null;
			if($info->e < 0) {
				$tmp10 = $nf->signNegative;
			} else {
				if($forceSign) {
					$tmp10 = $nf->signPositive;
				} else {
					$tmp10 = "";
				}
			}
			$tmp11 = _hx_string_or_null($tmp9) . _hx_string_or_null($tmp10);
			$tmp12 = Math::abs($info->e);
			$tmp13 = thx_format_NumberFormat::customFormatInteger("" . _hx_string_rec($tmp12, ""), $exp[1], $nf, $isCurrency, $isPercent);
			return _hx_string_or_null($tmp11) . _hx_string_or_null($tmp13);
		} else {
			return thx_format_NumberFormat::customIntegerAndFraction($f, $pattern, $nf, $isCurrency, $isPercent);
		}
	}
	static function customFormatInteger($v, $pattern, $nf, $isCurrency, $isPercent) {
		$buf = (new _hx_array(array()));
		$i = 0;
		$quote = 0;
		$p = thx_Strings::toArray($v);
		$lbuf = "";
		$first = true;
		$useGroups = false;
		$zeroes = 0;
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					switch($quote) {
					case 0:{
						$quote = 2;
					}break;
					case 1:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					case 2:{
						$quote = 0;
						$tmp = thx_format__NumberFormat_CustomFormat::Literal($lbuf);
						$buf->push($tmp);
						$lbuf = "";
					}break;
					default:{
						$tmp1 = thx_format__NumberFormat_CustomFormat::Literal($_g);
						$buf->push($tmp1);
					}break;
					}
				}break;
				case "#":{
					switch($quote) {
					case 0:{
						$tmp2 = thx_format__NumberFormat_CustomFormat::Hash($first);
						$buf->push($tmp2);
						$first = false;
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp3 = thx_format__NumberFormat_CustomFormat::Literal($_g);
						$buf->push($tmp3);
					}break;
					}
				}break;
				case "\$":{
					switch($quote) {
					case 0:{
						$tmp4 = thx_format__NumberFormat_CustomFormat::Literal($nf->symbolCurrency);
						$buf->push($tmp4);
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp5 = thx_format__NumberFormat_CustomFormat::Literal($_g);
						$buf->push($tmp5);
					}break;
					}
				}break;
				case "%":{
					switch($quote) {
					case 0:{
						$tmp6 = thx_format__NumberFormat_CustomFormat::Literal($nf->symbolPercent);
						$buf->push($tmp6);
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp7 = thx_format__NumberFormat_CustomFormat::Literal($_g);
						$buf->push($tmp7);
					}break;
					}
				}break;
				case "'":{
					switch($quote) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
						$tmp8 = thx_format__NumberFormat_CustomFormat::Literal($lbuf);
						$buf->push($tmp8);
						$lbuf = "";
					}break;
					case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp9 = thx_format__NumberFormat_CustomFormat::Literal($_g);
						$buf->push($tmp9);
					}break;
					}
				}break;
				case ",":{
					switch($quote) {
					case 0:{
						$useGroups = true;
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp10 = thx_format__NumberFormat_CustomFormat::Literal($_g);
						$buf->push($tmp10);
					}break;
					}
				}break;
				case "0":{
					switch($quote) {
					case 0:{
						$tmp11 = thx_format__NumberFormat_CustomFormat::Zero($first);
						$buf->push($tmp11);
						$first = false;
						++$zeroes;
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp12 = thx_format__NumberFormat_CustomFormat::Literal($_g);
						$buf->push($tmp12);
					}break;
					}
				}break;
				case "\\":{
					++$i;
					$tmp13 = _hx_substring($pattern, $i, $i + 1);
					$tmp14 = thx_format__NumberFormat_CustomFormat::Literal($tmp13);
					$buf->push($tmp14);
				}break;
				case "â€°":{
					switch($quote) {
					case 0:{
						$tmp15 = thx_format__NumberFormat_CustomFormat::Literal($nf->symbolPermille);
						$buf->push($tmp15);
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp16 = thx_format__NumberFormat_CustomFormat::Literal($_g);
						$buf->push($tmp16);
					}break;
					}
				}break;
				default:{
					switch($quote) {
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp17 = thx_format__NumberFormat_CustomFormat::Literal($_g);
						$buf->push($tmp17);
					}break;
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		$tmp18 = strlen($lbuf) > 0;
		if($tmp18) {
			$tmp19 = thx_format__NumberFormat_CustomFormat::Literal($lbuf);
			$buf->push($tmp19);
		}
		{
			$_g1 = $p->length;
			$_g2 = $zeroes;
			while($_g1 < $_g2) {
				++$_g1;
				$p->unshift("0");
			}
		}
		if($useGroups) {
			$i = $p->length - 1;
			$groups = null;
			if($isCurrency) {
				$groups = $nf->groupSizesCurrency->copy();
			} else {
				if($isPercent) {
					$groups = $nf->groupSizesPercent->copy();
				} else {
					$groups = $nf->groupSizesNumber->copy();
				}
			}
			$group = $groups->shift();
			$pos = 0;
			while($i >= 0) {
				if($group === 0) {
					break;
				}
				if($pos === $group) {
					$tmp20 = $p[$i];
					$tmp21 = null;
					if($isCurrency) {
						$tmp21 = $nf->separatorGroupCurrency;
					} else {
						if($isPercent) {
							$tmp21 = $nf->separatorGroupPercent;
						} else {
							$tmp21 = $nf->separatorGroupNumber;
						}
					}
					$p[$i] = _hx_string_or_null($tmp20) . _hx_string_or_null($tmp21);
					$pos = 0;
					$tmp22 = $groups->length > 0;
					if($tmp22) {
						$group = $groups->shift();
					}
					unset($tmp22,$tmp21,$tmp20);
				} else {
					++$pos;
					--$i;
				}
			}
		}
		$buf->reverse();
		$r = $buf->map(array(new _hx_lambda(array(&$p), "thx_format_NumberFormat_1"), 'execute'));
		$r->reverse();
		return $r->join("");
	}
	static function customIntegerAndFraction($f, $pattern, $nf, $isCurrency, $isPercent) {
		$p = thx_format_NumberFormat::splitPattern($pattern, ".");
		$tmp = strlen($p[0]);
		$power = $tmp - strlen(($p[0] = thx_Strings::trimCharsRight($p[0], ",")));
		$tmp1 = Math::pow(1000, $power);
		$f /= $tmp1;
		$tmp2 = $p->length === 1;
		if($tmp2) {
			$tmp3 = Math::round($f);
			return thx_format_NumberFormat::customFormatInteger("" . _hx_string_rec($tmp3, ""), $p[0], $nf, $isCurrency, $isPercent);
		} else {
			$tmp4 = thx_format_NumberFormat::countSymbols($p[1], "#0");
			$f = thx_Floats::roundTo($f, $tmp4);
			$np = thx_format_NumberFormat::splitOnDecimalSeparator($f);
			$tmp5 = thx_format_NumberFormat::customFormatInteger($np[0], $p[0], $nf, $isCurrency, $isPercent);
			$tmp6 = null;
			if($isCurrency) {
				$tmp6 = $nf->separatorDecimalCurrency;
			} else {
				if($isPercent) {
					$tmp6 = $nf->separatorDecimalPercent;
				} else {
					$tmp6 = $nf->separatorDecimalNumber;
				}
			}
			$tmp7 = _hx_string_or_null($tmp5) . _hx_string_or_null($tmp6);
			$t = null;
			if(null === $np) {
				$t = null;
			} else {
				$_1 = $np[1];
				if(null === $_1) {
					$t = null;
				} else {
					$t = $_1;
				}
			}
			$tmp8 = null;
			if($t !== null) {
				$tmp8 = $t;
			} else {
				$tmp8 = "0";
			}
			$tmp9 = thx_format_NumberFormat::customFormatDecimalFraction($tmp8, $p[1], $nf);
			return _hx_string_or_null($tmp7) . _hx_string_or_null($tmp9);
		}
	}
	static function exponentialInfo($f) {
		$tmp = Math::abs($f);
		$s = strtolower(("" . _hx_string_rec($tmp, "")));
		$pose = _hx_index_of($s, "e", null);
		$p = null;
		$e = null;
		if($pose > 0) {
			$p = _hx_explode(".", _hx_substring($s, 0, $pose));
			$tmp1 = _hx_substring($s, $pose + 1, null);
			$e = thx_Ints::parse($tmp1, null);
		} else {
			$p = _hx_explode(".", $s)->concat((new _hx_array(array(""))));
			$e = 0;
			$tmp2 = strlen($p[0]) > 1;
			if($tmp2) {
				$e = strlen($p[0]) - 1;
				$tmp3 = _hx_substring($p[0], 1, null);
				$p[1] = _hx_string_or_null($tmp3) . _hx_string_or_null($p[1]);
				$tmp4 = _hx_substring($p[0], 0, 1);
				$p[0] = $tmp4;
			} else {
				if($p[0] === "0") {
					$tmp5 = 1 + strlen($p[1]);
					$e = -($tmp5 - strlen(thx_Strings::trimCharsLeft($p[1], "0")));
					$tmp6 = _hx_substring($p[1], -$e - 1, null);
					$p[1] = $tmp6;
					$tmp7 = _hx_substring($p[1], 0, 1);
					$p[0] = $tmp7;
					$tmp8 = _hx_substring($p[1], 1, null);
					$p[1] = $tmp8;
				}
			}
		}
		$tmp9 = null;
		if($f < 0) {
			$tmp9 = -1;
		} else {
			$tmp9 = 1;
		}
		$tmp10 = $p->slice(0, 2)->join(".");
		$tmp11 = Std::parseFloat($tmp10);
		return _hx_anonymous(array("e" => $e, "f" => $tmp9 * $tmp11));
	}
	static function hasSymbols($pattern, $symbols) {
		$i = 0;
		$quote = 0;
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					$tmp = $quote;
					switch($tmp) {
					case 0:{
						$quote = 2;
					}break;
					case 2:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "'":{
					$tmp1 = $quote;
					switch($tmp1) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "\\":{
					++$i;
				}break;
				default:{
					if($quote === 0) {
						$tmp2 = null;
						if($_g !== "") {
							$tmp3 = _hx_index_of($symbols, $_g, null);
							$tmp2 = $tmp3 >= 0;
						} else {
							$tmp2 = true;
						}
						if($tmp2) {
							return true;
						}
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		return false;
	}
	static function intPart($s, $groupSizes, $groupSeparator) {
		$buf = (new _hx_array(array()));
		$sizes = $groupSizes->copy();
		$size = $sizes->shift();
		while(strlen($s) > 0) {
			if($size === 0) {
				$buf->unshift($s);
				$s = "";
			} else {
				$tmp = strlen($s) > $size;
				if($tmp) {
					$tmp1 = strlen($s) - $size;
					$tmp2 = _hx_substring($s, $tmp1, null);
					$buf->unshift($tmp2);
					$tmp3 = strlen($s) - $size;
					$s = _hx_substring($s, 0, $tmp3);
					$tmp4 = $sizes->length > 0;
					if($tmp4) {
						$size = $sizes->shift();
					}
					unset($tmp4,$tmp3,$tmp2,$tmp1);
				} else {
					$buf->unshift($s);
					$s = "";
				}
				unset($tmp);
			}
		}
		return $buf->join($groupSeparator);
	}
	static function numberFormat($culture) {
		$tmp = null;
		if(null !== $culture) {
			$tmp = null !== $culture->number;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return $culture->number;
		} else {
			return thx_format_Format::get_defaultCulture()->number;
		}
	}
	static function pad($s, $len, $round) {
		$_0 = $s;
		$t = null;
		if(null === $_0) {
			$t = null;
		} else {
			$t = $_0;
		}
		if($t !== null) {
			$s = $t;
		} else {
			$s = "";
		}
		$tmp = null;
		if($len > 0) {
			$tmp = strlen($s) > $len;
		} else {
			$tmp = false;
		}
		if($tmp) {
			if($round) {
				$tmp1 = _hx_substring($s, 0, $len - 1);
				$tmp2 = _hx_substring($s, $len - 1, $len);
				$tmp3 = Std::parseInt($tmp2);
				$tmp4 = null;
				$tmp5 = _hx_substring($s, $len, $len + 1);
				$tmp6 = Std::parseInt($tmp5);
				if($tmp6 >= 5) {
					$tmp4 = 1;
				} else {
					$tmp4 = 0;
				}
				return _hx_string_or_null($tmp1) . _hx_string_rec(($tmp3 + $tmp4), "");
			} else {
				return _hx_substring($s, 0, $len);
			}
		} else {
			$tmp7 = null;
			if(strlen("0") !== 0) {
				$tmp7 = strlen($s) >= $len;
			} else {
				$tmp7 = true;
			}
			if($tmp7) {
				return $s;
			} else {
				return str_pad($s, Math::ceil(($len - strlen($s)) / strlen("0")) * strlen("0") + strlen($s), "0", STR_PAD_RIGHT);
			}
		}
	}
	static function paramOrNull($param) {
		$tmp = strlen($param) === 0;
		if($tmp) {
			return null;
		} else {
			return Std::parseInt($param);
		}
	}
	static function splitOnDecimalSeparator($f) {
		$p = _hx_explode(".", ("" . _hx_string_rec($f, "")));
		$i = $p[0];
		$_0 = $p;
		$t = null;
		if(null === $_0) {
			$t = null;
		} else {
			$_1 = $_0[1];
			if(null === $_1) {
				$t = null;
			} else {
				$t = $_1;
			}
		}
		$tmp = null;
		if($t !== null) {
			$tmp = $t;
		} else {
			$tmp = "";
		}
		$d = strtolower($tmp);
		$tmp1 = _hx_index_of($d, "e", null);
		if($tmp1 >= 0) {
			$p = _hx_explode("e", $d);
			$d = $p[0];
			$e = thx_Ints::parse($p[1], null);
			if($e < 0) {
				$l = -$e - 1;
				$tmp2 = null;
				$tmp3 = null;
				if(strlen("0") !== 0) {
					$tmp3 = strlen("") >= $l;
				} else {
					$tmp3 = true;
				}
				if($tmp3) {
					$tmp2 = "";
				} else {
					$tmp2 = str_pad("", Math::ceil(($l - strlen("")) / strlen("0")) * strlen("0") + strlen(""), "0", STR_PAD_RIGHT);
				}
				$d = _hx_string_or_null($tmp2) . _hx_string_or_null($i) . _hx_string_or_null($d);
				$i = "0";
			} else {
				$s = _hx_string_or_null($i) . _hx_string_or_null($d);
				$d = _hx_substring($s, $e + 1, null);
				$i = thx_format_NumberFormat::pad($s, $e + 1, false);
			}
		}
		if(strlen($d) > 0) {
			return (new _hx_array(array($i, $d)));
		} else {
			return (new _hx_array(array($i)));
		}
	}
	static function splitPattern($pattern, $separator) {
		$pos = (new _hx_array(array()));
		$i = 0;
		$quote = 0;
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					$tmp = $quote;
					switch($tmp) {
					case 0:{
						$quote = 2;
					}break;
					case 2:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "'":{
					$tmp1 = $quote;
					switch($tmp1) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "\\":{
					++$i;
				}break;
				default:{
					if($quote === 0) {
						$tmp2 = null;
						if($_g !== "") {
							$tmp3 = _hx_index_of($separator, $_g, null);
							$tmp2 = $tmp3 >= 0;
						} else {
							$tmp2 = true;
						}
						if($tmp2) {
							$pos->push($i);
						}
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		$buf = (new _hx_array(array()));
		$prev = 0;
		{
			$_g1 = 0;
			while($_g1 < $pos->length) {
				$p = $pos[$_g1];
				++$_g1;
				$tmp4 = _hx_substring($pattern, $prev, $p);
				$buf->push($tmp4);
				$prev = $p + 1;
				unset($tmp4,$p);
			}
		}
		$tmp5 = _hx_substring($pattern, $prev, null);
		$buf->push($tmp5);
		return $buf;
	}
	static function value($f, $precision, $groupSizes, $groupSeparator, $decimalSeparator) {
		$tmp = thx_Floats::roundTo($f, $precision);
		$f = Math::abs($tmp);
		$p = thx_format_NumberFormat::splitOnDecimalSeparator($f);
		$buf = (new _hx_array(array()));
		$tmp1 = thx_format_NumberFormat::intPart($p[0], $groupSizes, $groupSeparator);
		$buf->push($tmp1);
		if($precision > 0) {
			$tmp2 = thx_format_NumberFormat::pad($p[1], $precision, true);
			$buf->push($tmp2);
		}
		return $buf->join($decimalSeparator);
	}
	function __toString() { return 'thx.format.NumberFormat'; }
}
function thx_format_NumberFormat_0(&$emptySpaceForSign, &$justifyRight, &$negativeSignOnly, &$padding, &$prefix, &$width, $s, $f1, $p1, $ns, $ps) {
	{
		if($prefix) {
			$s = _hx_string_or_null($p1) . _hx_string_or_null($s);
		}
		if($f1 < 0) {
			$s = _hx_string_or_null($ns) . _hx_string_or_null($s);
		} else {
			if(!$negativeSignOnly) {
				$s = _hx_string_or_null($ps) . _hx_string_or_null($s);
			} else {
				if($emptySpaceForSign) {
					$s = " " . _hx_string_or_null($s);
				}
			}
		}
		if($justifyRight) {
			$tmp5 = null;
			if(strlen($padding) !== 0) {
				$tmp5 = strlen($s) >= $width;
			} else {
				$tmp5 = true;
			}
			if($tmp5) {
				return $s;
			} else {
				return str_pad($s, Math::ceil(($width - strlen($s)) / strlen($padding)) * strlen($padding) + strlen($s), $padding, STR_PAD_LEFT);
			}
		} else {
			$tmp6 = null;
			if(strlen($padding) !== 0) {
				$tmp6 = strlen($s) >= $width;
			} else {
				$tmp6 = true;
			}
			if($tmp6) {
				return $s;
			} else {
				return str_pad($s, Math::ceil(($width - strlen($s)) / strlen($padding)) * strlen($padding) + strlen($s), $padding, STR_PAD_RIGHT);
			}
		}
	}
}
function thx_format_NumberFormat_1(&$p, $_) {
	{
		$tmp23 = $_->index;
		switch($tmp23) {
		case 0:{
			return _hx_deref($_)->params[0];
		}break;
		case 1:{
			$first1 = _hx_deref($_)->params[0];
			$tmp24 = $p->length === 0;
			if($tmp24) {
				return "";
			} else {
				if($first1) {
					return $p->join("");
				} else {
					return $p->pop();
				}
			}
		}break;
		case 2:{
			if(_hx_deref($_)->params[0]) {
				return $p->join("");
			} else {
				return $p->pop();
			}
		}break;
		}
	}
}
