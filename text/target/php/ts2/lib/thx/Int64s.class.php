<?php

// Generated by Haxe 3.3.0
class thx_Int64s {
	public function __construct(){}
	static $one;
	static $two;
	static $zero;
	static $ten;
	static $maxValue;
	static $minValue;
	static function abs($value) {
		$b = thx_Int64s::$zero;
		$v = $value->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$tmp = $v !== 0;
		if($tmp) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($value->low, $b->low);
		}
		$tmp1 = null;
		if($value->high < 0) {
			if($b->high < 0) {
				$tmp1 = $v;
			} else {
				$tmp1 = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp1 = $v;
			} else {
				$tmp1 = 1;
			}
		}
		if($tmp1 < 0) {
			$high = ~$value->high;
			$low = -$value->low;
			if($low === 0) {
				++$high;
				$tmp2 = $high << haxe__Int32_Int32_Impl_::$extraBits;
				$high = $tmp2 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x = new haxe__Int64____Int64($high, $low);
			return $x;
		} else {
			return $value;
		}
	}
	static function compare($a, $b) {
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$tmp = $v !== 0;
		if($tmp) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		$tmp1 = null;
		if($a->high < 0) {
			if($b->high < 0) {
				$tmp1 = $v;
			} else {
				$tmp1 = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp1 = $v;
			} else {
				$tmp1 = 1;
			}
		}
		if($tmp1 > 0) {
			return 1;
		} else {
			$v1 = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			$tmp2 = $v1 !== 0;
			if($tmp2) {
				$v1 = $v1;
			} else {
				$v1 = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
			}
			$tmp3 = null;
			if($a->high < 0) {
				if($b->high < 0) {
					$tmp3 = $v1;
				} else {
					$tmp3 = -1;
				}
			} else {
				if($b->high >= 0) {
					$tmp3 = $v1;
				} else {
					$tmp3 = 1;
				}
			}
			if($tmp3 < 0) {
				return -1;
			} else {
				return 0;
			}
		}
	}
	static function parse($s) {
		$sIsNegative = false;
		$x = new haxe__Int64____Int64(0, 1);
		$multiplier = $x;
		$x1 = new haxe__Int64____Int64(0, 0);
		$current = $x1;
		$tmp = _hx_char_at($s, 0);
		if($tmp === "-") {
			$sIsNegative = true;
			$s = _hx_substring($s, 1, strlen($s));
		}
		$len = strlen($s);
		{
			$_g1 = 0;
			while($_g1 < $len) {
				$i = $_g1++;
				$tmp1 = _hx_char_code_at($s, $len - 1 - $i);
				$digitInt = $tmp1 - 48;
				$tmp2 = null;
				if($digitInt >= 0) {
					$tmp2 = $digitInt > 9;
				} else {
					$tmp2 = true;
				}
				if($tmp2) {
					throw new HException(new thx_Error("String should only contain digits (and an optional - sign)", null, _hx_anonymous(array("fileName" => "Int64s.hx", "lineNumber" => 71, "className" => "thx.Int64s", "methodName" => "parse"))));
				}
				$x2 = new haxe__Int64____Int64($digitInt >> 31, $digitInt);
				$digit = $x2;
				if($sIsNegative) {
					$al = $multiplier->low & 65535;
					$ah = _hx_shift_right($multiplier->low, 16);
					$bl = $digit->low & 65535;
					$bh = _hx_shift_right($digit->low, 16);
					$p00 = haxe__Int32_Int32_Impl_::mul($al, $bl);
					$p10 = haxe__Int32_Int32_Impl_::mul($ah, $bl);
					$p01 = haxe__Int32_Int32_Impl_::mul($al, $bh);
					$p11 = haxe__Int32_Int32_Impl_::mul($ah, $bh);
					$low = $p00;
					$high = ($p11 + (_hx_shift_right($p01, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p10, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp3 = $p01 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
					$p01 = $tmp3 >> haxe__Int32_Int32_Impl_::$extraBits;
					$low = $p00 + $p01 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low, $p01) < 0) {
						++$high;
						$tmp4 = $high << haxe__Int32_Int32_Impl_::$extraBits;
						$high = $tmp4 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp4);
					}
					$tmp5 = $p10 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
					$p10 = $tmp5 >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp6 = $low + $p10 << haxe__Int32_Int32_Impl_::$extraBits;
					$low = $tmp6 >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low, $p10) < 0) {
						++$high;
						$tmp7 = $high << haxe__Int32_Int32_Impl_::$extraBits;
						$high = $tmp7 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp7);
					}
					$tmp8 = $high + (haxe__Int32_Int32_Impl_::mul($multiplier->low, $digit->high) + haxe__Int32_Int32_Impl_::mul($multiplier->high, $digit->low) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits;
					$high = $tmp8 >> haxe__Int32_Int32_Impl_::$extraBits;
					$x3 = new haxe__Int64____Int64($high, $low);
					$b = $x3;
					$high1 = $current->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low1 = $current->low - $b->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($current->low, $b->low) < 0) {
						--$high1;
						$tmp9 = $high1 << haxe__Int32_Int32_Impl_::$extraBits;
						$high1 = $tmp9 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp9);
					}
					$x4 = new haxe__Int64____Int64($high1, $low1);
					$current = $x4;
					$tmp10 = !($current->high < 0);
					if($tmp10) {
						throw new HException(new thx_Error("Int64 parsing error: Underflow", null, _hx_anonymous(array("fileName" => "Int64s.hx", "lineNumber" => 77, "className" => "thx.Int64s", "methodName" => "parse"))));
					}
					unset($x4,$x3,$tmp8,$tmp6,$tmp5,$tmp3,$tmp10,$p11,$p10,$p01,$p00,$low1,$low,$high1,$high,$bl,$bh,$b,$al,$ah);
				} else {
					$al1 = $multiplier->low & 65535;
					$ah1 = _hx_shift_right($multiplier->low, 16);
					$bl1 = $digit->low & 65535;
					$bh1 = _hx_shift_right($digit->low, 16);
					$p001 = haxe__Int32_Int32_Impl_::mul($al1, $bl1);
					$p101 = haxe__Int32_Int32_Impl_::mul($ah1, $bl1);
					$p011 = haxe__Int32_Int32_Impl_::mul($al1, $bh1);
					$p111 = haxe__Int32_Int32_Impl_::mul($ah1, $bh1);
					$low2 = $p001;
					$high2 = ($p111 + (_hx_shift_right($p011, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p101, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp11 = $p011 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
					$p011 = $tmp11 >> haxe__Int32_Int32_Impl_::$extraBits;
					$low2 = $p001 + $p011 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low2, $p011) < 0) {
						++$high2;
						$tmp12 = $high2 << haxe__Int32_Int32_Impl_::$extraBits;
						$high2 = $tmp12 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp12);
					}
					$tmp13 = $p101 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
					$p101 = $tmp13 >> haxe__Int32_Int32_Impl_::$extraBits;
					$tmp14 = $low2 + $p101 << haxe__Int32_Int32_Impl_::$extraBits;
					$low2 = $tmp14 >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low2, $p101) < 0) {
						++$high2;
						$tmp15 = $high2 << haxe__Int32_Int32_Impl_::$extraBits;
						$high2 = $tmp15 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp15);
					}
					$tmp16 = $high2 + (haxe__Int32_Int32_Impl_::mul($multiplier->low, $digit->high) + haxe__Int32_Int32_Impl_::mul($multiplier->high, $digit->low) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits;
					$high2 = $tmp16 >> haxe__Int32_Int32_Impl_::$extraBits;
					$x5 = new haxe__Int64____Int64($high2, $low2);
					$b1 = $x5;
					$high3 = $current->high + $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					$low3 = $current->low + $b1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
					if(haxe__Int32_Int32_Impl_::ucompare($low3, $current->low) < 0) {
						++$high3;
						$tmp17 = $high3 << haxe__Int32_Int32_Impl_::$extraBits;
						$high3 = $tmp17 >> haxe__Int32_Int32_Impl_::$extraBits;
						unset($tmp17);
					}
					$x6 = new haxe__Int64____Int64($high3, $low3);
					$current = $x6;
					$tmp18 = $current->high < 0;
					if($tmp18) {
						throw new HException(new thx_Error("Int64 parsing error: Overflow", null, _hx_anonymous(array("fileName" => "Int64s.hx", "lineNumber" => 81, "className" => "thx.Int64s", "methodName" => "parse"))));
					}
					unset($x6,$x5,$tmp18,$tmp16,$tmp14,$tmp13,$tmp11,$p111,$p101,$p011,$p001,$low3,$low2,$high3,$high2,$bl1,$bh1,$b1,$al1,$ah1);
				}
				$b2 = thx_Int64s::$ten;
				$al2 = $multiplier->low & 65535;
				$ah2 = _hx_shift_right($multiplier->low, 16);
				$bl2 = $b2->low & 65535;
				$bh2 = _hx_shift_right($b2->low, 16);
				$p002 = haxe__Int32_Int32_Impl_::mul($al2, $bl2);
				$p102 = haxe__Int32_Int32_Impl_::mul($ah2, $bl2);
				$p012 = haxe__Int32_Int32_Impl_::mul($al2, $bh2);
				$p112 = haxe__Int32_Int32_Impl_::mul($ah2, $bh2);
				$low4 = $p002;
				$high4 = ($p112 + (_hx_shift_right($p012, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) + (_hx_shift_right($p102, 16)) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$tmp19 = $p012 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
				$p012 = $tmp19 >> haxe__Int32_Int32_Impl_::$extraBits;
				$low4 = $p002 + $p012 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low4, $p012) < 0) {
					++$high4;
					$tmp20 = $high4 << haxe__Int32_Int32_Impl_::$extraBits;
					$high4 = $tmp20 >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($tmp20);
				}
				$tmp21 = $p102 << 16 << haxe__Int32_Int32_Impl_::$extraBits;
				$p102 = $tmp21 >> haxe__Int32_Int32_Impl_::$extraBits;
				$tmp22 = $low4 + $p102 << haxe__Int32_Int32_Impl_::$extraBits;
				$low4 = $tmp22 >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low4, $p102) < 0) {
					++$high4;
					$tmp23 = $high4 << haxe__Int32_Int32_Impl_::$extraBits;
					$high4 = $tmp23 >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($tmp23);
				}
				$tmp24 = $high4 + (haxe__Int32_Int32_Impl_::mul($multiplier->low, $b2->high) + haxe__Int32_Int32_Impl_::mul($multiplier->high, $b2->low) << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits) << haxe__Int32_Int32_Impl_::$extraBits;
				$high4 = $tmp24 >> haxe__Int32_Int32_Impl_::$extraBits;
				$x7 = new haxe__Int64____Int64($high4, $low4);
				$multiplier = $x7;
				unset($x7,$x2,$tmp24,$tmp22,$tmp21,$tmp2,$tmp19,$tmp1,$p112,$p102,$p012,$p002,$low4,$i,$high4,$digitInt,$digit,$bl2,$bh2,$b2,$al2,$ah2);
			}
		}
		return $current;
	}
	static function toInt64($s) {
		return thx_Int64s::parse($s);
	}
	static function divRound($num, $div) {
		$x = new haxe__Int64____Int64(0, 0);
		$b = $x;
		$tmp = null;
		if($num->high === $b->high) {
			$tmp = $num->low === $b->low;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return thx_Int64s::$zero;
		}
		$x1 = new haxe__Int64____Int64(0, 0);
		$b1 = $x1;
		$tmp1 = null;
		if($div->high === $b1->high) {
			$tmp1 = $div->low === $b1->low;
		} else {
			$tmp1 = false;
		}
		if($tmp1) {
			throw new HException(new thx_Error("Int64s.divRound division by zero", null, _hx_anonymous(array("fileName" => "Int64s.hx", "lineNumber" => 98, "className" => "thx.Int64s", "methodName" => "divRound"))));
		}
		$tmp2 = (is_object($_t = $num->high < 0) && ($_t instanceof Enum) ? $_t == $div->high < 0 : _hx_equal($_t, $div->high < 0));
		if($tmp2) {
			$b2 = thx_Int64s::$two;
			$b3 = haxe__Int64_Int64_Impl_::divMod($div, $b2)->quotient;
			$high = $num->high + $b3->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			$low = $num->low + $b3->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			if(haxe__Int32_Int32_Impl_::ucompare($low, $num->low) < 0) {
				++$high;
				$tmp3 = $high << haxe__Int32_Int32_Impl_::$extraBits;
				$high = $tmp3 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x2 = new haxe__Int64____Int64($high, $low);
			return haxe__Int64_Int64_Impl_::divMod($x2, $div)->quotient;
		} else {
			$tmp4 = $div->high < 0;
			if($tmp4) {
				$high1 = ~$num->high;
				$low1 = -$num->low;
				if($low1 === 0) {
					++$high1;
					$tmp5 = $high1 << haxe__Int32_Int32_Impl_::$extraBits;
					$high1 = $tmp5 >> haxe__Int32_Int32_Impl_::$extraBits;
				}
				$x3 = new haxe__Int64____Int64($high1, $low1);
				$a = $x3;
				$b4 = thx_Int64s::$one;
				$high2 = $a->high + $b4->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low2 = $a->low + $b4->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low2, $a->low) < 0) {
					++$high2;
					$tmp6 = $high2 << haxe__Int32_Int32_Impl_::$extraBits;
					$high2 = $tmp6 >> haxe__Int32_Int32_Impl_::$extraBits;
				}
				$x4 = new haxe__Int64____Int64($high2, $low2);
				$a1 = $x4;
				$b5 = thx_Int64s::$two;
				$b6 = haxe__Int64_Int64_Impl_::divMod($div, $b5)->quotient;
				$high3 = $a1->high + $b6->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low3 = $a1->low + $b6->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low3, $a1->low) < 0) {
					++$high3;
					$tmp7 = $high3 << haxe__Int32_Int32_Impl_::$extraBits;
					$high3 = $tmp7 >> haxe__Int32_Int32_Impl_::$extraBits;
				}
				$x5 = new haxe__Int64____Int64($high3, $low3);
				$a2 = $x5;
				$high4 = ~$div->high;
				$low4 = -$div->low;
				if($low4 === 0) {
					++$high4;
					$tmp8 = $high4 << haxe__Int32_Int32_Impl_::$extraBits;
					$high4 = $tmp8 >> haxe__Int32_Int32_Impl_::$extraBits;
				}
				$x6 = new haxe__Int64____Int64($high4, $low4);
				return haxe__Int64_Int64_Impl_::divMod($a2, $x6)->quotient;
			} else {
				$b7 = thx_Int64s::$one;
				$high5 = $num->high + $b7->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low5 = $num->low + $b7->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low5, $num->low) < 0) {
					++$high5;
					$tmp9 = $high5 << haxe__Int32_Int32_Impl_::$extraBits;
					$high5 = $tmp9 >> haxe__Int32_Int32_Impl_::$extraBits;
				}
				$x7 = new haxe__Int64____Int64($high5, $low5);
				$a3 = $x7;
				$b8 = thx_Int64s::$two;
				$b9 = haxe__Int64_Int64_Impl_::divMod($div, $b8)->quotient;
				$high6 = $a3->high - $b9->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low6 = $a3->low - $b9->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($a3->low, $b9->low) < 0) {
					--$high6;
					$tmp10 = $high6 << haxe__Int32_Int32_Impl_::$extraBits;
					$high6 = $tmp10 >> haxe__Int32_Int32_Impl_::$extraBits;
				}
				$x8 = new haxe__Int64____Int64($high6, $low6);
				return haxe__Int64_Int64_Impl_::divMod($x8, $div)->quotient;
			}
		}
	}
	static function divFloor($num, $div) {
		$x = new haxe__Int64____Int64(0, 0);
		$b = $x;
		$tmp = null;
		if($num->high === $b->high) {
			$tmp = $num->low === $b->low;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return thx_Int64s::$zero;
		}
		$x1 = new haxe__Int64____Int64(0, 0);
		$b1 = $x1;
		$tmp1 = null;
		if($div->high === $b1->high) {
			$tmp1 = $div->low === $b1->low;
		} else {
			$tmp1 = false;
		}
		if($tmp1) {
			throw new HException(new thx_Error("Int64s.divFloor division by zero", null, _hx_anonymous(array("fileName" => "Int64s.hx", "lineNumber" => 112, "className" => "thx.Int64s", "methodName" => "divFloor"))));
		}
		$a = haxe__Int64_Int64_Impl_::divMod($num, $div)->quotient;
		$x2 = null;
		if((is_object($_t = $num->high < 0) && ($_t instanceof Enum) ? $_t != $div->high < 0 : !_hx_equal($_t, $div->high < 0))) {
			$x2 = 1;
		} else {
			$x2 = 0;
		}
		$x3 = new haxe__Int64____Int64($x2 >> 31, $x2);
		$b2 = $x3;
		$high = $a->high - $b2->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$low = $a->low - $b2->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		if(haxe__Int32_Int32_Impl_::ucompare($a->low, $b2->low) < 0) {
			--$high;
			$tmp2 = $high << haxe__Int32_Int32_Impl_::$extraBits;
			$high = $tmp2 >> haxe__Int32_Int32_Impl_::$extraBits;
		}
		$x4 = new haxe__Int64____Int64($high, $low);
		return $x4;
	}
	static function divCeil($num, $div) {
		$x = new haxe__Int64____Int64(0, 0);
		$b = $x;
		$tmp = null;
		if($num->high === $b->high) {
			$tmp = $num->low === $b->low;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return thx_Int64s::$zero;
		}
		$x1 = new haxe__Int64____Int64(0, 0);
		$b1 = $x1;
		$tmp1 = null;
		if($div->high === $b1->high) {
			$tmp1 = $div->low === $b1->low;
		} else {
			$tmp1 = false;
		}
		if($tmp1) {
			throw new HException(new thx_Error("Int64s.divCeil division by zero", null, _hx_anonymous(array("fileName" => "Int64s.hx", "lineNumber" => 120, "className" => "thx.Int64s", "methodName" => "divCeil"))));
		}
		$r = haxe__Int64_Int64_Impl_::divMod($num, $div);
		$q = $r->quotient;
		$m = $r->modulus;
		$tmp2 = null;
		if((is_object($_t = $num->high < 0) && ($_t instanceof Enum) ? $_t == $div->high < 0 : _hx_equal($_t, $div->high < 0))) {
			$x2 = new haxe__Int64____Int64(0, 0);
			$b2 = $x2;
			$tmp3 = null;
			if($m->high === $b2->high) {
				$tmp3 = $m->low === $b2->low;
			} else {
				$tmp3 = false;
			}
			$tmp2 = !$tmp3;
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			$b3 = thx_Int64s::$one;
			$high = $q->high + $b3->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			$low = $q->low + $b3->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			if(haxe__Int32_Int32_Impl_::ucompare($low, $q->low) < 0) {
				++$high;
				$tmp4 = $high << haxe__Int32_Int32_Impl_::$extraBits;
				$high = $tmp4 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x3 = new haxe__Int64____Int64($high, $low);
			return $x3;
		} else {
			return $q;
		}
	}
	static $min;
	static function toFloat($i) {
		$isNegative = false;
		$x = new haxe__Int64____Int64(0, 0);
		$b = $x;
		$v = $i->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$tmp = $v !== 0;
		if($tmp) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($i->low, $b->low);
		}
		$tmp1 = null;
		if($i->high < 0) {
			if($b->high < 0) {
				$tmp1 = $v;
			} else {
				$tmp1 = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp1 = $v;
			} else {
				$tmp1 = 1;
			}
		}
		if($tmp1 < 0) {
			$b1 = thx_Int64s::$min;
			$v1 = $i->high - $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
			$tmp2 = $v1 !== 0;
			if($tmp2) {
				$v1 = $v1;
			} else {
				$v1 = haxe__Int32_Int32_Impl_::ucompare($i->low, $b1->low);
			}
			$tmp3 = null;
			if($i->high < 0) {
				if($b1->high < 0) {
					$tmp3 = $v1;
				} else {
					$tmp3 = -1;
				}
			} else {
				if($b1->high >= 0) {
					$tmp3 = $v1;
				} else {
					$tmp3 = 1;
				}
			}
			if($tmp3 < 0) {
				return -9223372036854775808.0;
			}
			$isNegative = true;
			$high = ~$i->high;
			$low = -$i->low;
			if($low === 0) {
				++$high;
				$tmp4 = $high << haxe__Int32_Int32_Impl_::$extraBits;
				$high = $tmp4 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x1 = new haxe__Int64____Int64($high, $low);
			$i = $x1;
		}
		$multiplier = 1.0;
		$ret = 0.0;
		{
			$_g = 0;
			while($_g < 64) {
				++$_g;
				$b2 = thx_Int64s::$one;
				$x2 = new haxe__Int64____Int64($i->high & $b2->high, $i->low & $b2->low);
				$a = $x2;
				$b3 = thx_Int64s::$zero;
				$tmp5 = null;
				if(!($a->high !== $b3->high)) {
					$tmp5 = $a->low !== $b3->low;
				} else {
					$tmp5 = true;
				}
				if($tmp5) {
					$ret += $multiplier;
				}
				$multiplier *= 2.0;
				{
					$x3 = new haxe__Int64____Int64($i->high >> 1, $i->high << 31 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($i->low, 1));
					$i = $x3;
					unset($x3);
				}
				unset($x2,$tmp5,$b3,$b2,$a);
			}
		}
		$tmp6 = null;
		if($isNegative) {
			$tmp6 = -1;
		} else {
			$tmp6 = 1;
		}
		return $tmp6 * $ret;
	}
	static function fromFloat($f) {
		$tmp = null;
		$tmp1 = !Math::isNaN($f);
		if($tmp1) {
			$tmp = !Math::isFinite($f);
		} else {
			$tmp = true;
		}
		if($tmp) {
			throw new HException(new thx_Error("Conversion to Int64 failed. Number is NaN or Infinite", null, _hx_anonymous(array("fileName" => "Int64s.hx", "lineNumber" => 163, "className" => "thx.Int64s", "methodName" => "fromFloat"))));
		}
		$noFractions = $f - _hx_mod($f, 1);
		if($noFractions > 9007199254740991.0) {
			throw new HException(new thx_Error("Conversion to Int64 failed. Conversion overflow", null, _hx_anonymous(array("fileName" => "Int64s.hx", "lineNumber" => 169, "className" => "thx.Int64s", "methodName" => "fromFloat"))));
		}
		if($noFractions < -9007199254740991.0) {
			throw new HException(new thx_Error("Conversion to Int64 failed. Conversion underflow", null, _hx_anonymous(array("fileName" => "Int64s.hx", "lineNumber" => 171, "className" => "thx.Int64s", "methodName" => "fromFloat"))));
		}
		$result = thx_Int64s::$zero;
		$neg = $noFractions < 0.0;
		$rest = null;
		if($neg) {
			$rest = -$noFractions;
		} else {
			$rest = $noFractions;
		}
		$i = 0;
		$curr = null;
		while($rest >= 1) {
			$curr = _hx_mod($rest, 2);
			$rest /= 2;
			if($curr >= 1) {
				$x = new haxe__Int64____Int64(0, 1);
				$a = $x;
				$b = $i;
				$b &= 63;
				$b1 = null;
				if($b === 0) {
					$x1 = new haxe__Int64____Int64($a->high, $a->low);
					$b1 = $x1;
					unset($x1);
				} else {
					if($b < 32) {
						$x2 = new haxe__Int64____Int64($a->high << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits | _hx_shift_right($a->low, 32 - $b), $a->low << $b << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits);
						$b1 = $x2;
						unset($x2);
					} else {
						$x3 = new haxe__Int64____Int64($a->low << $b - 32 << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits, 0);
						$b1 = $x3;
						unset($x3);
					}
				}
				$high = $result->high + $b1->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				$low = $result->low + $b1->low << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
				if(haxe__Int32_Int32_Impl_::ucompare($low, $result->low) < 0) {
					++$high;
					$tmp2 = $high << haxe__Int32_Int32_Impl_::$extraBits;
					$high = $tmp2 >> haxe__Int32_Int32_Impl_::$extraBits;
					unset($tmp2);
				}
				$x4 = new haxe__Int64____Int64($high, $low);
				$result = $x4;
				unset($x4,$x,$low,$high,$b1,$b,$a);
			}
			++$i;
		}
		if($neg) {
			$high1 = ~$result->high;
			$low1 = -$result->low;
			if($low1 === 0) {
				++$high1;
				$tmp3 = $high1 << haxe__Int32_Int32_Impl_::$extraBits;
				$high1 = $tmp3 >> haxe__Int32_Int32_Impl_::$extraBits;
			}
			$x5 = new haxe__Int64____Int64($high1, $low1);
			return $x5;
		} else {
			return $result;
		}
	}
	function __toString() { return 'thx.Int64s'; }
}
thx_Int64s::$one = thx_Int64s_0();
thx_Int64s::$two = thx_Int64s_1();
thx_Int64s::$zero = thx_Int64s_2();
thx_Int64s::$ten = thx_Int64s_3();
thx_Int64s::$maxValue = thx_Int64s_4();
thx_Int64s::$minValue = thx_Int64s_5();
thx_Int64s::$min = thx_Int64s_6();
function thx_Int64s_0() {
	{
		$x = new haxe__Int64____Int64(0, 1);
		return $x;
	}
}
function thx_Int64s_1() {
	{
		$x = new haxe__Int64____Int64(0, 2);
		return $x;
	}
}
function thx_Int64s_2() {
	{
		$x = new haxe__Int64____Int64(0, 0);
		return $x;
	}
}
function thx_Int64s_3() {
	{
		$x = new haxe__Int64____Int64(0, 10);
		return $x;
	}
}
function thx_Int64s_4() {
	{
		$x = new haxe__Int64____Int64(2147483647, -1);
		return $x;
	}
}
function thx_Int64s_5() {
	{
		$x = new haxe__Int64____Int64(-2147483648, 1);
		return $x;
	}
}
function thx_Int64s_6() {
	{
		$x = new haxe__Int64____Int64(-2147483648, 0);
		return $x;
	}
}
