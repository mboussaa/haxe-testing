// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_List
#include <List.h>
#endif
#ifndef INCLUDED__List_ListIterator
#include <_List/ListIterator.h>
#endif
#ifndef INCLUDED__List_ListNode
#include <_List/ListNode.h>
#endif
#ifndef INCLUDED_utest_Assertation
#include <utest/Assertation.h>
#endif
#ifndef INCLUDED_utest_ui_common_FixtureResult
#include <utest/ui/common/FixtureResult.h>
#endif
#ifndef INCLUDED_utest_ui_common_ResultStats
#include <utest/ui/common/ResultStats.h>
#endif

namespace utest{
namespace ui{
namespace common{

void FixtureResult_obj::__construct(::String methodName){
            	HX_STACK_FRAME("utest.ui.common.FixtureResult","new",0x11574508,"utest.ui.common.FixtureResult.new","utest/ui/common/FixtureResult.hx",16,0xca57a2c9)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(methodName,"methodName")
HXLINE(  17)		this->methodName = methodName;
HXLINE(  18)		this->list =  ::List_obj::__new();
HXLINE(  19)		this->hasTestError = false;
HXLINE(  20)		this->hasSetupError = false;
HXLINE(  21)		this->hasTeardownError = false;
HXLINE(  22)		this->hasTimeoutError = false;
HXLINE(  23)		this->hasAsyncError = false;
HXLINE(  25)		this->stats =  ::utest::ui::common::ResultStats_obj::__new();
            	}

Dynamic FixtureResult_obj::__CreateEmpty() { return new FixtureResult_obj; }

hx::ObjectPtr< FixtureResult_obj > FixtureResult_obj::__new(::String methodName)
{
	hx::ObjectPtr< FixtureResult_obj > _hx_result = new FixtureResult_obj();
	_hx_result->__construct(methodName);
	return _hx_result;
}

Dynamic FixtureResult_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< FixtureResult_obj > _hx_result = new FixtureResult_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

 ::_List::ListIterator FixtureResult_obj::iterator(){
            	HX_STACK_FRAME("utest.ui.common.FixtureResult","iterator",0x8986f446,"utest.ui.common.FixtureResult.iterator","utest/ui/common/FixtureResult.hx",29,0xca57a2c9)
            	HX_STACK_THIS(this)
HXLINE(  29)		return  ::_List::ListIterator_obj::__new(this->list->h);
            	}


HX_DEFINE_DYNAMIC_FUNC0(FixtureResult_obj,iterator,return )

void FixtureResult_obj::add(::hx::EnumBase assertation){
            	HX_STACK_FRAME("utest.ui.common.FixtureResult","add",0x114d66c9,"utest.ui.common.FixtureResult.add","utest/ui/common/FixtureResult.hx",31,0xca57a2c9)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(assertation,"assertation")
HXLINE(  32)		this->list->add(assertation);
HXLINE(  33)		Int _hx_tmp = ( ( ::hx::EnumBase)(assertation) )->_hx_getIndex();
HXDLIN(  33)		switch((int)(_hx_tmp)){
            			case (int)0: {
HXLINE(  35)				this->stats->addSuccesses((int)1);
            			}
            			break;
            			case (int)1: {
HXLINE(  37)				this->stats->addFailures((int)1);
            			}
            			break;
            			case (int)2: {
HXLINE(  39)				this->stats->addErrors((int)1);
            			}
            			break;
            			case (int)3: {
HXLINE(  41)				this->stats->addErrors((int)1);
HXLINE(  42)				this->hasSetupError = true;
            			}
            			break;
            			case (int)4: {
HXLINE(  44)				this->stats->addErrors((int)1);
HXLINE(  45)				this->hasTeardownError = true;
            			}
            			break;
            			case (int)5: {
HXLINE(  47)				this->stats->addErrors((int)1);
HXLINE(  48)				this->hasTimeoutError = true;
            			}
            			break;
            			case (int)6: {
HXLINE(  50)				this->stats->addErrors((int)1);
HXLINE(  51)				this->hasAsyncError = true;
            			}
            			break;
            			case (int)7: {
HXLINE(  53)				this->stats->addWarnings((int)1);
            			}
            			break;
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC1(FixtureResult_obj,add,(void))


FixtureResult_obj::FixtureResult_obj()
{
}

void FixtureResult_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(FixtureResult);
	HX_MARK_MEMBER_NAME(methodName,"methodName");
	HX_MARK_MEMBER_NAME(hasTestError,"hasTestError");
	HX_MARK_MEMBER_NAME(hasSetupError,"hasSetupError");
	HX_MARK_MEMBER_NAME(hasTeardownError,"hasTeardownError");
	HX_MARK_MEMBER_NAME(hasTimeoutError,"hasTimeoutError");
	HX_MARK_MEMBER_NAME(hasAsyncError,"hasAsyncError");
	HX_MARK_MEMBER_NAME(stats,"stats");
	HX_MARK_MEMBER_NAME(list,"list");
	HX_MARK_END_CLASS();
}

void FixtureResult_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(methodName,"methodName");
	HX_VISIT_MEMBER_NAME(hasTestError,"hasTestError");
	HX_VISIT_MEMBER_NAME(hasSetupError,"hasSetupError");
	HX_VISIT_MEMBER_NAME(hasTeardownError,"hasTeardownError");
	HX_VISIT_MEMBER_NAME(hasTimeoutError,"hasTimeoutError");
	HX_VISIT_MEMBER_NAME(hasAsyncError,"hasAsyncError");
	HX_VISIT_MEMBER_NAME(stats,"stats");
	HX_VISIT_MEMBER_NAME(list,"list");
}

hx::Val FixtureResult_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 3:
		if (HX_FIELD_EQ(inName,"add") ) { return hx::Val( add_dyn()); }
		break;
	case 4:
		if (HX_FIELD_EQ(inName,"list") ) { return hx::Val( list); }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"stats") ) { return hx::Val( stats); }
		break;
	case 8:
		if (HX_FIELD_EQ(inName,"iterator") ) { return hx::Val( iterator_dyn()); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"methodName") ) { return hx::Val( methodName); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"hasTestError") ) { return hx::Val( hasTestError); }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"hasSetupError") ) { return hx::Val( hasSetupError); }
		if (HX_FIELD_EQ(inName,"hasAsyncError") ) { return hx::Val( hasAsyncError); }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"hasTimeoutError") ) { return hx::Val( hasTimeoutError); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"hasTeardownError") ) { return hx::Val( hasTeardownError); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val FixtureResult_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 4:
		if (HX_FIELD_EQ(inName,"list") ) { list=inValue.Cast<  ::List >(); return inValue; }
		break;
	case 5:
		if (HX_FIELD_EQ(inName,"stats") ) { stats=inValue.Cast<  ::utest::ui::common::ResultStats >(); return inValue; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"methodName") ) { methodName=inValue.Cast< ::String >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"hasTestError") ) { hasTestError=inValue.Cast< Bool >(); return inValue; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"hasSetupError") ) { hasSetupError=inValue.Cast< Bool >(); return inValue; }
		if (HX_FIELD_EQ(inName,"hasAsyncError") ) { hasAsyncError=inValue.Cast< Bool >(); return inValue; }
		break;
	case 15:
		if (HX_FIELD_EQ(inName,"hasTimeoutError") ) { hasTimeoutError=inValue.Cast< Bool >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"hasTeardownError") ) { hasTeardownError=inValue.Cast< Bool >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void FixtureResult_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("methodName","\xcc","\x19","\x0f","\x12"));
	outFields->push(HX_HCSTRING("hasTestError","\x5c","\xef","\x7d","\xc9"));
	outFields->push(HX_HCSTRING("hasSetupError","\x05","\xa0","\x83","\x6f"));
	outFields->push(HX_HCSTRING("hasTeardownError","\x6a","\xc3","\x23","\xa5"));
	outFields->push(HX_HCSTRING("hasTimeoutError","\xe1","\x23","\x47","\x5c"));
	outFields->push(HX_HCSTRING("hasAsyncError","\xe6","\x3a","\xbd","\x3b"));
	outFields->push(HX_HCSTRING("stats","\x1f","\x76","\x0b","\x84"));
	outFields->push(HX_HCSTRING("list","\x5e","\x1c","\xb3","\x47"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo FixtureResult_obj_sMemberStorageInfo[] = {
	{hx::fsString,(int)offsetof(FixtureResult_obj,methodName),HX_HCSTRING("methodName","\xcc","\x19","\x0f","\x12")},
	{hx::fsBool,(int)offsetof(FixtureResult_obj,hasTestError),HX_HCSTRING("hasTestError","\x5c","\xef","\x7d","\xc9")},
	{hx::fsBool,(int)offsetof(FixtureResult_obj,hasSetupError),HX_HCSTRING("hasSetupError","\x05","\xa0","\x83","\x6f")},
	{hx::fsBool,(int)offsetof(FixtureResult_obj,hasTeardownError),HX_HCSTRING("hasTeardownError","\x6a","\xc3","\x23","\xa5")},
	{hx::fsBool,(int)offsetof(FixtureResult_obj,hasTimeoutError),HX_HCSTRING("hasTimeoutError","\xe1","\x23","\x47","\x5c")},
	{hx::fsBool,(int)offsetof(FixtureResult_obj,hasAsyncError),HX_HCSTRING("hasAsyncError","\xe6","\x3a","\xbd","\x3b")},
	{hx::fsObject /*::utest::ui::common::ResultStats*/ ,(int)offsetof(FixtureResult_obj,stats),HX_HCSTRING("stats","\x1f","\x76","\x0b","\x84")},
	{hx::fsObject /*::List*/ ,(int)offsetof(FixtureResult_obj,list),HX_HCSTRING("list","\x5e","\x1c","\xb3","\x47")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *FixtureResult_obj_sStaticStorageInfo = 0;
#endif

static ::String FixtureResult_obj_sMemberFields[] = {
	HX_HCSTRING("methodName","\xcc","\x19","\x0f","\x12"),
	HX_HCSTRING("hasTestError","\x5c","\xef","\x7d","\xc9"),
	HX_HCSTRING("hasSetupError","\x05","\xa0","\x83","\x6f"),
	HX_HCSTRING("hasTeardownError","\x6a","\xc3","\x23","\xa5"),
	HX_HCSTRING("hasTimeoutError","\xe1","\x23","\x47","\x5c"),
	HX_HCSTRING("hasAsyncError","\xe6","\x3a","\xbd","\x3b"),
	HX_HCSTRING("stats","\x1f","\x76","\x0b","\x84"),
	HX_HCSTRING("list","\x5e","\x1c","\xb3","\x47"),
	HX_HCSTRING("iterator","\xee","\x49","\x9a","\x93"),
	HX_HCSTRING("add","\x21","\xf2","\x49","\x00"),
	::String(null()) };

static void FixtureResult_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(FixtureResult_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void FixtureResult_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(FixtureResult_obj::__mClass,"__mClass");
};

#endif

hx::Class FixtureResult_obj::__mClass;

void FixtureResult_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("utest.ui.common.FixtureResult","\x16","\x61","\x86","\xae");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = FixtureResult_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(FixtureResult_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< FixtureResult_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = FixtureResult_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = FixtureResult_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = FixtureResult_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace utest
} // end namespace ui
} // end namespace common
