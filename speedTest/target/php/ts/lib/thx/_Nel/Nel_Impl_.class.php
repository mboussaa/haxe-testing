<?php

// Generated by Haxe 3.3.0
class thx__Nel_Nel_Impl_ {
	public function __construct(){}
	static function nel($hd, $tl) {
		$_g = thx__Nel_Nel_Impl_::fromArray($tl);
		$tmp = $_g->index;
		switch($tmp) {
		case 0:{
			return thx__Nel_Nel_Impl_::cons($hd, _hx_deref($_g)->params[0]);
		}break;
		case 1:{
			return thx__Nel_Nel_Impl_::pure($hd);
		}break;
		}
	}
	static function pure($a) {
		return thx_NonEmptyList::Single($a);
	}
	static function cons($a, $nl) {
		return thx_NonEmptyList::ConsNel($a, $nl);
	}
	static function fromArray($arr) {
		$tmp = $arr->length === 0;
		if($tmp) {
			return haxe_ds_Option::$None;
		} else {
			$tmp1 = $arr[$arr->length - 1];
			$res = thx_NonEmptyList::Single($tmp1);
			{
				$tmp2 = thx_Ints::rangeIter($arr->length - 2, -1, -1);
				while(true) {
					$tmp3 = !$tmp2->hasNext();
					if($tmp3) {
						break;
					}
					$i = $tmp2->next();
					$res = thx_NonEmptyList::ConsNel($arr[$i], $res);
					unset($tmp3,$i);
				}
			}
			return haxe_ds_Option::Some($res);
		}
	}
	static function map($this1, $f) {
		$fb = $f;
		$tmp = array(new _hx_lambda(array(&$fb), "thx__Nel_Nel_Impl__0"), 'execute');
		return thx__Nel_Nel_Impl_::flatMap($this1, $tmp);
	}
	static function flatMap($this1, $f) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return call_user_func_array($f, array(_hx_deref($this1)->params[0]));
		}break;
		case 1:{
			$xs = _hx_deref($this1)->params[1];
			$tmp1 = call_user_func_array($f, array(_hx_deref($this1)->params[0]));
			$tmp2 = thx__Nel_Nel_Impl_::flatMap($xs, $f);
			return thx__Nel_Nel_Impl_::append($tmp1, $tmp2);
		}break;
		}
	}
	static function fold($this1, $s) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return _hx_deref($this1)->params[0];
		}break;
		case 1:{
			$xs = _hx_deref($this1)->params[1];
			$x = _hx_deref($this1)->params[0];
			$tmp1 = thx__Semigroup_Semigroup_Impl_::get_append($s);
			$tmp2 = thx__Nel_Nel_Impl_::fold($xs, $s);
			return call_user_func_array($tmp1, array($x, $tmp2));
		}break;
		}
	}
	static function append($this1, $nel) {
		$tmp = $this1->index;
		switch($tmp) {
		case 0:{
			return thx_NonEmptyList::ConsNel(_hx_deref($this1)->params[0], $nel);
		}break;
		case 1:{
			$xs = _hx_deref($this1)->params[1];
			$x = _hx_deref($this1)->params[0];
			$tmp1 = thx__Nel_Nel_Impl_::append($xs, $nel);
			return thx_NonEmptyList::ConsNel($x, $tmp1);
		}break;
		}
	}
	static function toArray($this1) {
		$go = null;
		$go = array(new _hx_lambda(array(&$go), "thx__Nel_Nel_Impl__1"), 'execute');
		$array = call_user_func_array($go, array((new _hx_array(array())), $this1));
		$result = $array->copy();
		$result->reverse();
		return $result;
	}
	static function semigroup() {
		return array(new _hx_lambda(array(), "thx__Nel_Nel_Impl__2"), 'execute');
	}
	function __toString() { return 'thx._Nel.Nel_Impl_'; }
}
function thx__Nel_Nel_Impl__0(&$fb, $v) {
	{
		$tmp1 = call_user_func_array($fb, array($v));
		return thx__Nel_Nel_Impl_::pure($tmp1);
	}
}
function thx__Nel_Nel_Impl__1(&$go, $acc, $xs) {
	{
		$tmp = $xs->index;
		switch($tmp) {
		case 0:{
			return thx_Arrays::append($acc, _hx_deref($xs)->params[0]);
		}break;
		case 1:{
			$xs1 = _hx_deref($xs)->params[1];
			$tmp1 = thx_Arrays::append($acc, _hx_deref($xs)->params[0]);
			return call_user_func_array($go, array($tmp1, $xs1));
		}break;
		}
	}
}
function thx__Nel_Nel_Impl__2($nl, $nr) {
	{
		return thx__Nel_Nel_Impl_::append($nl, $nr);
	}
}
