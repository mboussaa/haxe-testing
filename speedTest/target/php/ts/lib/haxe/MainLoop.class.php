<?php

// Generated by Haxe 3.3.0
class haxe_MainLoop {
	public function __construct(){}
	static $pending = null;
	static function sortEvents() {
		$list = haxe_MainLoop::$pending;
		if($list === null) {
			return;
		}
		$insize = 1;
		$nmerges = null;
		$psize = 0;
		$qsize = 0;
		$p = null;
		$q = null;
		$e = null;
		$tail = null;
		while(true) {
			$p = $list;
			$list = null;
			$tail = null;
			$nmerges = 0;
			while($p !== null) {
				++$nmerges;
				$q = $p;
				$psize = 0;
				{
					$_g1 = 0;
					$_g = $insize;
					while($_g1 < $_g) {
						++$_g1;
						++$psize;
						$q = $q->next;
						if($q === null) {
							break;
						}
					}
					unset($_g1,$_g);
				}
				$qsize = $insize;
				while(true) {
					$tmp = null;
					if($psize <= 0) {
						if($qsize > 0) {
							$tmp = $q !== null;
						} else {
							$tmp = false;
						}
					} else {
						$tmp = true;
					}
					if(!$tmp) {
						break;
					}
					$tmp1 = $psize === 0;
					if($tmp1) {
						$e = $q;
						$q = $q->next;
						--$qsize;
					} else {
						$tmp2 = null;
						$tmp3 = null;
						if($qsize !== 0) {
							$tmp3 = $q === null;
						} else {
							$tmp3 = true;
						}
						if(!$tmp3) {
							if($p->priority <= $q->priority) {
								if($p->priority === $q->priority) {
									$tmp2 = $p->nextRun <= $q->nextRun;
								} else {
									$tmp2 = false;
								}
							} else {
								$tmp2 = true;
							}
						} else {
							$tmp2 = true;
						}
						if($tmp2) {
							$e = $p;
							$p = $p->next;
							--$psize;
						} else {
							$e = $q;
							$q = $q->next;
							--$qsize;
						}
						unset($tmp3,$tmp2);
					}
					if($tail !== null) {
						$tail->next = $e;
					} else {
						$list = $e;
					}
					$e->prev = $tail;
					$tail = $e;
					unset($tmp1,$tmp);
				}
				$p = $q;
			}
			$tail->next = null;
			if($nmerges <= 1) {
				break;
			}
			$insize *= 2;
		}
		$list->prev = null;
		haxe_MainLoop::$pending = $list;
	}
	static function tick() {
		haxe_MainLoop::sortEvents();
		$e = haxe_MainLoop::$pending;
		$now = haxe_Timer::stamp();
		$wait = 1e9;
		while($e !== null) {
			$next = $e->next;
			$wt = $e->nextRun - $now;
			$tmp = null;
			if(!($e->nextRun < 0)) {
				$tmp = $wt <= 0;
			} else {
				$tmp = true;
			}
			if($tmp) {
				$wait = 0;
				if($e->f !== null) {
					$e->f();
				}
			} else {
				$tmp1 = $wait > $wt;
				if($tmp1) {
					$wait = $wt;
				}
				unset($tmp1);
			}
			$e = $next;
			unset($wt,$tmp,$next);
		}
		return $wait;
	}
	function __toString() { return 'haxe.MainLoop'; }
}
