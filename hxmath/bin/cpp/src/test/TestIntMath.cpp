// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_hxmath_math_IntVector2Default
#include <hxmath/math/IntVector2Default.h>
#endif
#ifndef INCLUDED_hxmath_math_Vector2Default
#include <hxmath/math/Vector2Default.h>
#endif
#ifndef INCLUDED_hxmath_math__IntVector2_IntVector2_Impl_
#include <hxmath/math/_IntVector2/IntVector2_Impl_.h>
#endif
#ifndef INCLUDED_hxmath_math__ShortVector2_ShortVector2_Impl_
#include <hxmath/math/_ShortVector2/ShortVector2_Impl_.h>
#endif
#ifndef INCLUDED_nanotest_NanoTestCase
#include <nanotest/NanoTestCase.h>
#endif
#ifndef INCLUDED_test_MathTestCase
#include <test/MathTestCase.h>
#endif
#ifndef INCLUDED_test_TestIntMath
#include <test/TestIntMath.h>
#endif

namespace test{

void TestIntMath_obj::__construct( ::Dynamic posInfos){
            	HX_STACK_FRAME("test.TestIntMath","new",0xe55e9b5b,"test.TestIntMath.new","test/TestIntMath.hx",10,0x0c40e836)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(posInfos,"posInfos")
HXLINE(  10)		super::__construct(posInfos);
            	}

Dynamic TestIntMath_obj::__CreateEmpty() { return new TestIntMath_obj; }

hx::ObjectPtr< TestIntMath_obj > TestIntMath_obj::__new( ::Dynamic posInfos)
{
	hx::ObjectPtr< TestIntMath_obj > _hx_result = new TestIntMath_obj();
	_hx_result->__construct(posInfos);
	return _hx_result;
}

Dynamic TestIntMath_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< TestIntMath_obj > _hx_result = new TestIntMath_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

void TestIntMath_obj::testIntVector2Conversion(){
            	HX_STACK_FRAME("test.TestIntMath","testIntVector2Conversion",0x19e6baad,"test.TestIntMath.testIntVector2Conversion","test/TestIntMath.hx",13,0x0c40e836)
            	HX_STACK_THIS(this)
HXLINE(  15)		HX_VARI(  ::hxmath::math::IntVector2Default,v) = ::hxmath::math::_IntVector2::IntVector2_Impl__obj::_new((int)1,(int)2);
HXLINE(  16)		HX_VARI(  ::hxmath::math::Vector2Default,u) =  ::hxmath::math::Vector2Default_obj::__new(v->x,v->y);
HXLINE(  17)		HX_VARI(  ::hxmath::math::Vector2Default,expectedU) =  ::hxmath::math::Vector2Default_obj::__new(((Float)1.0),((Float)2.0));
HXLINE(  18)		HX_VARI(  ::hxmath::math::Vector2Default,self) =  ::hxmath::math::Vector2Default_obj::__new(u->x,u->y);
HXDLIN(  18)		hx::SubEq(self->x,expectedU->x);
HXDLIN(  18)		hx::SubEq(self->y,expectedU->y);
HXDLIN(  18)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self1,"self") = self;
HXDLIN(  18)		Float _hx_tmp = ((self1->x * self1->x) + (self1->y * self1->y));
HXDLIN(  18)		Float _hx_tmp1 = ::Math_obj::sqrt(_hx_tmp);
HXDLIN(  18)		this->assertApproxEquals(((Float)0.0),_hx_tmp1,null(),hx::SourceInfo(HX_("TestIntMath.hx",d9,2f,5a,11),18,HX_("test.TestIntMath",e9,51,c9,90),HX_("testIntVector2Conversion",88,d9,be,77)));
HXLINE(  21)		HX_VARI(  ::hxmath::math::Vector2Default,eps) =  ::hxmath::math::Vector2Default_obj::__new(((Float)0.1),((Float)0.1));
HXLINE(  22)		HX_VARI(  ::hxmath::math::Vector2Default,one) =  ::hxmath::math::Vector2Default_obj::__new(((Float)1.0),((Float)1.0));
HXLINE(  23)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self2,"self") =  ::hxmath::math::Vector2Default_obj::__new(u->x,u->y);
HXDLIN(  23)		hx::AddEq(self2->x,eps->x);
HXDLIN(  23)		hx::AddEq(self2->y,eps->y);
HXDLIN(  23)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,this1,"this") = self2;
HXDLIN(  23)		HX_VARI(  ::Dynamic,func) = null();
HXDLIN(  23)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self3,"self") = this1;
HXDLIN(  23)		Bool _hx_tmp2 = hx::IsNull( func );
HXDLIN(  23)		if (_hx_tmp2) {
HXLINE(  23)			func = ::Std_obj::_hx_int_dyn();
            		}
HXDLIN(  23)		Int _hx_tmp3 = ( (Int)(func(self3->x)) );
HXDLIN(  23)		Int _hx_tmp4 = ( (Int)(func(self3->y)) );
HXDLIN(  23)		HX_VARI(  ::hxmath::math::IntVector2Default,flooredVec) = ::hxmath::math::_IntVector2::IntVector2_Impl__obj::_new(_hx_tmp3,_hx_tmp4);
HXLINE(  24)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self4,"self") =  ::hxmath::math::Vector2Default_obj::__new(u->x,u->y);
HXDLIN(  24)		hx::AddEq(self4->x,eps->x);
HXDLIN(  24)		hx::AddEq(self4->y,eps->y);
HXDLIN(  24)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,this2,"this") = self4;
HXDLIN(  24)		HX_VARI_NAME(  ::Dynamic,func1,"func") = ::Math_obj::ceil_dyn();
HXDLIN(  24)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self5,"self") = this2;
HXDLIN(  24)		Bool _hx_tmp5 = hx::IsNull( func1 );
HXDLIN(  24)		if (_hx_tmp5) {
HXLINE(  24)			func1 = ::Std_obj::_hx_int_dyn();
            		}
HXDLIN(  24)		Int _hx_tmp6 = ( (Int)(func1(self5->x)) );
HXDLIN(  24)		Int _hx_tmp7 = ( (Int)(func1(self5->y)) );
HXDLIN(  24)		HX_VARI(  ::hxmath::math::IntVector2Default,cieldVec) = ::hxmath::math::_IntVector2::IntVector2_Impl__obj::_new(_hx_tmp6,_hx_tmp7);
HXLINE(  25)		HX_VARI(  ::hxmath::math::Vector2Default,a) =  ::hxmath::math::Vector2Default_obj::__new(flooredVec->x,flooredVec->y);
HXDLIN(  25)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self6,"self") =  ::hxmath::math::Vector2Default_obj::__new(a->x,a->y);
HXDLIN(  25)		hx::SubEq(self6->x,u->x);
HXDLIN(  25)		hx::SubEq(self6->y,u->y);
HXDLIN(  25)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self7,"self") = self6;
HXDLIN(  25)		Float _hx_tmp8 = ((self7->x * self7->x) + (self7->y * self7->y));
HXDLIN(  25)		Float _hx_tmp9 = ::Math_obj::sqrt(_hx_tmp8);
HXDLIN(  25)		this->assertApproxEquals(_hx_tmp9,((Float)0.0),null(),hx::SourceInfo(HX_("TestIntMath.hx",d9,2f,5a,11),25,HX_("test.TestIntMath",e9,51,c9,90),HX_("testIntVector2Conversion",88,d9,be,77)));
HXLINE(  26)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,a1,"a") =  ::hxmath::math::Vector2Default_obj::__new(cieldVec->x,cieldVec->y);
HXDLIN(  26)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self8,"self") =  ::hxmath::math::Vector2Default_obj::__new(u->x,u->y);
HXDLIN(  26)		hx::AddEq(self8->x,one->x);
HXDLIN(  26)		hx::AddEq(self8->y,one->y);
HXDLIN(  26)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self9,"self") =  ::hxmath::math::Vector2Default_obj::__new(a1->x,a1->y);
HXDLIN(  26)		hx::SubEq(self9->x,self8->x);
HXDLIN(  26)		hx::SubEq(self9->y,self8->y);
HXDLIN(  26)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self10,"self") = self9;
HXDLIN(  26)		Float _hx_tmp10 = ((self10->x * self10->x) + (self10->y * self10->y));
HXDLIN(  26)		Float _hx_tmp11 = ::Math_obj::sqrt(_hx_tmp10);
HXDLIN(  26)		this->assertApproxEquals(_hx_tmp11,((Float)0.0),null(),hx::SourceInfo(HX_("TestIntMath.hx",d9,2f,5a,11),26,HX_("test.TestIntMath",e9,51,c9,90),HX_("testIntVector2Conversion",88,d9,be,77)));
HXLINE(  29)		HX_VARI( Int,vi) = ::hxmath::math::_ShortVector2::ShortVector2_Impl__obj::_new((int)1,(int)2);
HXLINE(  30)		HX_VARI(  ::hxmath::math::Vector2Default,ui) =  ::hxmath::math::Vector2Default_obj::__new(((int)vi & (int)(int)65535),((int)((int)vi >> (int)(int)16) & (int)(int)65535));
HXLINE(  31)		HX_VARI(  ::hxmath::math::Vector2Default,expectedUi) =  ::hxmath::math::Vector2Default_obj::__new(((Float)1.0),((Float)2.0));
HXLINE(  32)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self11,"self") =  ::hxmath::math::Vector2Default_obj::__new(ui->x,ui->y);
HXDLIN(  32)		hx::SubEq(self11->x,expectedUi->x);
HXDLIN(  32)		hx::SubEq(self11->y,expectedUi->y);
HXDLIN(  32)		HX_VARI_NAME(  ::hxmath::math::Vector2Default,self12,"self") = self11;
HXDLIN(  32)		Float _hx_tmp12 = ((self12->x * self12->x) + (self12->y * self12->y));
HXDLIN(  32)		Float _hx_tmp13 = ::Math_obj::sqrt(_hx_tmp12);
HXDLIN(  32)		this->assertApproxEquals(((Float)0.0),_hx_tmp13,null(),hx::SourceInfo(HX_("TestIntMath.hx",d9,2f,5a,11),32,HX_("test.TestIntMath",e9,51,c9,90),HX_("testIntVector2Conversion",88,d9,be,77)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(TestIntMath_obj,testIntVector2Conversion,(void))


TestIntMath_obj::TestIntMath_obj()
{
}

hx::Val TestIntMath_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 24:
		if (HX_FIELD_EQ(inName,"testIntVector2Conversion") ) { return hx::Val( testIntVector2Conversion_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *TestIntMath_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *TestIntMath_obj_sStaticStorageInfo = 0;
#endif

static ::String TestIntMath_obj_sMemberFields[] = {
	HX_HCSTRING("testIntVector2Conversion","\x88","\xd9","\xbe","\x77"),
	::String(null()) };

static void TestIntMath_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(TestIntMath_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void TestIntMath_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(TestIntMath_obj::__mClass,"__mClass");
};

#endif

hx::Class TestIntMath_obj::__mClass;

void TestIntMath_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("test.TestIntMath","\xe9","\x51","\xc9","\x90");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = TestIntMath_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(TestIntMath_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< TestIntMath_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = TestIntMath_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = TestIntMath_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = TestIntMath_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace test
