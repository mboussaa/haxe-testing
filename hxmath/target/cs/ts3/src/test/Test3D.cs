// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace test {
	public class Test3D : global::test.MathTestCase {
		
		public Test3D(global::haxe.lang.EmptyObject empty) : base(((global::haxe.lang.EmptyObject) (global::haxe.lang.EmptyObject.EMPTY) )) {
		}
		
		
		public Test3D(object posInfos) : base(((global::haxe.lang.EmptyObject) (global::haxe.lang.EmptyObject.EMPTY) )) {
			global::test.Test3D.__hx_ctor_test_Test3D(this, posInfos);
		}
		
		
		public static void __hx_ctor_test_Test3D(global::test.Test3D __temp_me56, object posInfos) {
			global::test.MathTestCase.__hx_ctor_test_MathTestCase(__temp_me56, posInfos);
		}
		
		
		public static new object __hx_createEmpty() {
			return new global::test.Test3D(((global::haxe.lang.EmptyObject) (global::haxe.lang.EmptyObject.EMPTY) ));
		}
		
		
		public static new object __hx_create(global::Array arr) {
			return new global::test.Test3D(((object) (arr[0]) ));
		}
		
		
		public virtual void testMatrixMult() {
			unchecked {
				int _g = 0;
				while (( _g < 10 )) {
					 ++ _g;
					global::hxmath.math.Matrix3x3Default a = this.randomMatrix3x3(default(global::haxe.lang.Null<double>));
					global::hxmath.math.Matrix3x3Default a1 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0)) );
					global::hxmath.math.Matrix3x3Default a2 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(( ( ( a1.m00 * a.m00 ) + ( a1.m10 * a.m01 ) ) + ( a1.m20 * a.m02 ) ), ( ( ( a1.m00 * a.m10 ) + ( a1.m10 * a.m11 ) ) + ( a1.m20 * a.m12 ) ), ( ( ( a1.m00 * a.m20 ) + ( a1.m10 * a.m21 ) ) + ( a1.m20 * a.m22 ) ), ( ( ( a1.m01 * a.m00 ) + ( a1.m11 * a.m01 ) ) + ( a1.m21 * a.m02 ) ), ( ( ( a1.m01 * a.m10 ) + ( a1.m11 * a.m11 ) ) + ( a1.m21 * a.m12 ) ), ( ( ( a1.m01 * a.m20 ) + ( a1.m11 * a.m21 ) ) + ( a1.m21 * a.m22 ) ), ( ( ( a1.m02 * a.m00 ) + ( a1.m12 * a.m01 ) ) + ( a1.m22 * a.m02 ) ), ( ( ( a1.m02 * a.m10 ) + ( a1.m12 * a.m11 ) ) + ( a1.m22 * a.m12 ) ), ( ( ( a1.m02 * a.m20 ) + ( a1.m12 * a.m21 ) ) + ( a1.m22 * a.m22 ) ))) );
					this.assertTrue(( ( ( a2 == null ) && ( a == null ) ) || ( ( ( ( ( ( ( ( ( ( ( a2 != null ) && ( a != null ) ) && ( a2.m00 == a.m00 ) ) && ( a2.m10 == a.m10 ) ) && ( a2.m20 == a.m20 ) ) && ( a2.m01 == a.m01 ) ) && ( a2.m11 == a.m11 ) ) && ( a2.m21 == a.m21 ) ) && ( a2.m02 == a.m02 ) ) && ( a2.m12 == a.m12 ) ) && ( a2.m22 == a.m22 ) ) ), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testMatrixMult", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (18) )}));
				}
				
			}
		}
		
		
		public virtual void testAddSub() {
			unchecked {
				{
					int _g = 0;
					while (( _g < 10 )) {
						 ++ _g;
						global::hxmath.math.Matrix3x3Default a = this.randomMatrix3x3(default(global::haxe.lang.Null<double>));
						global::hxmath.math.Matrix3x3Default b = this.randomMatrix3x3(default(global::haxe.lang.Null<double>));
						global::hxmath.math.Matrix3x3Default c = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(a.m00, a.m10, a.m20, a.m01, a.m11, a.m21, a.m02, a.m12, a.m22)) );
						c.m00 += b.m00;
						c.m10 += b.m10;
						c.m20 += b.m20;
						c.m01 += b.m01;
						c.m11 += b.m11;
						c.m21 += b.m21;
						c.m02 += b.m02;
						c.m12 += b.m12;
						c.m22 += b.m22;
						global::hxmath.math.Matrix3x3Default self = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(a.m00, a.m10, a.m20, a.m01, a.m11, a.m21, a.m02, a.m12, a.m22)) );
						self.m00 += b.m00;
						self.m10 += b.m10;
						self.m20 += b.m20;
						self.m01 += b.m01;
						self.m11 += b.m11;
						self.m21 += b.m21;
						self.m02 += b.m02;
						self.m12 += b.m12;
						self.m22 += b.m22;
						this.assertTrue(( ( ( c == null ) && ( self == null ) ) || ( ( ( ( ( ( ( ( ( ( ( c != null ) && ( self != null ) ) && ( c.m00 == self.m00 ) ) && ( c.m10 == self.m10 ) ) && ( c.m20 == self.m20 ) ) && ( c.m01 == self.m01 ) ) && ( c.m11 == self.m11 ) ) && ( c.m21 == self.m21 ) ) && ( c.m02 == self.m02 ) ) && ( c.m12 == self.m12 ) ) && ( c.m22 == self.m22 ) ) ), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAddSub", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (29) )}));
					}
					
				}
				
				{
					int _g1 = 0;
					while (( _g1 < 10 )) {
						 ++ _g1;
						global::hxmath.math.Matrix3x3Default a1 = this.randomMatrix3x3(default(global::haxe.lang.Null<double>));
						global::hxmath.math.Matrix3x3Default b1 = this.randomMatrix3x3(default(global::haxe.lang.Null<double>));
						global::hxmath.math.Matrix3x3Default c1 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(a1.m00, a1.m10, a1.m20, a1.m01, a1.m11, a1.m21, a1.m02, a1.m12, a1.m22)) );
						c1.m00 -= b1.m00;
						c1.m10 -= b1.m10;
						c1.m20 -= b1.m20;
						c1.m01 -= b1.m01;
						c1.m11 -= b1.m11;
						c1.m21 -= b1.m21;
						c1.m02 -= b1.m02;
						c1.m12 -= b1.m12;
						c1.m22 -= b1.m22;
						global::hxmath.math.Matrix3x3Default self1 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(a1.m00, a1.m10, a1.m20, a1.m01, a1.m11, a1.m21, a1.m02, a1.m12, a1.m22)) );
						self1.m00 -= b1.m00;
						self1.m10 -= b1.m10;
						self1.m20 -= b1.m20;
						self1.m01 -= b1.m01;
						self1.m11 -= b1.m11;
						self1.m21 -= b1.m21;
						self1.m02 -= b1.m02;
						self1.m12 -= b1.m12;
						self1.m22 -= b1.m22;
						this.assertTrue(( ( ( c1 == null ) && ( self1 == null ) ) || ( ( ( ( ( ( ( ( ( ( ( c1 != null ) && ( self1 != null ) ) && ( c1.m00 == self1.m00 ) ) && ( c1.m10 == self1.m10 ) ) && ( c1.m20 == self1.m20 ) ) && ( c1.m01 == self1.m01 ) ) && ( c1.m11 == self1.m11 ) ) && ( c1.m21 == self1.m21 ) ) && ( c1.m02 == self1.m02 ) ) && ( c1.m12 == self1.m12 ) ) && ( c1.m22 == self1.m22 ) ) ), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAddSub", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (37) )}));
					}
					
				}
				
			}
		}
		
		
		public virtual void testCrossProductPrecedence() {
			unchecked {
				global::hxmath.math.Vector3Default a = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(1.0, 0.0, 0.0)) );
				global::hxmath.math.Vector3Default a1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 1.0, 0.0)) );
				global::hxmath.math.Vector3Default b = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				global::hxmath.math.Vector3Default self = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(a1.x, a1.y, a1.z)) );
				double newX = ( ( self.y * b.z ) - ( self.z * b.y ) );
				double newY = ( ( self.z * b.x ) - ( self.x * b.z ) );
				double newZ = ( ( self.x * b.y ) - ( self.y * b.x ) );
				self.x = newX;
				self.y = newY;
				self.z = newZ;
				global::hxmath.math.Vector3Default self1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(a.x, a.y, a.z)) );
				self1.x += self.x;
				self1.y += self.y;
				self1.z += self.z;
				global::hxmath.math.Vector3Default _g1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(1.0, 0.0, 0.0)) );
				global::hxmath.math.Vector3Default self2 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(_g1.x, _g1.y, _g1.z)) );
				self2.x *= 2.0;
				self2.y *= 2.0;
				self2.z *= 2.0;
				this.assertTrue(( ( ( self1 == null ) && ( self2 == null ) ) || ( ( ( ( ( self1 != null ) && ( self2 != null ) ) && ( self1.x == self2.x ) ) && ( self1.y == self2.y ) ) && ( self1.z == self2.z ) ) ), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testCrossProductPrecedence", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (43) )}));
			}
		}
		
		
		public virtual void testAxialRotation() {
			unchecked {
				double angleRadians = ( ( global::Math.PI / 180 ) * 90.0 );
				double s = global::System.Math.Sin(((double) (angleRadians) ));
				double c = global::System.Math.Cos(((double) (angleRadians) ));
				global::hxmath.math.Matrix3x3Default a = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(((double) (1) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), c,  - (s) , ((double) (0) ), s, c)) );
				global::hxmath.math.Vector3Default v = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 1.0, 0.0)) );
				global::hxmath.math.Vector3Default a1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(( ( ( a.m00 * v.x ) + ( a.m10 * v.y ) ) + ( a.m20 * v.z ) ), ( ( ( a.m01 * v.x ) + ( a.m11 * v.y ) ) + ( a.m21 * v.z ) ), ( ( ( a.m02 * v.x ) + ( a.m12 * v.y ) ) + ( a.m22 * v.z ) ))) );
				global::hxmath.math.Vector3Default b = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				global::hxmath.math.Vector3Default self = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(a1.x, a1.y, a1.z)) );
				self.x -= b.x;
				self.y -= b.y;
				self.z -= b.z;
				global::hxmath.math.Vector3Default self1 = ((global::hxmath.math.Vector3Default) (self) );
				this.assertApproxEquals(global::System.Math.Sqrt(((double) (( ( ( self1.x * self1.x ) + ( self1.y * self1.y ) ) + ( self1.z * self1.z ) )) )), 0.0, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAxialRotation", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (53) )}));
				double angleRadians1 = ( ( global::Math.PI / 180 ) * 90.0 );
				double s1 = global::System.Math.Sin(((double) (angleRadians1) ));
				double c1 = global::System.Math.Cos(((double) (angleRadians1) ));
				global::hxmath.math.Matrix3x3Default a2 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(((double) (1) ), ((double) (0) ), ((double) (0) ), ((double) (0) ), c1,  - (s1) , ((double) (0) ), s1, c1)) );
				global::hxmath.math.Vector3Default v1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				global::hxmath.math.Vector3Default a3 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(( ( ( a2.m00 * v1.x ) + ( a2.m10 * v1.y ) ) + ( a2.m20 * v1.z ) ), ( ( ( a2.m01 * v1.x ) + ( a2.m11 * v1.y ) ) + ( a2.m21 * v1.z ) ), ( ( ( a2.m02 * v1.x ) + ( a2.m12 * v1.y ) ) + ( a2.m22 * v1.z ) ))) );
				global::hxmath.math.Vector3Default b1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 1.0, 0.0)) );
				global::hxmath.math.Vector3Default self2 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(a3.x, a3.y, a3.z)) );
				self2.x += b1.x;
				self2.y += b1.y;
				self2.z += b1.z;
				global::hxmath.math.Vector3Default self3 = ((global::hxmath.math.Vector3Default) (self2) );
				this.assertApproxEquals(global::System.Math.Sqrt(((double) (( ( ( self3.x * self3.x ) + ( self3.y * self3.y ) ) + ( self3.z * self3.z ) )) )), 0.0, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAxialRotation", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (54) )}));
				double angleRadians2 = ( ( global::Math.PI / 180 ) * 90.0 );
				double s2 = global::System.Math.Sin(((double) (angleRadians2) ));
				double c2 = global::System.Math.Cos(((double) (angleRadians2) ));
				global::hxmath.math.Matrix3x3Default a4 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(c2, ((double) (0) ), s2, ((double) (0) ), ((double) (1) ), ((double) (0) ),  - (s2) , ((double) (0) ), c2)) );
				global::hxmath.math.Vector3Default v2 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				global::hxmath.math.Vector3Default a5 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(( ( ( a4.m00 * v2.x ) + ( a4.m10 * v2.y ) ) + ( a4.m20 * v2.z ) ), ( ( ( a4.m01 * v2.x ) + ( a4.m11 * v2.y ) ) + ( a4.m21 * v2.z ) ), ( ( ( a4.m02 * v2.x ) + ( a4.m12 * v2.y ) ) + ( a4.m22 * v2.z ) ))) );
				global::hxmath.math.Vector3Default b2 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(1.0, 0.0, 0.0)) );
				global::hxmath.math.Vector3Default self4 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(a5.x, a5.y, a5.z)) );
				self4.x -= b2.x;
				self4.y -= b2.y;
				self4.z -= b2.z;
				global::hxmath.math.Vector3Default self5 = ((global::hxmath.math.Vector3Default) (self4) );
				this.assertApproxEquals(global::System.Math.Sqrt(((double) (( ( ( self5.x * self5.x ) + ( self5.y * self5.y ) ) + ( self5.z * self5.z ) )) )), 0.0, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAxialRotation", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (59) )}));
				double angleRadians3 = ( ( global::Math.PI / 180 ) * 90.0 );
				double s3 = global::System.Math.Sin(((double) (angleRadians3) ));
				double c3 = global::System.Math.Cos(((double) (angleRadians3) ));
				global::hxmath.math.Matrix3x3Default a6 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(c3, ((double) (0) ), s3, ((double) (0) ), ((double) (1) ), ((double) (0) ),  - (s3) , ((double) (0) ), c3)) );
				global::hxmath.math.Vector3Default v3 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(1.0, 0.0, 0.0)) );
				global::hxmath.math.Vector3Default a7 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(( ( ( a6.m00 * v3.x ) + ( a6.m10 * v3.y ) ) + ( a6.m20 * v3.z ) ), ( ( ( a6.m01 * v3.x ) + ( a6.m11 * v3.y ) ) + ( a6.m21 * v3.z ) ), ( ( ( a6.m02 * v3.x ) + ( a6.m12 * v3.y ) ) + ( a6.m22 * v3.z ) ))) );
				global::hxmath.math.Vector3Default b3 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				global::hxmath.math.Vector3Default self6 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(a7.x, a7.y, a7.z)) );
				self6.x += b3.x;
				self6.y += b3.y;
				self6.z += b3.z;
				global::hxmath.math.Vector3Default self7 = ((global::hxmath.math.Vector3Default) (self6) );
				this.assertApproxEquals(global::System.Math.Sqrt(((double) (( ( ( self7.x * self7.x ) + ( self7.y * self7.y ) ) + ( self7.z * self7.z ) )) )), 0.0, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAxialRotation", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (60) )}));
				double angleRadians4 = ( ( global::Math.PI / 180 ) * 90.0 );
				double s4 = global::System.Math.Sin(((double) (angleRadians4) ));
				double c4 = global::System.Math.Cos(((double) (angleRadians4) ));
				global::hxmath.math.Matrix3x3Default a8 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(c4,  - (s4) , ((double) (0) ), s4, c4, ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (1) ))) );
				global::hxmath.math.Vector3Default v4 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(1.0, 0.0, 0.0)) );
				global::hxmath.math.Vector3Default a9 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(( ( ( a8.m00 * v4.x ) + ( a8.m10 * v4.y ) ) + ( a8.m20 * v4.z ) ), ( ( ( a8.m01 * v4.x ) + ( a8.m11 * v4.y ) ) + ( a8.m21 * v4.z ) ), ( ( ( a8.m02 * v4.x ) + ( a8.m12 * v4.y ) ) + ( a8.m22 * v4.z ) ))) );
				global::hxmath.math.Vector3Default b4 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 1.0, 0.0)) );
				global::hxmath.math.Vector3Default self8 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(a9.x, a9.y, a9.z)) );
				self8.x -= b4.x;
				self8.y -= b4.y;
				self8.z -= b4.z;
				global::hxmath.math.Vector3Default self9 = ((global::hxmath.math.Vector3Default) (self8) );
				this.assertApproxEquals(global::System.Math.Sqrt(((double) (( ( ( self9.x * self9.x ) + ( self9.y * self9.y ) ) + ( self9.z * self9.z ) )) )), 0.0, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAxialRotation", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (65) )}));
				double angleRadians5 = ( ( global::Math.PI / 180 ) * 90.0 );
				double s5 = global::System.Math.Sin(((double) (angleRadians5) ));
				double c5 = global::System.Math.Cos(((double) (angleRadians5) ));
				global::hxmath.math.Matrix3x3Default a10 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(c5,  - (s5) , ((double) (0) ), s5, c5, ((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (1) ))) );
				global::hxmath.math.Vector3Default v5 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 1.0, 0.0)) );
				global::hxmath.math.Vector3Default a11 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(( ( ( a10.m00 * v5.x ) + ( a10.m10 * v5.y ) ) + ( a10.m20 * v5.z ) ), ( ( ( a10.m01 * v5.x ) + ( a10.m11 * v5.y ) ) + ( a10.m21 * v5.z ) ), ( ( ( a10.m02 * v5.x ) + ( a10.m12 * v5.y ) ) + ( a10.m22 * v5.z ) ))) );
				global::hxmath.math.Vector3Default b5 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(1.0, 0.0, 0.0)) );
				global::hxmath.math.Vector3Default self10 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(a11.x, a11.y, a11.z)) );
				self10.x += b5.x;
				self10.y += b5.y;
				self10.z += b5.z;
				global::hxmath.math.Vector3Default self11 = ((global::hxmath.math.Vector3Default) (self10) );
				this.assertApproxEquals(global::System.Math.Sqrt(((double) (( ( ( self11.x * self11.x ) + ( self11.y * self11.y ) ) + ( self11.z * self11.z ) )) )), 0.0, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAxialRotation", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (66) )}));
			}
		}
		
		
		public virtual void testQuaternionToMatrix() {
			unchecked {
				global::haxe.lang.Function createMatrixPair = ( (( global::test.Test3D_testQuaternionToMatrix_71__Fun.__hx_current != null )) ? (global::test.Test3D_testQuaternionToMatrix_71__Fun.__hx_current) : (global::test.Test3D_testQuaternionToMatrix_71__Fun.__hx_current = ((global::test.Test3D_testQuaternionToMatrix_71__Fun) (new global::test.Test3D_testQuaternionToMatrix_71__Fun()) )) );
				{
					int _g = 0;
					while (( _g < 3 )) {
						int axis2 = _g++;
						double unitAngle1 = 0.0;
						{
							int _g1 = 0;
							while (( _g1 < 10 )) {
								 ++ _g1;
								unitAngle1 += 0.01;
								double totalLength = 0.0;
								{
									int _g2 = 0;
									while (( _g2 < 3 )) {
										int c = _g2++;
										object pair = ((object) (createMatrixPair.__hx_invoke2_o(unitAngle1, global::haxe.lang.Runtime.undefined, ((double) (axis2) ), global::haxe.lang.Runtime.undefined)) );
										global::hxmath.math.Matrix3x3Default self = ((global::hxmath.math.Matrix3x3Default) (global::haxe.lang.Runtime.getField(pair, "n", 110, true)) );
										object tmp = null;
										switch (c) {
											case 0:
											{
												tmp = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(self.m00, self.m01, self.m02)) );
												break;
											}
											
											
											case 1:
											{
												tmp = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(self.m10, self.m11, self.m12)) );
												break;
											}
											
											
											case 2:
											{
												tmp = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(self.m20, self.m21, self.m22)) );
												break;
											}
											
											
											default:
											{
												throw global::haxe.lang.HaxeException.wrap("Invalid column");
											}
											
										}
										
										global::hxmath.math.Vector3Default a = ((global::hxmath.math.Vector3Default) (tmp) );
										global::hxmath.math.Matrix3x3Default self1 = ((global::hxmath.math.Matrix3x3Default) (global::haxe.lang.Runtime.getField(pair, "m", 109, true)) );
										object tmp1 = null;
										switch (c) {
											case 0:
											{
												tmp1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(self1.m00, self1.m01, self1.m02)) );
												break;
											}
											
											
											case 1:
											{
												tmp1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(self1.m10, self1.m11, self1.m12)) );
												break;
											}
											
											
											case 2:
											{
												tmp1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(self1.m20, self1.m21, self1.m22)) );
												break;
											}
											
											
											default:
											{
												throw global::haxe.lang.HaxeException.wrap("Invalid column");
											}
											
										}
										
										global::hxmath.math.Vector3Default b = ((global::hxmath.math.Vector3Default) (tmp1) );
										global::hxmath.math.Vector3Default self2 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(a.x, a.y, a.z)) );
										self2.x -= b.x;
										self2.y -= b.y;
										self2.z -= b.z;
										global::hxmath.math.Vector3Default self3 = ((global::hxmath.math.Vector3Default) (self2) );
										totalLength += global::System.Math.Sqrt(((double) (( ( ( self3.x * self3.x ) + ( self3.y * self3.y ) ) + ( self3.z * self3.z ) )) ));
									}
									
								}
								
								this.assertApproxEquals(totalLength, 0.0, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testQuaternionToMatrix", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (98) )}));
							}
							
						}
						
					}
					
				}
				
			}
		}
		
		
		public virtual void testMatrixFrameInverse() {
			unchecked {
				int _g = 0;
				while (( _g < 10 )) {
					 ++ _g;
					global::hxmath.frames.IFrame3 frame = this.randomFrame3(default(global::haxe.lang.Null<double>));
					global::hxmath.math.QuaternionDefault self = ((global::hxmath.math.QuaternionDefault) (frame.get_orientation()) );
					global::hxmath.math.QuaternionDefault self1 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(self.s, self.x, self.y, self.z)) );
					self1.x =  - (self1.x) ;
					self1.y =  - (self1.y) ;
					self1.z =  - (self1.z) ;
					global::hxmath.math.QuaternionDefault self2 = ((global::hxmath.math.QuaternionDefault) (self1) );
					double length = global::System.Math.Sqrt(((double) (( ( ( ( self2.s * self2.s ) + ( self2.x * self2.x ) ) + ( self2.y * self2.y ) ) + ( self2.z * self2.z ) )) ));
					if (( length > 0.0 )) {
						double k = ( 1.0 / length );
						{
							self2.s *= k;
							self2.x *= k;
							self2.y *= k;
							self2.z *= k;
						}
						
					}
					
					global::hxmath.math.Vector3Default u = frame.get_offset();
					double a = ( 2.0 * (( ( ( self2.x * u.x ) + ( self2.y * u.y ) ) + ( self2.z * u.z ) )) );
					double b = ( ( ( ( self2.s * self2.s ) - ( self2.x * self2.x ) ) - ( self2.y * self2.y ) ) - ( self2.z * self2.z ) );
					double c = ( 2.0 * self2.s );
					global::hxmath.math.Vector3Default self3 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(( ( ( a * self2.x ) + ( b * u.x ) ) + ( c * (( ( self2.y * u.z ) - ( self2.z * u.y ) )) ) ), ( ( ( a * self2.y ) + ( b * u.y ) ) + ( c * (( ( self2.z * u.x ) - ( self2.x * u.z ) )) ) ), ( ( ( a * self2.z ) + ( b * u.z ) ) + ( c * (( ( self2.x * u.y ) - ( self2.y * u.x ) )) ) ))) );
					self3.x =  - (self3.x) ;
					self3.y =  - (self3.y) ;
					self3.z =  - (self3.z) ;
					global::hxmath.frames.IFrame3 invFrame = global::hxmath.frames._Frame3.Frame3_Impl_._new(self3, self2);
					frame.get_matrix();
					global::hxmath.math.Matrix4x4Default invFrameMatrix = invFrame.get_matrix();
					global::hxmath.math.Matrix4x4Default self4 = ((global::hxmath.math.Matrix4x4Default) (frame.get_matrix()) );
					{
						double temp = self4.m01;
						self4.m01 = self4.m10;
						self4.m10 = temp;
						temp = self4.m02;
						self4.m02 = self4.m20;
						self4.m20 = temp;
						temp = self4.m12;
						self4.m12 = self4.m21;
						self4.m21 = temp;
					}
					
					double tx =  - ((( ( ( self4.m00 * self4.m30 ) + ( self4.m10 * self4.m31 ) ) + ( self4.m20 * self4.m32 ) ))) ;
					double ty =  - ((( ( ( self4.m01 * self4.m30 ) + ( self4.m11 * self4.m31 ) ) + ( self4.m21 * self4.m32 ) ))) ;
					double tz =  - ((( ( ( self4.m02 * self4.m30 ) + ( self4.m12 * self4.m31 ) ) + ( self4.m22 * self4.m32 ) ))) ;
					self4.m30 = tx;
					self4.m31 = ty;
					self4.m32 = tz;
					global::hxmath.math.Vector4Default homogenous0 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(0.0, 0.0, 0.0, 1.0)) );
					global::hxmath.math.Vector4Default homogenousX = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(1.0, 0.0, 0.0, 1.0)) );
					global::hxmath.math.Vector4Default homogenousY = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(0.0, 1.0, 0.0, 1.0)) );
					global::hxmath.math.Vector4Default homogenousZ = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(0.0, 0.0, 1.0, 1.0)) );
					global::hxmath.math.Vector4Default a1 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(( ( ( ( invFrameMatrix.m00 * homogenous0.x ) + ( invFrameMatrix.m10 * homogenous0.y ) ) + ( invFrameMatrix.m20 * homogenous0.z ) ) + ( invFrameMatrix.m30 * homogenous0.w ) ), ( ( ( ( invFrameMatrix.m01 * homogenous0.x ) + ( invFrameMatrix.m11 * homogenous0.y ) ) + ( invFrameMatrix.m21 * homogenous0.z ) ) + ( invFrameMatrix.m31 * homogenous0.w ) ), ( ( ( ( invFrameMatrix.m02 * homogenous0.x ) + ( invFrameMatrix.m12 * homogenous0.y ) ) + ( invFrameMatrix.m22 * homogenous0.z ) ) + ( invFrameMatrix.m32 * homogenous0.w ) ), ( ( ( ( invFrameMatrix.m03 * homogenous0.x ) + ( invFrameMatrix.m13 * homogenous0.y ) ) + ( invFrameMatrix.m23 * homogenous0.z ) ) + ( invFrameMatrix.m33 * homogenous0.w ) ))) );
					global::hxmath.math.Vector4Default b1 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(( ( ( ( self4.m00 * homogenous0.x ) + ( self4.m10 * homogenous0.y ) ) + ( self4.m20 * homogenous0.z ) ) + ( self4.m30 * homogenous0.w ) ), ( ( ( ( self4.m01 * homogenous0.x ) + ( self4.m11 * homogenous0.y ) ) + ( self4.m21 * homogenous0.z ) ) + ( self4.m31 * homogenous0.w ) ), ( ( ( ( self4.m02 * homogenous0.x ) + ( self4.m12 * homogenous0.y ) ) + ( self4.m22 * homogenous0.z ) ) + ( self4.m32 * homogenous0.w ) ), ( ( ( ( self4.m03 * homogenous0.x ) + ( self4.m13 * homogenous0.y ) ) + ( self4.m23 * homogenous0.z ) ) + ( self4.m33 * homogenous0.w ) ))) );
					global::hxmath.math.Vector4Default self5 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(a1.x, a1.y, a1.z, a1.w)) );
					self5.x -= b1.x;
					self5.y -= b1.y;
					self5.z -= b1.z;
					self5.w -= b1.w;
					global::hxmath.math.Vector4Default self6 = ((global::hxmath.math.Vector4Default) (self5) );
					this.assertApproxEquals(0.0, ( ( ( ( self6.x * self6.x ) + ( self6.y * self6.y ) ) + ( self6.z * self6.z ) ) + ( self6.w * self6.w ) ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testMatrixFrameInverse", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (126) )}));
					global::hxmath.math.Vector4Default a2 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(( ( ( ( invFrameMatrix.m00 * homogenousX.x ) + ( invFrameMatrix.m10 * homogenousX.y ) ) + ( invFrameMatrix.m20 * homogenousX.z ) ) + ( invFrameMatrix.m30 * homogenousX.w ) ), ( ( ( ( invFrameMatrix.m01 * homogenousX.x ) + ( invFrameMatrix.m11 * homogenousX.y ) ) + ( invFrameMatrix.m21 * homogenousX.z ) ) + ( invFrameMatrix.m31 * homogenousX.w ) ), ( ( ( ( invFrameMatrix.m02 * homogenousX.x ) + ( invFrameMatrix.m12 * homogenousX.y ) ) + ( invFrameMatrix.m22 * homogenousX.z ) ) + ( invFrameMatrix.m32 * homogenousX.w ) ), ( ( ( ( invFrameMatrix.m03 * homogenousX.x ) + ( invFrameMatrix.m13 * homogenousX.y ) ) + ( invFrameMatrix.m23 * homogenousX.z ) ) + ( invFrameMatrix.m33 * homogenousX.w ) ))) );
					global::hxmath.math.Vector4Default b2 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(( ( ( ( self4.m00 * homogenousX.x ) + ( self4.m10 * homogenousX.y ) ) + ( self4.m20 * homogenousX.z ) ) + ( self4.m30 * homogenousX.w ) ), ( ( ( ( self4.m01 * homogenousX.x ) + ( self4.m11 * homogenousX.y ) ) + ( self4.m21 * homogenousX.z ) ) + ( self4.m31 * homogenousX.w ) ), ( ( ( ( self4.m02 * homogenousX.x ) + ( self4.m12 * homogenousX.y ) ) + ( self4.m22 * homogenousX.z ) ) + ( self4.m32 * homogenousX.w ) ), ( ( ( ( self4.m03 * homogenousX.x ) + ( self4.m13 * homogenousX.y ) ) + ( self4.m23 * homogenousX.z ) ) + ( self4.m33 * homogenousX.w ) ))) );
					global::hxmath.math.Vector4Default self7 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(a2.x, a2.y, a2.z, a2.w)) );
					self7.x -= b2.x;
					self7.y -= b2.y;
					self7.z -= b2.z;
					self7.w -= b2.w;
					global::hxmath.math.Vector4Default self8 = ((global::hxmath.math.Vector4Default) (self7) );
					this.assertApproxEquals(0.0, ( ( ( ( self8.x * self8.x ) + ( self8.y * self8.y ) ) + ( self8.z * self8.z ) ) + ( self8.w * self8.w ) ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testMatrixFrameInverse", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (127) )}));
					global::hxmath.math.Vector4Default a3 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(( ( ( ( invFrameMatrix.m00 * homogenousY.x ) + ( invFrameMatrix.m10 * homogenousY.y ) ) + ( invFrameMatrix.m20 * homogenousY.z ) ) + ( invFrameMatrix.m30 * homogenousY.w ) ), ( ( ( ( invFrameMatrix.m01 * homogenousY.x ) + ( invFrameMatrix.m11 * homogenousY.y ) ) + ( invFrameMatrix.m21 * homogenousY.z ) ) + ( invFrameMatrix.m31 * homogenousY.w ) ), ( ( ( ( invFrameMatrix.m02 * homogenousY.x ) + ( invFrameMatrix.m12 * homogenousY.y ) ) + ( invFrameMatrix.m22 * homogenousY.z ) ) + ( invFrameMatrix.m32 * homogenousY.w ) ), ( ( ( ( invFrameMatrix.m03 * homogenousY.x ) + ( invFrameMatrix.m13 * homogenousY.y ) ) + ( invFrameMatrix.m23 * homogenousY.z ) ) + ( invFrameMatrix.m33 * homogenousY.w ) ))) );
					global::hxmath.math.Vector4Default b3 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(( ( ( ( self4.m00 * homogenousY.x ) + ( self4.m10 * homogenousY.y ) ) + ( self4.m20 * homogenousY.z ) ) + ( self4.m30 * homogenousY.w ) ), ( ( ( ( self4.m01 * homogenousY.x ) + ( self4.m11 * homogenousY.y ) ) + ( self4.m21 * homogenousY.z ) ) + ( self4.m31 * homogenousY.w ) ), ( ( ( ( self4.m02 * homogenousY.x ) + ( self4.m12 * homogenousY.y ) ) + ( self4.m22 * homogenousY.z ) ) + ( self4.m32 * homogenousY.w ) ), ( ( ( ( self4.m03 * homogenousY.x ) + ( self4.m13 * homogenousY.y ) ) + ( self4.m23 * homogenousY.z ) ) + ( self4.m33 * homogenousY.w ) ))) );
					global::hxmath.math.Vector4Default self9 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(a3.x, a3.y, a3.z, a3.w)) );
					self9.x -= b3.x;
					self9.y -= b3.y;
					self9.z -= b3.z;
					self9.w -= b3.w;
					global::hxmath.math.Vector4Default self10 = ((global::hxmath.math.Vector4Default) (self9) );
					this.assertApproxEquals(0.0, ( ( ( ( self10.x * self10.x ) + ( self10.y * self10.y ) ) + ( self10.z * self10.z ) ) + ( self10.w * self10.w ) ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testMatrixFrameInverse", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (128) )}));
					global::hxmath.math.Vector4Default a4 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(( ( ( ( invFrameMatrix.m00 * homogenousZ.x ) + ( invFrameMatrix.m10 * homogenousZ.y ) ) + ( invFrameMatrix.m20 * homogenousZ.z ) ) + ( invFrameMatrix.m30 * homogenousZ.w ) ), ( ( ( ( invFrameMatrix.m01 * homogenousZ.x ) + ( invFrameMatrix.m11 * homogenousZ.y ) ) + ( invFrameMatrix.m21 * homogenousZ.z ) ) + ( invFrameMatrix.m31 * homogenousZ.w ) ), ( ( ( ( invFrameMatrix.m02 * homogenousZ.x ) + ( invFrameMatrix.m12 * homogenousZ.y ) ) + ( invFrameMatrix.m22 * homogenousZ.z ) ) + ( invFrameMatrix.m32 * homogenousZ.w ) ), ( ( ( ( invFrameMatrix.m03 * homogenousZ.x ) + ( invFrameMatrix.m13 * homogenousZ.y ) ) + ( invFrameMatrix.m23 * homogenousZ.z ) ) + ( invFrameMatrix.m33 * homogenousZ.w ) ))) );
					global::hxmath.math.Vector4Default b4 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(( ( ( ( self4.m00 * homogenousZ.x ) + ( self4.m10 * homogenousZ.y ) ) + ( self4.m20 * homogenousZ.z ) ) + ( self4.m30 * homogenousZ.w ) ), ( ( ( ( self4.m01 * homogenousZ.x ) + ( self4.m11 * homogenousZ.y ) ) + ( self4.m21 * homogenousZ.z ) ) + ( self4.m31 * homogenousZ.w ) ), ( ( ( ( self4.m02 * homogenousZ.x ) + ( self4.m12 * homogenousZ.y ) ) + ( self4.m22 * homogenousZ.z ) ) + ( self4.m32 * homogenousZ.w ) ), ( ( ( ( self4.m03 * homogenousZ.x ) + ( self4.m13 * homogenousZ.y ) ) + ( self4.m23 * homogenousZ.z ) ) + ( self4.m33 * homogenousZ.w ) ))) );
					global::hxmath.math.Vector4Default self11 = ((global::hxmath.math.Vector4Default) (new global::hxmath.math.Vector4Default(a4.x, a4.y, a4.z, a4.w)) );
					self11.x -= b4.x;
					self11.y -= b4.y;
					self11.z -= b4.z;
					self11.w -= b4.w;
					global::hxmath.math.Vector4Default self12 = ((global::hxmath.math.Vector4Default) (self11) );
					this.assertApproxEquals(0.0, ( ( ( ( self12.x * self12.x ) + ( self12.y * self12.y ) ) + ( self12.z * self12.z ) ) + ( self12.w * self12.w ) ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testMatrixFrameInverse", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (129) )}));
				}
				
			}
		}
		
		
		public virtual void testQuaternionInverse() {
			unchecked {
				int _g = 0;
				while (( _g < 10 )) {
					 ++ _g;
					global::hxmath.math.QuaternionDefault self = ((global::hxmath.math.QuaternionDefault) (this.randomQuaternion(default(global::haxe.lang.Null<double>))) );
					double _g1 = ( 1.0 / global::System.Math.Sqrt(((double) (( ( ( ( self.s * self.s ) + ( self.x * self.x ) ) + ( self.y * self.y ) ) + ( self.z * self.z ) )) )) );
					global::hxmath.math.QuaternionDefault self1 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(self.s, self.x, self.y, self.z)) );
					self1.s *= _g1;
					self1.x *= _g1;
					self1.y *= _g1;
					self1.z *= _g1;
					global::hxmath.math.QuaternionDefault self2 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(self1.s, self1.x, self1.y, self1.z)) );
					self2.x =  - (self2.x) ;
					self2.y =  - (self2.y) ;
					self2.z =  - (self2.z) ;
					global::hxmath.math.QuaternionDefault p = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(( ( ( ( self1.s * self2.s ) - ( self1.x * self2.x ) ) - ( self1.y * self2.y ) ) - ( self1.z * self2.z ) ), ( ( ( ( self1.s * self2.x ) + ( self2.s * self1.x ) ) + ( self1.y * self2.z ) ) - ( self1.z * self2.y ) ), ( ( ( ( self1.s * self2.y ) + ( self2.s * self1.y ) ) + ( self1.z * self2.x ) ) - ( self1.x * self2.z ) ), ( ( ( ( self1.s * self2.z ) + ( self2.s * self1.z ) ) + ( self1.x * self2.y ) ) - ( self1.y * self2.x ) ))) );
					this.assertApproxEquals(1.0, p.s, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testQuaternionInverse", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (142) )}));
					global::hxmath.math.Vector3Default self3 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(p.x, p.y, p.z)) );
					this.assertApproxEquals(0.0, global::System.Math.Sqrt(((double) (( ( ( self3.x * self3.x ) + ( self3.y * self3.y ) ) + ( self3.z * self3.z ) )) )), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testQuaternionInverse", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (143) )}));
				}
				
			}
		}
		
		
		public virtual void testOrthoNormalize() {
			unchecked {
				int _g = 0;
				while (( _g < 10 )) {
					 ++ _g;
					global::hxmath.math.Vector3Default u = this.randomVector3(default(global::haxe.lang.Null<double>));
					global::hxmath.math.Vector3Default v = this.randomVector3(default(global::haxe.lang.Null<double>));
					global::hxmath.math.Vector3Default w = this.randomVector3(default(global::haxe.lang.Null<double>));
					{
						{
							double length = global::System.Math.Sqrt(((double) (( ( ( u.x * u.x ) + ( u.y * u.y ) ) + ( u.z * u.z ) )) ));
							if (( length > 0.0 )) {
								u.x /= length;
								u.y /= length;
								u.z /= length;
							}
							
						}
						
						{
							global::hxmath.math.Vector3Default self = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(v.x, v.y, v.z)) );
							double s = ( (( ( ( self.x * u.x ) + ( self.y * u.y ) ) + ( self.z * u.z ) )) / (( ( ( u.x * u.x ) + ( u.y * u.y ) ) + ( u.z * u.z ) )) );
							{
								int _g1 = 0;
								while (( _g1 < 3 )) {
									int i = _g1++;
									{
										object tmp = null;
										switch (i) {
											case 0:
											{
												tmp = u.x;
												break;
											}
											
											
											case 1:
											{
												tmp = u.y;
												break;
											}
											
											
											case 2:
											{
												tmp = u.z;
												break;
											}
											
											
											default:
											{
												throw global::haxe.lang.HaxeException.wrap("Invalid element");
											}
											
										}
										
										double @value = ((double) (global::haxe.lang.Runtime.toDouble(tmp)) );
										switch (i) {
											case 0:
											{
												self.x = @value;
												break;
											}
											
											
											case 1:
											{
												self.y = @value;
												break;
											}
											
											
											case 2:
											{
												self.z = @value;
												break;
											}
											
											
											default:
											{
												throw global::haxe.lang.HaxeException.wrap("Invalid element");
											}
											
										}
										
									}
									
								}
								
							}
							
							{
								self.x *= s;
								self.y *= s;
								self.z *= s;
							}
							
							v.x -= self.x;
							v.y -= self.y;
							v.z -= self.z;
						}
						
						{
							double length1 = global::System.Math.Sqrt(((double) (( ( ( v.x * v.x ) + ( v.y * v.y ) ) + ( v.z * v.z ) )) ));
							if (( length1 > 0.0 )) {
								v.x /= length1;
								v.y /= length1;
								v.z /= length1;
							}
							
						}
						
						{
							global::hxmath.math.Vector3Default self1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(w.x, w.y, w.z)) );
							double s1 = ( (( ( ( self1.x * u.x ) + ( self1.y * u.y ) ) + ( self1.z * u.z ) )) / (( ( ( u.x * u.x ) + ( u.y * u.y ) ) + ( u.z * u.z ) )) );
							{
								int _g2 = 0;
								while (( _g2 < 3 )) {
									int i1 = _g2++;
									{
										object tmp1 = null;
										switch (i1) {
											case 0:
											{
												tmp1 = u.x;
												break;
											}
											
											
											case 1:
											{
												tmp1 = u.y;
												break;
											}
											
											
											case 2:
											{
												tmp1 = u.z;
												break;
											}
											
											
											default:
											{
												throw global::haxe.lang.HaxeException.wrap("Invalid element");
											}
											
										}
										
										double value1 = ((double) (global::haxe.lang.Runtime.toDouble(tmp1)) );
										switch (i1) {
											case 0:
											{
												self1.x = value1;
												break;
											}
											
											
											case 1:
											{
												self1.y = value1;
												break;
											}
											
											
											case 2:
											{
												self1.z = value1;
												break;
											}
											
											
											default:
											{
												throw global::haxe.lang.HaxeException.wrap("Invalid element");
											}
											
										}
										
									}
									
								}
								
							}
							
							{
								self1.x *= s1;
								self1.y *= s1;
								self1.z *= s1;
							}
							
							w.x -= self1.x;
							w.y -= self1.y;
							w.z -= self1.z;
						}
						
						{
							global::hxmath.math.Vector3Default self2 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(w.x, w.y, w.z)) );
							double s2 = ( (( ( ( self2.x * v.x ) + ( self2.y * v.y ) ) + ( self2.z * v.z ) )) / (( ( ( v.x * v.x ) + ( v.y * v.y ) ) + ( v.z * v.z ) )) );
							{
								int _g3 = 0;
								while (( _g3 < 3 )) {
									int i2 = _g3++;
									{
										object tmp2 = null;
										switch (i2) {
											case 0:
											{
												tmp2 = v.x;
												break;
											}
											
											
											case 1:
											{
												tmp2 = v.y;
												break;
											}
											
											
											case 2:
											{
												tmp2 = v.z;
												break;
											}
											
											
											default:
											{
												throw global::haxe.lang.HaxeException.wrap("Invalid element");
											}
											
										}
										
										double value2 = ((double) (global::haxe.lang.Runtime.toDouble(tmp2)) );
										switch (i2) {
											case 0:
											{
												self2.x = value2;
												break;
											}
											
											
											case 1:
											{
												self2.y = value2;
												break;
											}
											
											
											case 2:
											{
												self2.z = value2;
												break;
											}
											
											
											default:
											{
												throw global::haxe.lang.HaxeException.wrap("Invalid element");
											}
											
										}
										
									}
									
								}
								
							}
							
							{
								self2.x *= s2;
								self2.y *= s2;
								self2.z *= s2;
							}
							
							w.x -= self2.x;
							w.y -= self2.y;
							w.z -= self2.z;
						}
						
						{
							double length2 = global::System.Math.Sqrt(((double) (( ( ( w.x * w.x ) + ( w.y * w.y ) ) + ( w.z * w.z ) )) ));
							if (( length2 > 0.0 )) {
								w.x /= length2;
								w.y /= length2;
								w.z /= length2;
							}
							
						}
						
					}
					
					this.assertApproxEquals(1.0, global::System.Math.Sqrt(((double) (( ( ( u.x * u.x ) + ( u.y * u.y ) ) + ( u.z * u.z ) )) )), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testOrthoNormalize", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (157) )}));
					this.assertApproxEquals(1.0, global::System.Math.Sqrt(((double) (( ( ( v.x * v.x ) + ( v.y * v.y ) ) + ( v.z * v.z ) )) )), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testOrthoNormalize", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (158) )}));
					this.assertApproxEquals(1.0, global::System.Math.Sqrt(((double) (( ( ( w.x * w.x ) + ( w.y * w.y ) ) + ( w.z * w.z ) )) )), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testOrthoNormalize", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (159) )}));
					this.assertApproxEquals(0.0, ( ( ( u.x * v.x ) + ( u.y * v.y ) ) + ( u.z * v.z ) ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testOrthoNormalize", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (160) )}));
					this.assertApproxEquals(0.0, ( ( ( u.x * w.x ) + ( u.y * w.y ) ) + ( u.z * w.z ) ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testOrthoNormalize", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (161) )}));
					this.assertApproxEquals(0.0, ( ( ( v.x * w.x ) + ( v.y * w.y ) ) + ( v.z * w.z ) ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testOrthoNormalize", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (162) )}));
					global::hxmath.math.Vector3Default self3 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(u.x, u.y, u.z)) );
					double newX = ( ( self3.y * v.z ) - ( self3.z * v.y ) );
					double newY = ( ( self3.z * v.x ) - ( self3.x * v.z ) );
					double newZ = ( ( self3.x * v.y ) - ( self3.y * v.x ) );
					self3.x = newX;
					self3.y = newY;
					self3.z = newZ;
					global::hxmath.math.Vector3Default self4 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(self3.x, self3.y, self3.z)) );
					double newX1 = ( ( self4.y * w.z ) - ( self4.z * w.y ) );
					double newY1 = ( ( self4.z * w.x ) - ( self4.x * w.z ) );
					double newZ1 = ( ( self4.x * w.y ) - ( self4.y * w.x ) );
					self4.x = newX1;
					self4.y = newY1;
					self4.z = newZ1;
					global::hxmath.math.Vector3Default self5 = ((global::hxmath.math.Vector3Default) (self4) );
					this.assertApproxEquals(0.0, global::System.Math.Sqrt(((double) (( ( ( self5.x * self5.x ) + ( self5.y * self5.y ) ) + ( self5.z * self5.z ) )) )), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testOrthoNormalize", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (164) )}));
				}
				
			}
		}
		
		
		public virtual void testAngles() {
			unchecked {
				global::hxmath.math.Vector3Default this1 = new global::hxmath.math.Vector3Default(1.0, 0.0, 0.0);
				global::hxmath.math.Vector3Default b = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 1.0, 0.0)) );
				global::hxmath.math.Vector3Default self = ((global::hxmath.math.Vector3Default) (this1) );
				this.assertApproxEquals(global::System.Math.Acos(((double) (( (( ( ( self.x * b.x ) + ( self.y * b.y ) ) + ( self.z * b.z ) )) / (( global::System.Math.Sqrt(((double) (( ( ( self.x * self.x ) + ( self.y * self.y ) ) + ( self.z * self.z ) )) )) * global::System.Math.Sqrt(((double) (( ( ( b.x * b.x ) + ( b.y * b.y ) ) + ( b.z * b.z ) )) )) )) )) )), ( global::Math.PI / 2.0 ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAngles", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (170) )}));
				global::hxmath.math.Vector3Default this2 = new global::hxmath.math.Vector3Default(1.0, 0.0, 0.0);
				global::hxmath.math.Vector3Default b1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				global::hxmath.math.Vector3Default self1 = ((global::hxmath.math.Vector3Default) (this2) );
				this.assertApproxEquals(global::System.Math.Acos(((double) (( (( ( ( self1.x * b1.x ) + ( self1.y * b1.y ) ) + ( self1.z * b1.z ) )) / (( global::System.Math.Sqrt(((double) (( ( ( self1.x * self1.x ) + ( self1.y * self1.y ) ) + ( self1.z * self1.z ) )) )) * global::System.Math.Sqrt(((double) (( ( ( b1.x * b1.x ) + ( b1.y * b1.y ) ) + ( b1.z * b1.z ) )) )) )) )) )), ( global::Math.PI / 2.0 ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAngles", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (171) )}));
				global::hxmath.math.Vector3Default this3 = new global::hxmath.math.Vector3Default(0.0, 1.0, 0.0);
				global::hxmath.math.Vector3Default b2 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				global::hxmath.math.Vector3Default self2 = ((global::hxmath.math.Vector3Default) (this3) );
				this.assertApproxEquals(global::System.Math.Acos(((double) (( (( ( ( self2.x * b2.x ) + ( self2.y * b2.y ) ) + ( self2.z * b2.z ) )) / (( global::System.Math.Sqrt(((double) (( ( ( self2.x * self2.x ) + ( self2.y * self2.y ) ) + ( self2.z * self2.z ) )) )) * global::System.Math.Sqrt(((double) (( ( ( b2.x * b2.x ) + ( b2.y * b2.y ) ) + ( b2.z * b2.z ) )) )) )) )) )), ( global::Math.PI / 2.0 ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testAngles", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (172) )}));
			}
		}
		
		
		public virtual void testReflect() {
			unchecked {
				int _g = 0;
				while (( _g < 10 )) {
					 ++ _g;
					global::hxmath.math.Vector3Default u = this.randomVector3(default(global::haxe.lang.Null<double>));
					global::hxmath.math.Vector3Default normal = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
					global::hxmath.math.Vector3Default self = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(u.x, u.y, u.z)) );
					global::hxmath.math.Vector3Default self1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(self.x, self.y, self.z)) );
					double s = ( (( ( ( self1.x * normal.x ) + ( self1.y * normal.y ) ) + ( self1.z * normal.z ) )) / (( ( ( normal.x * normal.x ) + ( normal.y * normal.y ) ) + ( normal.z * normal.z ) )) );
					{
						int _g1 = 0;
						while (( _g1 < 3 )) {
							int i = _g1++;
							{
								object tmp = null;
								switch (i) {
									case 0:
									{
										tmp = normal.x;
										break;
									}
									
									
									case 1:
									{
										tmp = normal.y;
										break;
									}
									
									
									case 2:
									{
										tmp = normal.z;
										break;
									}
									
									
									default:
									{
										throw global::haxe.lang.HaxeException.wrap("Invalid element");
									}
									
								}
								
								double @value = ((double) (global::haxe.lang.Runtime.toDouble(tmp)) );
								switch (i) {
									case 0:
									{
										self1.x = @value;
										break;
									}
									
									
									case 1:
									{
										self1.y = @value;
										break;
									}
									
									
									case 2:
									{
										self1.z = @value;
										break;
									}
									
									
									default:
									{
										throw global::haxe.lang.HaxeException.wrap("Invalid element");
									}
									
								}
								
							}
							
						}
						
					}
					
					{
						self1.x *= s;
						self1.y *= s;
						self1.z *= s;
					}
					
					{
						self1.x *= 2.0;
						self1.y *= 2.0;
						self1.z *= 2.0;
					}
					
					{
						self.x -= self1.x;
						self.y -= self1.y;
						self.z -= self1.z;
					}
					
					this.assertEquals<double>(((double) (u.x) ), ((double) (self.x) ), ((object) (new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testReflect", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (182) )})) ));
					this.assertEquals<double>(((double) (u.y) ), ((double) (self.y) ), ((object) (new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testReflect", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (183) )})) ));
					this.assertEquals<double>(((double) ( - (u.z) ) ), ((double) (self.z) ), ((object) (new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testReflect", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (184) )})) ));
				}
				
			}
		}
		
		
		public virtual void testProjectOntoPlane() {
			unchecked {
				int _g = 0;
				while (( _g < 10 )) {
					 ++ _g;
					global::hxmath.math.Vector3Default u = this.randomVector3(default(global::haxe.lang.Null<double>));
					global::hxmath.math.Vector3Default normal = this.randomVector3(default(global::haxe.lang.Null<double>));
					{
						global::hxmath.math.Vector3Default self = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(u.x, u.y, u.z)) );
						double s = ( (( ( ( self.x * normal.x ) + ( self.y * normal.y ) ) + ( self.z * normal.z ) )) / (( ( ( normal.x * normal.x ) + ( normal.y * normal.y ) ) + ( normal.z * normal.z ) )) );
						{
							int _g1 = 0;
							while (( _g1 < 3 )) {
								int i = _g1++;
								{
									object tmp = null;
									switch (i) {
										case 0:
										{
											tmp = normal.x;
											break;
										}
										
										
										case 1:
										{
											tmp = normal.y;
											break;
										}
										
										
										case 2:
										{
											tmp = normal.z;
											break;
										}
										
										
										default:
										{
											throw global::haxe.lang.HaxeException.wrap("Invalid element");
										}
										
									}
									
									double @value = ((double) (global::haxe.lang.Runtime.toDouble(tmp)) );
									switch (i) {
										case 0:
										{
											self.x = @value;
											break;
										}
										
										
										case 1:
										{
											self.y = @value;
											break;
										}
										
										
										case 2:
										{
											self.z = @value;
											break;
										}
										
										
										default:
										{
											throw global::haxe.lang.HaxeException.wrap("Invalid element");
										}
										
									}
									
								}
								
							}
							
						}
						
						{
							self.x *= s;
							self.y *= s;
							self.z *= s;
						}
						
						u.x -= self.x;
						u.y -= self.y;
						u.z -= self.z;
					}
					
					this.assertApproxEquals(0.0, ( ( ( u.x * normal.x ) + ( u.y * normal.y ) ) + ( u.z * normal.z ) ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testProjectOntoPlane", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (197) )}));
				}
				
			}
		}
		
		
		public virtual void testSlerpMidpointAngle() {
			unchecked {
				global::hxmath.math.Vector3Default axis = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				double angleRadians = ( ( global::Math.PI / 180 ) * 0 );
				double cosHalfAngle = global::System.Math.Cos(((double) (( angleRadians / 2.0 )) ));
				double sinHalfAngle = global::System.Math.Sin(((double) (( angleRadians / 2.0 )) ));
				global::hxmath.math.QuaternionDefault qA = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(cosHalfAngle, ( sinHalfAngle * axis.x ), ( sinHalfAngle * axis.y ), ( sinHalfAngle * axis.z ))) );
				global::hxmath.math.Vector3Default axis1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				double angleRadians1 = ( ( global::Math.PI / 180 ) * 90 );
				double cosHalfAngle1 = global::System.Math.Cos(((double) (( angleRadians1 / 2.0 )) ));
				double sinHalfAngle1 = global::System.Math.Sin(((double) (( angleRadians1 / 2.0 )) ));
				global::hxmath.math.QuaternionDefault qB = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(cosHalfAngle1, ( sinHalfAngle1 * axis1.x ), ( sinHalfAngle1 * axis1.y ), ( sinHalfAngle1 * axis1.z ))) );
				double cosHalfTheta = ( ( ( ( qA.s * qB.s ) + ( qA.x * qB.x ) ) + ( qA.y * qB.y ) ) + ( qA.z * qB.z ) );
				global::hxmath.math.QuaternionDefault qC = null;
				if (( global::System.Math.Abs(((double) (cosHalfTheta) )) >= 1.0 )) {
					qC = qA;
				}
				else {
					double halfTheta = global::System.Math.Acos(((double) (cosHalfTheta) ));
					double sinHalfTheta = global::System.Math.Sqrt(((double) (( 1.0 - ( cosHalfTheta * cosHalfTheta ) )) ));
					if (( global::System.Math.Abs(((double) (sinHalfTheta) )) < 1e-3 )) {
						global::hxmath.math.QuaternionDefault self = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(qA.s, qA.x, qA.y, qA.z)) );
						self.s *= 0.5;
						self.x *= 0.5;
						self.y *= 0.5;
						self.z *= 0.5;
						global::hxmath.math.QuaternionDefault self1 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(qB.s, qB.x, qB.y, qB.z)) );
						self1.s *= 0.5;
						self1.x *= 0.5;
						self1.y *= 0.5;
						self1.z *= 0.5;
						global::hxmath.math.QuaternionDefault self2 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(self.s, self.x, self.y, self.z)) );
						self2.s += self1.s;
						self2.x += self1.x;
						self2.y += self1.y;
						self2.z += self1.z;
						global::hxmath.math.QuaternionDefault self3 = ((global::hxmath.math.QuaternionDefault) (self2) );
						double length = global::System.Math.Sqrt(((double) (( ( ( ( self3.s * self3.s ) + ( self3.x * self3.x ) ) + ( self3.y * self3.y ) ) + ( self3.z * self3.z ) )) ));
						if (( length > 0.0 )) {
							double k = ( 1.0 / length );
							{
								self3.s *= k;
								self3.x *= k;
								self3.y *= k;
								self3.z *= k;
							}
							
						}
						
						qC = self3;
					}
					else {
						double ta = ( global::System.Math.Sin(((double) (( 0.5 * halfTheta )) )) / sinHalfTheta );
						double tb = ( global::System.Math.Sin(((double) (( 0.5 * halfTheta )) )) / sinHalfTheta );
						global::hxmath.math.QuaternionDefault result = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ))) );
						result.x = ( ( qA.x * ta ) + ( qB.x * tb ) );
						result.y = ( ( qA.y * ta ) + ( qB.y * tb ) );
						result.z = ( ( qA.z * ta ) + ( qB.z * tb ) );
						result.s = ( ( qA.s * ta ) + ( qB.s * tb ) );
						qC = result;
					}
					
				}
				
				double tmp = ( ( ( ( qA.s * qC.s ) + ( qA.x * qC.x ) ) + ( qA.y * qC.y ) ) + ( qA.z * qC.z ) );
				double tmp1 = global::System.Math.Sqrt(((double) (( ( ( ( qA.s * qA.s ) + ( qA.x * qA.x ) ) + ( qA.y * qA.y ) ) + ( qA.z * qA.z ) )) ));
				global::hxmath.math.QuaternionDefault self4 = ((global::hxmath.math.QuaternionDefault) (qC) );
				double angleAC = ( ( ( 2.0 * global::System.Math.Acos(((double) (( tmp / (( tmp1 * global::System.Math.Sqrt(((double) (( ( ( ( self4.s * self4.s ) + ( self4.x * self4.x ) ) + ( self4.y * self4.y ) ) + ( self4.z * self4.z ) )) )) )) )) )) ) * 180.0 ) / global::Math.PI );
				global::hxmath.math.QuaternionDefault self5 = ((global::hxmath.math.QuaternionDefault) (qC) );
				double angleCB = ( ( ( 2.0 * global::System.Math.Acos(((double) (( (( ( ( ( self5.s * qB.s ) + ( self5.x * qB.x ) ) + ( self5.y * qB.y ) ) + ( self5.z * qB.z ) )) / (( global::System.Math.Sqrt(((double) (( ( ( ( self5.s * self5.s ) + ( self5.x * self5.x ) ) + ( self5.y * self5.y ) ) + ( self5.z * self5.z ) )) )) * global::System.Math.Sqrt(((double) (( ( ( ( qB.s * qB.s ) + ( qB.x * qB.x ) ) + ( qB.y * qB.y ) ) + ( qB.z * qB.z ) )) )) )) )) )) ) * 180.0 ) / global::Math.PI );
				this.assertApproxEquals(45.0, angleAC, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testSlerpMidpointAngle", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (209) )}));
				this.assertApproxEquals(45.0, angleCB, default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testSlerpMidpointAngle", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (210) )}));
			}
		}
		
		
		public virtual void testSlerpMonotonicity() {
			unchecked {
				int _g = 0;
				while (( _g < 10 )) {
					 ++ _g;
					global::hxmath.math.QuaternionDefault self = ((global::hxmath.math.QuaternionDefault) (this.randomQuaternion(default(global::haxe.lang.Null<double>))) );
					double length = global::System.Math.Sqrt(((double) (( ( ( ( self.s * self.s ) + ( self.x * self.x ) ) + ( self.y * self.y ) ) + ( self.z * self.z ) )) ));
					if (( length > 0.0 )) {
						double k = ( 1.0 / length );
						{
							self.s *= k;
							self.x *= k;
							self.y *= k;
							self.z *= k;
						}
						
					}
					
					global::hxmath.math.QuaternionDefault self1 = ((global::hxmath.math.QuaternionDefault) (this.randomQuaternion(default(global::haxe.lang.Null<double>))) );
					double length1 = global::System.Math.Sqrt(((double) (( ( ( ( self1.s * self1.s ) + ( self1.x * self1.x ) ) + ( self1.y * self1.y ) ) + ( self1.z * self1.z ) )) ));
					if (( length1 > 0.0 )) {
						double k1 = ( 1.0 / length1 );
						{
							self1.s *= k1;
							self1.x *= k1;
							self1.y *= k1;
							self1.z *= k1;
						}
						
					}
					
					double lastAC = global::Math.NEGATIVE_INFINITY;
					double lastCB = global::Math.POSITIVE_INFINITY;
					{
						int _g1 = 1;
						while (( _g1 < 12 )) {
							double t = ( ((double) (_g1++) ) / 12 );
							double cosHalfTheta = ( ( ( ( self.s * self1.s ) + ( self.x * self1.x ) ) + ( self.y * self1.y ) ) + ( self.z * self1.z ) );
							global::hxmath.math.QuaternionDefault qC = null;
							if (( global::System.Math.Abs(((double) (cosHalfTheta) )) >= 1.0 )) {
								qC = self;
							}
							else {
								double halfTheta = global::System.Math.Acos(((double) (cosHalfTheta) ));
								double sinHalfTheta = global::System.Math.Sqrt(((double) (( 1.0 - ( cosHalfTheta * cosHalfTheta ) )) ));
								if (( global::System.Math.Abs(((double) (sinHalfTheta) )) < 1e-3 )) {
									double s = ( 1.0 - t );
									global::hxmath.math.QuaternionDefault self2 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(self.s, self.x, self.y, self.z)) );
									self2.s *= s;
									self2.x *= s;
									self2.y *= s;
									self2.z *= s;
									global::hxmath.math.QuaternionDefault self3 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(self1.s, self1.x, self1.y, self1.z)) );
									self3.s *= t;
									self3.x *= t;
									self3.y *= t;
									self3.z *= t;
									global::hxmath.math.QuaternionDefault self4 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(self2.s, self2.x, self2.y, self2.z)) );
									self4.s += self3.s;
									self4.x += self3.x;
									self4.y += self3.y;
									self4.z += self3.z;
									global::hxmath.math.QuaternionDefault self5 = ((global::hxmath.math.QuaternionDefault) (self4) );
									double length2 = global::System.Math.Sqrt(((double) (( ( ( ( self5.s * self5.s ) + ( self5.x * self5.x ) ) + ( self5.y * self5.y ) ) + ( self5.z * self5.z ) )) ));
									if (( length2 > 0.0 )) {
										double k2 = ( 1.0 / length2 );
										{
											self5.s *= k2;
											self5.x *= k2;
											self5.y *= k2;
											self5.z *= k2;
										}
										
									}
									
									qC = self5;
								}
								else {
									double ta = ( global::System.Math.Sin(((double) (( (( 1 - t )) * halfTheta )) )) / sinHalfTheta );
									double tb = ( global::System.Math.Sin(((double) (( t * halfTheta )) )) / sinHalfTheta );
									global::hxmath.math.QuaternionDefault result = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ))) );
									result.x = ( ( self.x * ta ) + ( self1.x * tb ) );
									result.y = ( ( self.y * ta ) + ( self1.y * tb ) );
									result.z = ( ( self.z * ta ) + ( self1.z * tb ) );
									result.s = ( ( self.s * ta ) + ( self1.s * tb ) );
									qC = result;
								}
								
							}
							
							double tmp = ( ( ( ( self.s * qC.s ) + ( self.x * qC.x ) ) + ( self.y * qC.y ) ) + ( self.z * qC.z ) );
							double tmp1 = global::System.Math.Sqrt(((double) (( ( ( ( self.s * self.s ) + ( self.x * self.x ) ) + ( self.y * self.y ) ) + ( self.z * self.z ) )) ));
							global::hxmath.math.QuaternionDefault self6 = ((global::hxmath.math.QuaternionDefault) (qC) );
							double angleAC = ( ( ( 2.0 * global::System.Math.Acos(((double) (( tmp / (( tmp1 * global::System.Math.Sqrt(((double) (( ( ( ( self6.s * self6.s ) + ( self6.x * self6.x ) ) + ( self6.y * self6.y ) ) + ( self6.z * self6.z ) )) )) )) )) )) ) * 180.0 ) / global::Math.PI );
							global::hxmath.math.QuaternionDefault self7 = ((global::hxmath.math.QuaternionDefault) (qC) );
							double angleCB = ( ( ( 2.0 * global::System.Math.Acos(((double) (( (( ( ( ( self7.s * self1.s ) + ( self7.x * self1.x ) ) + ( self7.y * self1.y ) ) + ( self7.z * self1.z ) )) / (( global::System.Math.Sqrt(((double) (( ( ( ( self7.s * self7.s ) + ( self7.x * self7.x ) ) + ( self7.y * self7.y ) ) + ( self7.z * self7.z ) )) )) * global::System.Math.Sqrt(((double) (( ( ( ( self1.s * self1.s ) + ( self1.x * self1.x ) ) + ( self1.y * self1.y ) ) + ( self1.z * self1.z ) )) )) )) )) )) ) * 180.0 ) / global::Math.PI );
							this.assertTrue(( angleAC > lastAC ), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testSlerpMonotonicity", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (230) )}));
							this.assertTrue(( angleCB < lastCB ), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testSlerpMonotonicity", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (231) )}));
							lastAC = angleAC;
							lastCB = angleCB;
						}
						
					}
					
				}
				
			}
		}
		
		
		public virtual void testSlerpLargeAngleStability() {
			unchecked {
				global::hxmath.math.Vector3Default axis = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				double angleRadians = ( ( global::Math.PI / 180 ) * 0 );
				double cosHalfAngle = global::System.Math.Cos(((double) (( angleRadians / 2.0 )) ));
				double sinHalfAngle = global::System.Math.Sin(((double) (( angleRadians / 2.0 )) ));
				global::hxmath.math.QuaternionDefault qA = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(cosHalfAngle, ( sinHalfAngle * axis.x ), ( sinHalfAngle * axis.y ), ( sinHalfAngle * axis.z ))) );
				global::hxmath.math.Vector3Default axis1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				double angleRadians1 = ( ( global::Math.PI / 180 ) * 180 );
				double cosHalfAngle1 = global::System.Math.Cos(((double) (( angleRadians1 / 2.0 )) ));
				double sinHalfAngle1 = global::System.Math.Sin(((double) (( angleRadians1 / 2.0 )) ));
				global::hxmath.math.QuaternionDefault qB = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(cosHalfAngle1, ( sinHalfAngle1 * axis1.x ), ( sinHalfAngle1 * axis1.y ), ( sinHalfAngle1 * axis1.z ))) );
				double cosHalfTheta = ( ( ( ( qA.s * qB.s ) + ( qA.x * qB.x ) ) + ( qA.y * qB.y ) ) + ( qA.z * qB.z ) );
				global::hxmath.math.QuaternionDefault qC = null;
				if (( global::System.Math.Abs(((double) (cosHalfTheta) )) >= 1.0 )) {
					qC = qA;
				}
				else {
					double halfTheta = global::System.Math.Acos(((double) (cosHalfTheta) ));
					double sinHalfTheta = global::System.Math.Sqrt(((double) (( 1.0 - ( cosHalfTheta * cosHalfTheta ) )) ));
					if (( global::System.Math.Abs(((double) (sinHalfTheta) )) < 1e-3 )) {
						global::hxmath.math.QuaternionDefault self = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(qA.s, qA.x, qA.y, qA.z)) );
						self.s *= 0.5;
						self.x *= 0.5;
						self.y *= 0.5;
						self.z *= 0.5;
						global::hxmath.math.QuaternionDefault self1 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(qB.s, qB.x, qB.y, qB.z)) );
						self1.s *= 0.5;
						self1.x *= 0.5;
						self1.y *= 0.5;
						self1.z *= 0.5;
						global::hxmath.math.QuaternionDefault self2 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(self.s, self.x, self.y, self.z)) );
						self2.s += self1.s;
						self2.x += self1.x;
						self2.y += self1.y;
						self2.z += self1.z;
						global::hxmath.math.QuaternionDefault self3 = ((global::hxmath.math.QuaternionDefault) (self2) );
						double length = global::System.Math.Sqrt(((double) (( ( ( ( self3.s * self3.s ) + ( self3.x * self3.x ) ) + ( self3.y * self3.y ) ) + ( self3.z * self3.z ) )) ));
						if (( length > 0.0 )) {
							double k = ( 1.0 / length );
							{
								self3.s *= k;
								self3.x *= k;
								self3.y *= k;
								self3.z *= k;
							}
							
						}
						
						qC = self3;
					}
					else {
						double ta = ( global::System.Math.Sin(((double) (( 0.5 * halfTheta )) )) / sinHalfTheta );
						double tb = ( global::System.Math.Sin(((double) (( 0.5 * halfTheta )) )) / sinHalfTheta );
						global::hxmath.math.QuaternionDefault result = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ))) );
						result.x = ( ( qA.x * ta ) + ( qB.x * tb ) );
						result.y = ( ( qA.y * ta ) + ( qB.y * tb ) );
						result.z = ( ( qA.z * ta ) + ( qB.z * tb ) );
						result.s = ( ( qA.s * ta ) + ( qB.s * tb ) );
						qC = result;
					}
					
				}
				
				global::hxmath.math.QuaternionDefault self4 = ((global::hxmath.math.QuaternionDefault) (qC) );
				this.assertApproxEquals(((double) (90) ), ( ( ( 2.0 * global::System.Math.Acos(((double) (( (( ( ( ( self4.s * qA.s ) + ( self4.x * qA.x ) ) + ( self4.y * qA.y ) ) + ( self4.z * qA.z ) )) / (( global::System.Math.Sqrt(((double) (( ( ( ( self4.s * self4.s ) + ( self4.x * self4.x ) ) + ( self4.y * self4.y ) ) + ( self4.z * self4.z ) )) )) * global::System.Math.Sqrt(((double) (( ( ( ( qA.s * qA.s ) + ( qA.x * qA.x ) ) + ( qA.y * qA.y ) ) + ( qA.z * qA.z ) )) )) )) )) )) ) * 180.0 ) / global::Math.PI ), default(global::haxe.lang.Null<double>), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testSlerpLargeAngleStability", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (244) )}));
			}
		}
		
		
		public virtual void testSlerpSmallAngleStability() {
			unchecked {
				global::hxmath.math.Vector3Default axis = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				double angleRadians = ( ( global::Math.PI / 180 ) * 0 );
				double cosHalfAngle = global::System.Math.Cos(((double) (( angleRadians / 2.0 )) ));
				double sinHalfAngle = global::System.Math.Sin(((double) (( angleRadians / 2.0 )) ));
				global::hxmath.math.QuaternionDefault qA = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(cosHalfAngle, ( sinHalfAngle * axis.x ), ( sinHalfAngle * axis.y ), ( sinHalfAngle * axis.z ))) );
				global::hxmath.math.Vector3Default axis1 = ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) );
				double angleRadians1 = ( ( global::Math.PI / 180 ) * 1e-2 );
				double cosHalfAngle1 = global::System.Math.Cos(((double) (( angleRadians1 / 2.0 )) ));
				double sinHalfAngle1 = global::System.Math.Sin(((double) (( angleRadians1 / 2.0 )) ));
				global::hxmath.math.QuaternionDefault qB = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(cosHalfAngle1, ( sinHalfAngle1 * axis1.x ), ( sinHalfAngle1 * axis1.y ), ( sinHalfAngle1 * axis1.z ))) );
				double cosHalfTheta = ( ( ( ( qA.s * qB.s ) + ( qA.x * qB.x ) ) + ( qA.y * qB.y ) ) + ( qA.z * qB.z ) );
				global::hxmath.math.QuaternionDefault qC = null;
				if (( global::System.Math.Abs(((double) (cosHalfTheta) )) >= 1.0 )) {
					qC = qA;
				}
				else {
					double halfTheta = global::System.Math.Acos(((double) (cosHalfTheta) ));
					double sinHalfTheta = global::System.Math.Sqrt(((double) (( 1.0 - ( cosHalfTheta * cosHalfTheta ) )) ));
					if (( global::System.Math.Abs(((double) (sinHalfTheta) )) < 1e-3 )) {
						global::hxmath.math.QuaternionDefault self = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(qA.s, qA.x, qA.y, qA.z)) );
						self.s *= 0.5;
						self.x *= 0.5;
						self.y *= 0.5;
						self.z *= 0.5;
						global::hxmath.math.QuaternionDefault self1 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(qB.s, qB.x, qB.y, qB.z)) );
						self1.s *= 0.5;
						self1.x *= 0.5;
						self1.y *= 0.5;
						self1.z *= 0.5;
						global::hxmath.math.QuaternionDefault self2 = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(self.s, self.x, self.y, self.z)) );
						self2.s += self1.s;
						self2.x += self1.x;
						self2.y += self1.y;
						self2.z += self1.z;
						global::hxmath.math.QuaternionDefault self3 = ((global::hxmath.math.QuaternionDefault) (self2) );
						double length = global::System.Math.Sqrt(((double) (( ( ( ( self3.s * self3.s ) + ( self3.x * self3.x ) ) + ( self3.y * self3.y ) ) + ( self3.z * self3.z ) )) ));
						if (( length > 0.0 )) {
							double k = ( 1.0 / length );
							{
								self3.s *= k;
								self3.x *= k;
								self3.y *= k;
								self3.z *= k;
							}
							
						}
						
						qC = self3;
					}
					else {
						double ta = ( global::System.Math.Sin(((double) (( 0.5 * halfTheta )) )) / sinHalfTheta );
						double tb = ( global::System.Math.Sin(((double) (( 0.5 * halfTheta )) )) / sinHalfTheta );
						global::hxmath.math.QuaternionDefault result = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(((double) (0) ), ((double) (0) ), ((double) (0) ), ((double) (0) ))) );
						result.x = ( ( qA.x * ta ) + ( qB.x * tb ) );
						result.y = ( ( qA.y * ta ) + ( qB.y * tb ) );
						result.z = ( ( qA.z * ta ) + ( qB.z * tb ) );
						result.s = ( ( qA.s * ta ) + ( qB.s * tb ) );
						qC = result;
					}
					
				}
				
				double tmp = ( ( ( ( qA.s * qC.s ) + ( qA.x * qC.x ) ) + ( qA.y * qC.y ) ) + ( qA.z * qC.z ) );
				double tmp1 = global::System.Math.Sqrt(((double) (( ( ( ( qA.s * qA.s ) + ( qA.x * qA.x ) ) + ( qA.y * qA.y ) ) + ( qA.z * qA.z ) )) ));
				global::hxmath.math.QuaternionDefault self4 = ((global::hxmath.math.QuaternionDefault) (qC) );
				this.assertTrue(( ( 2.0 * global::System.Math.Acos(((double) (( tmp / (( tmp1 * global::System.Math.Sqrt(((double) (( ( ( ( self4.s * self4.s ) + ( self4.x * self4.x ) ) + ( self4.y * self4.y ) ) + ( self4.z * self4.z ) )) )) )) )) )) ) <= 1e-2 ), new global::haxe.lang.DynamicObject(new int[]{302979532, 1547539107, 1648581351}, new object[]{"testSlerpSmallAngleStability", "test.Test3D", "Test3D.hx"}, new int[]{1981972957}, new double[]{((double) (253) )}));
			}
		}
		
		
		public override object __hx_getField(string field, int hash, bool throwErrors, bool isCheck, bool handleProperties) {
			unchecked {
				switch (hash) {
					case 266765349:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testSlerpSmallAngleStability", 266765349)) );
					}
					
					
					case 1262127641:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testSlerpLargeAngleStability", 1262127641)) );
					}
					
					
					case 1577172252:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testSlerpMonotonicity", 1577172252)) );
					}
					
					
					case 1884102419:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testSlerpMidpointAngle", 1884102419)) );
					}
					
					
					case 77524475:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testProjectOntoPlane", 77524475)) );
					}
					
					
					case 636645899:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testReflect", 636645899)) );
					}
					
					
					case 2081250098:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testAngles", 2081250098)) );
					}
					
					
					case 1915543847:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testOrthoNormalize", 1915543847)) );
					}
					
					
					case 1132126592:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testQuaternionInverse", 1132126592)) );
					}
					
					
					case 1198379990:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testMatrixFrameInverse", 1198379990)) );
					}
					
					
					case 903896652:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testQuaternionToMatrix", 903896652)) );
					}
					
					
					case 791337897:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testAxialRotation", 791337897)) );
					}
					
					
					case 368514155:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testCrossProductPrecedence", 368514155)) );
					}
					
					
					case 939327441:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testAddSub", 939327441)) );
					}
					
					
					case 593012163:
					{
						return ((global::haxe.lang.Function) (new global::haxe.lang.Closure(this, "testMatrixMult", 593012163)) );
					}
					
					
					default:
					{
						return base.__hx_getField(field, hash, throwErrors, isCheck, handleProperties);
					}
					
				}
				
			}
		}
		
		
		public override object __hx_invokeField(string field, int hash, global::Array dynargs) {
			unchecked {
				switch (hash) {
					case 266765349:
					{
						this.testSlerpSmallAngleStability();
						break;
					}
					
					
					case 1262127641:
					{
						this.testSlerpLargeAngleStability();
						break;
					}
					
					
					case 1577172252:
					{
						this.testSlerpMonotonicity();
						break;
					}
					
					
					case 1884102419:
					{
						this.testSlerpMidpointAngle();
						break;
					}
					
					
					case 77524475:
					{
						this.testProjectOntoPlane();
						break;
					}
					
					
					case 636645899:
					{
						this.testReflect();
						break;
					}
					
					
					case 2081250098:
					{
						this.testAngles();
						break;
					}
					
					
					case 1915543847:
					{
						this.testOrthoNormalize();
						break;
					}
					
					
					case 1132126592:
					{
						this.testQuaternionInverse();
						break;
					}
					
					
					case 1198379990:
					{
						this.testMatrixFrameInverse();
						break;
					}
					
					
					case 903896652:
					{
						this.testQuaternionToMatrix();
						break;
					}
					
					
					case 791337897:
					{
						this.testAxialRotation();
						break;
					}
					
					
					case 368514155:
					{
						this.testCrossProductPrecedence();
						break;
					}
					
					
					case 939327441:
					{
						this.testAddSub();
						break;
					}
					
					
					case 593012163:
					{
						this.testMatrixMult();
						break;
					}
					
					
					default:
					{
						return base.__hx_invokeField(field, hash, dynargs);
					}
					
				}
				
				return null;
			}
		}
		
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace test {
	public class Test3D_testQuaternionToMatrix_71__Fun : global::haxe.lang.Function {
		
		public Test3D_testQuaternionToMatrix_71__Fun() : base(2, 0) {
		}
		
		
		public static global::test.Test3D_testQuaternionToMatrix_71__Fun __hx_current;
		
		public override object __hx_invoke2_o(double __fn_float1, object __fn_dyn1, double __fn_float2, object __fn_dyn2) {
			unchecked {
				int axis = ( (( __fn_dyn2 == global::haxe.lang.Runtime.undefined )) ? (((int) (__fn_float2) )) : (((int) (global::haxe.lang.Runtime.toInt(__fn_dyn2)) )) );
				double unitAngle = ( (( __fn_dyn1 == global::haxe.lang.Runtime.undefined )) ? (((double) (__fn_float1) )) : (((double) (global::haxe.lang.Runtime.toDouble(__fn_dyn1)) )) );
				global::Array<object> axes = new global::Array<object>(new object[]{((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(1.0, 0.0, 0.0)) ), ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 1.0, 0.0)) ), ((global::hxmath.math.Vector3Default) (new global::hxmath.math.Vector3Default(0.0, 0.0, 1.0)) )});
				global::Array<object> @const = new global::Array<object>(new object[]{((global::haxe.lang.Function) (new global::haxe.lang.Closure(typeof(global::hxmath.math._Matrix3x3.Matrix3x3_Impl_), "rotationX", 1827625306)) ), ((global::haxe.lang.Function) (new global::haxe.lang.Closure(typeof(global::hxmath.math._Matrix3x3.Matrix3x3_Impl_), "rotationY", 1827625307)) ), ((global::haxe.lang.Function) (new global::haxe.lang.Closure(typeof(global::hxmath.math._Matrix3x3.Matrix3x3_Impl_), "rotationZ", 1827625308)) )});
				double angle = ( unitAngle * 360.0 );
				global::hxmath.math.Vector3Default axis1 = ((global::hxmath.math.Vector3Default) (axes[axis]) );
				double angleRadians = ( ( global::Math.PI / 180 ) * angle );
				double cosHalfAngle = global::System.Math.Cos(((double) (( angleRadians / 2.0 )) ));
				double sinHalfAngle = global::System.Math.Sin(((double) (( angleRadians / 2.0 )) ));
				global::hxmath.math.QuaternionDefault q = ((global::hxmath.math.QuaternionDefault) (new global::hxmath.math.QuaternionDefault(cosHalfAngle, ( sinHalfAngle * axis1.x ), ( sinHalfAngle * axis1.y ), ( sinHalfAngle * axis1.z ))) );
				double s = q.s;
				double x = q.x;
				double y = q.y;
				double z = q.z;
				{
					global::hxmath.math.Matrix3x3Default __temp_odecl1 = ((global::hxmath.math.Matrix3x3Default) (((global::haxe.lang.Function) (@const[axis]) ).__hx_invoke1_o(angle, global::haxe.lang.Runtime.undefined)) );
					global::hxmath.math.Matrix3x3Default __temp_odecl2 = ((global::hxmath.math.Matrix3x3Default) (new global::hxmath.math.Matrix3x3Default(( 1 - ( 2 * (( ( y * y ) + ( z * z ) )) ) ), ( 2 * (( ( x * y ) - ( s * z ) )) ), ( 2 * (( ( s * y ) + ( x * z ) )) ), ( 2 * (( ( x * y ) + ( s * z ) )) ), ( 1 - ( 2 * (( ( x * x ) + ( z * z ) )) ) ), ( 2 * (( ( y * z ) - ( s * x ) )) ), ( 2 * (( ( x * z ) - ( s * y ) )) ), ( 2 * (( ( y * z ) + ( s * x ) )) ), ( 1 - ( 2 * (( ( x * x ) + ( y * y ) )) ) ))) );
					return new global::haxe.lang.DynamicObject(new int[]{109, 110}, new object[]{__temp_odecl1, __temp_odecl2}, new int[]{}, new double[]{});
				}
				
			}
		}
		
		
	}
}


