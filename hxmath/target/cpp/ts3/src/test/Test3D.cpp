// Generated by Haxe 3.3.0
#include <hxcpp.h>

#include "hxMath.h"
#ifndef INCLUDED_hxmath_frames_IFrame3
#include <hxmath/frames/IFrame3.h>
#endif
#ifndef INCLUDED_hxmath_frames__Frame3_Frame3_Impl_
#include <hxmath/frames/_Frame3/Frame3_Impl_.h>
#endif
#ifndef INCLUDED_hxmath_math_Matrix3x3Default
#include <hxmath/math/Matrix3x3Default.h>
#endif
#ifndef INCLUDED_hxmath_math_Matrix4x4Default
#include <hxmath/math/Matrix4x4Default.h>
#endif
#ifndef INCLUDED_hxmath_math_QuaternionDefault
#include <hxmath/math/QuaternionDefault.h>
#endif
#ifndef INCLUDED_hxmath_math_Vector3Default
#include <hxmath/math/Vector3Default.h>
#endif
#ifndef INCLUDED_hxmath_math_Vector4Default
#include <hxmath/math/Vector4Default.h>
#endif
#ifndef INCLUDED_hxmath_math__Matrix3x3_Matrix3x3_Impl_
#include <hxmath/math/_Matrix3x3/Matrix3x3_Impl_.h>
#endif
#ifndef INCLUDED_nanotest_NanoTestAssertResult
#include <nanotest/NanoTestAssertResult.h>
#endif
#ifndef INCLUDED_nanotest_NanoTestCase
#include <nanotest/NanoTestCase.h>
#endif
#ifndef INCLUDED_test_MathTestCase
#include <test/MathTestCase.h>
#endif
#ifndef INCLUDED_test_Test3D
#include <test/Test3D.h>
#endif

namespace test{

void Test3D_obj::__construct( ::Dynamic posInfos){
            	HX_STACK_FRAME("test.Test3D","new",0x1dd2eab1,"test.Test3D.new","test/Test3D.hx",11,0x591b2dbe)
            	HX_STACK_THIS(this)
            	HX_STACK_ARG(posInfos,"posInfos")
HXLINE(  11)		super::__construct(posInfos);
            	}

Dynamic Test3D_obj::__CreateEmpty() { return new Test3D_obj; }

hx::ObjectPtr< Test3D_obj > Test3D_obj::__new( ::Dynamic posInfos)
{
	hx::ObjectPtr< Test3D_obj > _hx_result = new Test3D_obj();
	_hx_result->__construct(posInfos);
	return _hx_result;
}

Dynamic Test3D_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Test3D_obj > _hx_result = new Test3D_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

void Test3D_obj::testMatrixMult(){
            	HX_STACK_FRAME("test.Test3D","testMatrixMult",0xc6ed7b12,"test.Test3D.testMatrixMult","test/Test3D.hx",15,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE(  15)		HX_VARI( Int,_g) = (int)0;
HXDLIN(  15)		while((_g < (int)10)){
HXLINE(  15)			++_g;
HXLINE(  17)			HX_VARI(  ::hxmath::math::Matrix3x3Default,a) = this->randomMatrix3x3(null());
HXLINE(  18)			HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,a1,"a") =  ::hxmath::math::Matrix3x3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0),((Float)0.0),((Float)1.0),((Float)0.0),((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN(  18)			HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,a2,"a") =  ::hxmath::math::Matrix3x3Default_obj::__new((((a1->m00 * a->m00) + (a1->m10 * a->m01)) + (a1->m20 * a->m02)),(((a1->m00 * a->m10) + (a1->m10 * a->m11)) + (a1->m20 * a->m12)),(((a1->m00 * a->m20) + (a1->m10 * a->m21)) + (a1->m20 * a->m22)),(((a1->m01 * a->m00) + (a1->m11 * a->m01)) + (a1->m21 * a->m02)),(((a1->m01 * a->m10) + (a1->m11 * a->m11)) + (a1->m21 * a->m12)),(((a1->m01 * a->m20) + (a1->m11 * a->m21)) + (a1->m21 * a->m22)),(((a1->m02 * a->m00) + (a1->m12 * a->m01)) + (a1->m22 * a->m02)),(((a1->m02 * a->m10) + (a1->m12 * a->m11)) + (a1->m22 * a->m12)),(((a1->m02 * a->m20) + (a1->m12 * a->m21)) + (a1->m22 * a->m22)));
HXDLIN(  18)			Bool _hx_tmp;
HXDLIN(  18)			Bool _hx_tmp1;
HXDLIN(  18)			if (hx::IsNull( a2 )) {
HXLINE(  18)				_hx_tmp1 = hx::IsNull( a );
            			}
            			else {
HXLINE(  18)				_hx_tmp1 = false;
            			}
HXDLIN(  18)			if (!(_hx_tmp1)) {
HXLINE(  18)				Bool _hx_tmp2;
HXDLIN(  18)				Bool _hx_tmp3;
HXDLIN(  18)				Bool _hx_tmp4;
HXDLIN(  18)				Bool _hx_tmp5;
HXDLIN(  18)				Bool _hx_tmp6;
HXDLIN(  18)				Bool _hx_tmp7;
HXDLIN(  18)				Bool _hx_tmp8;
HXDLIN(  18)				Bool _hx_tmp9;
HXDLIN(  18)				Bool _hx_tmp10;
HXDLIN(  18)				if (hx::IsNotNull( a2 )) {
HXLINE(  18)					_hx_tmp10 = hx::IsNotNull( a );
            				}
            				else {
HXLINE(  18)					_hx_tmp10 = false;
            				}
HXDLIN(  18)				if (_hx_tmp10) {
HXLINE(  18)					_hx_tmp9 = (a2->m00 == a->m00);
            				}
            				else {
HXLINE(  18)					_hx_tmp9 = false;
            				}
HXDLIN(  18)				if (_hx_tmp9) {
HXLINE(  18)					_hx_tmp8 = (a2->m10 == a->m10);
            				}
            				else {
HXLINE(  18)					_hx_tmp8 = false;
            				}
HXDLIN(  18)				if (_hx_tmp8) {
HXLINE(  18)					_hx_tmp7 = (a2->m20 == a->m20);
            				}
            				else {
HXLINE(  18)					_hx_tmp7 = false;
            				}
HXDLIN(  18)				if (_hx_tmp7) {
HXLINE(  18)					_hx_tmp6 = (a2->m01 == a->m01);
            				}
            				else {
HXLINE(  18)					_hx_tmp6 = false;
            				}
HXDLIN(  18)				if (_hx_tmp6) {
HXLINE(  18)					_hx_tmp5 = (a2->m11 == a->m11);
            				}
            				else {
HXLINE(  18)					_hx_tmp5 = false;
            				}
HXDLIN(  18)				if (_hx_tmp5) {
HXLINE(  18)					_hx_tmp4 = (a2->m21 == a->m21);
            				}
            				else {
HXLINE(  18)					_hx_tmp4 = false;
            				}
HXDLIN(  18)				if (_hx_tmp4) {
HXLINE(  18)					_hx_tmp3 = (a2->m02 == a->m02);
            				}
            				else {
HXLINE(  18)					_hx_tmp3 = false;
            				}
HXDLIN(  18)				if (_hx_tmp3) {
HXLINE(  18)					_hx_tmp2 = (a2->m12 == a->m12);
            				}
            				else {
HXLINE(  18)					_hx_tmp2 = false;
            				}
HXDLIN(  18)				if (_hx_tmp2) {
HXLINE(  18)					_hx_tmp = (a2->m22 == a->m22);
            				}
            				else {
HXLINE(  18)					_hx_tmp = false;
            				}
            			}
            			else {
HXLINE(  18)				_hx_tmp = true;
            			}
HXDLIN(  18)			this->assertTrue(_hx_tmp,hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),18,HX_("test.Test3D",3f,be,21,72),HX_("testMatrixMult",c3,a5,58,23)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testMatrixMult,(void))

void Test3D_obj::testAddSub(){
            	HX_STACK_FRAME("test.Test3D","testAddSub",0x10eb41a0,"test.Test3D.testAddSub","test/Test3D.hx",23,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE(  24)		{
HXLINE(  24)			HX_VARI( Int,_g) = (int)0;
HXDLIN(  24)			while((_g < (int)10)){
HXLINE(  24)				++_g;
HXLINE(  26)				HX_VARI(  ::hxmath::math::Matrix3x3Default,a) = this->randomMatrix3x3(null());
HXLINE(  27)				HX_VARI(  ::hxmath::math::Matrix3x3Default,b) = this->randomMatrix3x3(null());
HXLINE(  28)				HX_VARI(  ::hxmath::math::Matrix3x3Default,c) =  ::hxmath::math::Matrix3x3Default_obj::__new(a->m00,a->m10,a->m20,a->m01,a->m11,a->m21,a->m02,a->m12,a->m22);
HXLINE(  29)				hx::AddEq(c->m00,b->m00);
HXDLIN(  29)				hx::AddEq(c->m10,b->m10);
HXDLIN(  29)				hx::AddEq(c->m20,b->m20);
HXDLIN(  29)				hx::AddEq(c->m01,b->m01);
HXDLIN(  29)				hx::AddEq(c->m11,b->m11);
HXDLIN(  29)				hx::AddEq(c->m21,b->m21);
HXDLIN(  29)				hx::AddEq(c->m02,b->m02);
HXDLIN(  29)				hx::AddEq(c->m12,b->m12);
HXDLIN(  29)				hx::AddEq(c->m22,b->m22);
HXDLIN(  29)				HX_VARI(  ::hxmath::math::Matrix3x3Default,self) =  ::hxmath::math::Matrix3x3Default_obj::__new(a->m00,a->m10,a->m20,a->m01,a->m11,a->m21,a->m02,a->m12,a->m22);
HXDLIN(  29)				hx::AddEq(self->m00,b->m00);
HXDLIN(  29)				hx::AddEq(self->m10,b->m10);
HXDLIN(  29)				hx::AddEq(self->m20,b->m20);
HXDLIN(  29)				hx::AddEq(self->m01,b->m01);
HXDLIN(  29)				hx::AddEq(self->m11,b->m11);
HXDLIN(  29)				hx::AddEq(self->m21,b->m21);
HXDLIN(  29)				hx::AddEq(self->m02,b->m02);
HXDLIN(  29)				hx::AddEq(self->m12,b->m12);
HXDLIN(  29)				hx::AddEq(self->m22,b->m22);
HXDLIN(  29)				Bool _hx_tmp;
HXDLIN(  29)				Bool _hx_tmp1;
HXDLIN(  29)				if (hx::IsNull( c )) {
HXLINE(  29)					_hx_tmp1 = hx::IsNull( self );
            				}
            				else {
HXLINE(  29)					_hx_tmp1 = false;
            				}
HXDLIN(  29)				if (!(_hx_tmp1)) {
HXLINE(  29)					Bool _hx_tmp2;
HXDLIN(  29)					Bool _hx_tmp3;
HXDLIN(  29)					Bool _hx_tmp4;
HXDLIN(  29)					Bool _hx_tmp5;
HXDLIN(  29)					Bool _hx_tmp6;
HXDLIN(  29)					Bool _hx_tmp7;
HXDLIN(  29)					Bool _hx_tmp8;
HXDLIN(  29)					Bool _hx_tmp9;
HXDLIN(  29)					Bool _hx_tmp10;
HXDLIN(  29)					if (hx::IsNotNull( c )) {
HXLINE(  29)						_hx_tmp10 = hx::IsNotNull( self );
            					}
            					else {
HXLINE(  29)						_hx_tmp10 = false;
            					}
HXDLIN(  29)					if (_hx_tmp10) {
HXLINE(  29)						_hx_tmp9 = (c->m00 == self->m00);
            					}
            					else {
HXLINE(  29)						_hx_tmp9 = false;
            					}
HXDLIN(  29)					if (_hx_tmp9) {
HXLINE(  29)						_hx_tmp8 = (c->m10 == self->m10);
            					}
            					else {
HXLINE(  29)						_hx_tmp8 = false;
            					}
HXDLIN(  29)					if (_hx_tmp8) {
HXLINE(  29)						_hx_tmp7 = (c->m20 == self->m20);
            					}
            					else {
HXLINE(  29)						_hx_tmp7 = false;
            					}
HXDLIN(  29)					if (_hx_tmp7) {
HXLINE(  29)						_hx_tmp6 = (c->m01 == self->m01);
            					}
            					else {
HXLINE(  29)						_hx_tmp6 = false;
            					}
HXDLIN(  29)					if (_hx_tmp6) {
HXLINE(  29)						_hx_tmp5 = (c->m11 == self->m11);
            					}
            					else {
HXLINE(  29)						_hx_tmp5 = false;
            					}
HXDLIN(  29)					if (_hx_tmp5) {
HXLINE(  29)						_hx_tmp4 = (c->m21 == self->m21);
            					}
            					else {
HXLINE(  29)						_hx_tmp4 = false;
            					}
HXDLIN(  29)					if (_hx_tmp4) {
HXLINE(  29)						_hx_tmp3 = (c->m02 == self->m02);
            					}
            					else {
HXLINE(  29)						_hx_tmp3 = false;
            					}
HXDLIN(  29)					if (_hx_tmp3) {
HXLINE(  29)						_hx_tmp2 = (c->m12 == self->m12);
            					}
            					else {
HXLINE(  29)						_hx_tmp2 = false;
            					}
HXDLIN(  29)					if (_hx_tmp2) {
HXLINE(  29)						_hx_tmp = (c->m22 == self->m22);
            					}
            					else {
HXLINE(  29)						_hx_tmp = false;
            					}
            				}
            				else {
HXLINE(  29)					_hx_tmp = true;
            				}
HXDLIN(  29)				this->assertTrue(_hx_tmp,hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),29,HX_("test.Test3D",3f,be,21,72),HX_("testAddSub",d1,ff,fc,b7)));
            			}
            		}
HXLINE(  32)		{
HXLINE(  32)			HX_VARI_NAME( Int,_g1,"_g") = (int)0;
HXDLIN(  32)			while((_g1 < (int)10)){
HXLINE(  32)				++_g1;
HXLINE(  34)				HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,a1,"a") = this->randomMatrix3x3(null());
HXLINE(  35)				HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,b1,"b") = this->randomMatrix3x3(null());
HXLINE(  36)				HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,c1,"c") =  ::hxmath::math::Matrix3x3Default_obj::__new(a1->m00,a1->m10,a1->m20,a1->m01,a1->m11,a1->m21,a1->m02,a1->m12,a1->m22);
HXLINE(  37)				hx::SubEq(c1->m00,b1->m00);
HXDLIN(  37)				hx::SubEq(c1->m10,b1->m10);
HXDLIN(  37)				hx::SubEq(c1->m20,b1->m20);
HXDLIN(  37)				hx::SubEq(c1->m01,b1->m01);
HXDLIN(  37)				hx::SubEq(c1->m11,b1->m11);
HXDLIN(  37)				hx::SubEq(c1->m21,b1->m21);
HXDLIN(  37)				hx::SubEq(c1->m02,b1->m02);
HXDLIN(  37)				hx::SubEq(c1->m12,b1->m12);
HXDLIN(  37)				hx::SubEq(c1->m22,b1->m22);
HXDLIN(  37)				HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,self1,"self") =  ::hxmath::math::Matrix3x3Default_obj::__new(a1->m00,a1->m10,a1->m20,a1->m01,a1->m11,a1->m21,a1->m02,a1->m12,a1->m22);
HXDLIN(  37)				hx::SubEq(self1->m00,b1->m00);
HXDLIN(  37)				hx::SubEq(self1->m10,b1->m10);
HXDLIN(  37)				hx::SubEq(self1->m20,b1->m20);
HXDLIN(  37)				hx::SubEq(self1->m01,b1->m01);
HXDLIN(  37)				hx::SubEq(self1->m11,b1->m11);
HXDLIN(  37)				hx::SubEq(self1->m21,b1->m21);
HXDLIN(  37)				hx::SubEq(self1->m02,b1->m02);
HXDLIN(  37)				hx::SubEq(self1->m12,b1->m12);
HXDLIN(  37)				hx::SubEq(self1->m22,b1->m22);
HXDLIN(  37)				Bool _hx_tmp11;
HXDLIN(  37)				Bool _hx_tmp12;
HXDLIN(  37)				if (hx::IsNull( c1 )) {
HXLINE(  37)					_hx_tmp12 = hx::IsNull( self1 );
            				}
            				else {
HXLINE(  37)					_hx_tmp12 = false;
            				}
HXDLIN(  37)				if (!(_hx_tmp12)) {
HXLINE(  37)					Bool _hx_tmp13;
HXDLIN(  37)					Bool _hx_tmp14;
HXDLIN(  37)					Bool _hx_tmp15;
HXDLIN(  37)					Bool _hx_tmp16;
HXDLIN(  37)					Bool _hx_tmp17;
HXDLIN(  37)					Bool _hx_tmp18;
HXDLIN(  37)					Bool _hx_tmp19;
HXDLIN(  37)					Bool _hx_tmp20;
HXDLIN(  37)					Bool _hx_tmp21;
HXDLIN(  37)					if (hx::IsNotNull( c1 )) {
HXLINE(  37)						_hx_tmp21 = hx::IsNotNull( self1 );
            					}
            					else {
HXLINE(  37)						_hx_tmp21 = false;
            					}
HXDLIN(  37)					if (_hx_tmp21) {
HXLINE(  37)						_hx_tmp20 = (c1->m00 == self1->m00);
            					}
            					else {
HXLINE(  37)						_hx_tmp20 = false;
            					}
HXDLIN(  37)					if (_hx_tmp20) {
HXLINE(  37)						_hx_tmp19 = (c1->m10 == self1->m10);
            					}
            					else {
HXLINE(  37)						_hx_tmp19 = false;
            					}
HXDLIN(  37)					if (_hx_tmp19) {
HXLINE(  37)						_hx_tmp18 = (c1->m20 == self1->m20);
            					}
            					else {
HXLINE(  37)						_hx_tmp18 = false;
            					}
HXDLIN(  37)					if (_hx_tmp18) {
HXLINE(  37)						_hx_tmp17 = (c1->m01 == self1->m01);
            					}
            					else {
HXLINE(  37)						_hx_tmp17 = false;
            					}
HXDLIN(  37)					if (_hx_tmp17) {
HXLINE(  37)						_hx_tmp16 = (c1->m11 == self1->m11);
            					}
            					else {
HXLINE(  37)						_hx_tmp16 = false;
            					}
HXDLIN(  37)					if (_hx_tmp16) {
HXLINE(  37)						_hx_tmp15 = (c1->m21 == self1->m21);
            					}
            					else {
HXLINE(  37)						_hx_tmp15 = false;
            					}
HXDLIN(  37)					if (_hx_tmp15) {
HXLINE(  37)						_hx_tmp14 = (c1->m02 == self1->m02);
            					}
            					else {
HXLINE(  37)						_hx_tmp14 = false;
            					}
HXDLIN(  37)					if (_hx_tmp14) {
HXLINE(  37)						_hx_tmp13 = (c1->m12 == self1->m12);
            					}
            					else {
HXLINE(  37)						_hx_tmp13 = false;
            					}
HXDLIN(  37)					if (_hx_tmp13) {
HXLINE(  37)						_hx_tmp11 = (c1->m22 == self1->m22);
            					}
            					else {
HXLINE(  37)						_hx_tmp11 = false;
            					}
            				}
            				else {
HXLINE(  37)					_hx_tmp11 = true;
            				}
HXDLIN(  37)				this->assertTrue(_hx_tmp11,hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),37,HX_("test.Test3D",3f,be,21,72),HX_("testAddSub",d1,ff,fc,b7)));
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testAddSub,(void))

void Test3D_obj::testCrossProductPrecedence(){
            	HX_STACK_FRAME("test.Test3D","testCrossProductPrecedence",0x765e243a,"test.Test3D.testCrossProductPrecedence","test/Test3D.hx",43,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE(  43)		HX_VARI(  ::hxmath::math::Vector3Default,a) =  ::hxmath::math::Vector3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0));
HXDLIN(  43)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,a1,"a") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)1.0),((Float)0.0));
HXDLIN(  43)		HX_VARI(  ::hxmath::math::Vector3Default,b) =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN(  43)		HX_VARI(  ::hxmath::math::Vector3Default,self) =  ::hxmath::math::Vector3Default_obj::__new(a1->x,a1->y,a1->z);
HXDLIN(  43)		HX_VARI( Float,newX) = ((self->y * b->z) - (self->z * b->y));
HXDLIN(  43)		HX_VARI( Float,newY) = ((self->z * b->x) - (self->x * b->z));
HXDLIN(  43)		HX_VARI( Float,newZ) = ((self->x * b->y) - (self->y * b->x));
HXDLIN(  43)		self->x = newX;
HXDLIN(  43)		self->y = newY;
HXDLIN(  43)		self->z = newZ;
HXDLIN(  43)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self1,"self") =  ::hxmath::math::Vector3Default_obj::__new(a->x,a->y,a->z);
HXDLIN(  43)		hx::AddEq(self1->x,self->x);
HXDLIN(  43)		hx::AddEq(self1->y,self->y);
HXDLIN(  43)		hx::AddEq(self1->z,self->z);
HXDLIN(  43)		HX_VARI(  ::hxmath::math::Vector3Default,_g1) =  ::hxmath::math::Vector3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0));
HXDLIN(  43)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self2,"self") =  ::hxmath::math::Vector3Default_obj::__new(_g1->x,_g1->y,_g1->z);
HXDLIN(  43)		hx::MultEq(self2->x,((Float)2.0));
HXDLIN(  43)		hx::MultEq(self2->y,((Float)2.0));
HXDLIN(  43)		hx::MultEq(self2->z,((Float)2.0));
HXDLIN(  43)		Bool _hx_tmp;
HXDLIN(  43)		Bool _hx_tmp1;
HXDLIN(  43)		if (hx::IsNull( self1 )) {
HXLINE(  43)			_hx_tmp1 = hx::IsNull( self2 );
            		}
            		else {
HXLINE(  43)			_hx_tmp1 = false;
            		}
HXDLIN(  43)		if (!(_hx_tmp1)) {
HXLINE(  43)			Bool _hx_tmp2;
HXDLIN(  43)			Bool _hx_tmp3;
HXDLIN(  43)			Bool _hx_tmp4;
HXDLIN(  43)			if (hx::IsNotNull( self1 )) {
HXLINE(  43)				_hx_tmp4 = hx::IsNotNull( self2 );
            			}
            			else {
HXLINE(  43)				_hx_tmp4 = false;
            			}
HXDLIN(  43)			if (_hx_tmp4) {
HXLINE(  43)				_hx_tmp3 = (self1->x == self2->x);
            			}
            			else {
HXLINE(  43)				_hx_tmp3 = false;
            			}
HXDLIN(  43)			if (_hx_tmp3) {
HXLINE(  43)				_hx_tmp2 = (self1->y == self2->y);
            			}
            			else {
HXLINE(  43)				_hx_tmp2 = false;
            			}
HXDLIN(  43)			if (_hx_tmp2) {
HXLINE(  43)				_hx_tmp = (self1->z == self2->z);
            			}
            			else {
HXLINE(  43)				_hx_tmp = false;
            			}
            		}
            		else {
HXLINE(  43)			_hx_tmp = true;
            		}
HXDLIN(  43)		this->assertTrue(_hx_tmp,hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),43,HX_("test.Test3D",3f,be,21,72),HX_("testCrossProductPrecedence",6b,14,f7,15)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testCrossProductPrecedence,(void))

void Test3D_obj::testAxialRotation(){
            	HX_STACK_FRAME("test.Test3D","testAxialRotation",0xfec101ba,"test.Test3D.testAxialRotation","test/Test3D.hx",47,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE(  53)		HX_VARI( Float,angleRadians) = (((Float)::Math_obj::PI / (Float)(int)180) * ((Float)90.0));
HXDLIN(  53)		HX_VARI( Float,s) = ::Math_obj::sin(angleRadians);
HXDLIN(  53)		HX_VARI( Float,c) = ::Math_obj::cos(angleRadians);
HXDLIN(  53)		HX_VARI(  ::hxmath::math::Matrix3x3Default,a) =  ::hxmath::math::Matrix3x3Default_obj::__new((int)1,(int)0,(int)0,(int)0,c,-(s),(int)0,s,c);
HXDLIN(  53)		HX_VARI(  ::hxmath::math::Vector3Default,v) =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)1.0),((Float)0.0));
HXDLIN(  53)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,a1,"a") =  ::hxmath::math::Vector3Default_obj::__new((((a->m00 * v->x) + (a->m10 * v->y)) + (a->m20 * v->z)),(((a->m01 * v->x) + (a->m11 * v->y)) + (a->m21 * v->z)),(((a->m02 * v->x) + (a->m12 * v->y)) + (a->m22 * v->z)));
HXDLIN(  53)		HX_VARI(  ::hxmath::math::Vector3Default,b) =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN(  53)		HX_VARI(  ::hxmath::math::Vector3Default,self) =  ::hxmath::math::Vector3Default_obj::__new(a1->x,a1->y,a1->z);
HXDLIN(  53)		hx::SubEq(self->x,b->x);
HXDLIN(  53)		hx::SubEq(self->y,b->y);
HXDLIN(  53)		hx::SubEq(self->z,b->z);
HXDLIN(  53)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self1,"self") = self;
HXDLIN(  53)		Float _hx_tmp = (((self1->x * self1->x) + (self1->y * self1->y)) + (self1->z * self1->z));
HXDLIN(  53)		Float _hx_tmp1 = ::Math_obj::sqrt(_hx_tmp);
HXDLIN(  53)		this->assertApproxEquals(_hx_tmp1,((Float)0.0),null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),53,HX_("test.Test3D",3f,be,21,72),HX_("testAxialRotation",a9,db,2a,2f)));
HXLINE(  54)		HX_VARI_NAME( Float,angleRadians1,"angleRadians") = (((Float)::Math_obj::PI / (Float)(int)180) * ((Float)90.0));
HXDLIN(  54)		HX_VARI_NAME( Float,s1,"s") = ::Math_obj::sin(angleRadians1);
HXDLIN(  54)		HX_VARI_NAME( Float,c1,"c") = ::Math_obj::cos(angleRadians1);
HXDLIN(  54)		HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,a2,"a") =  ::hxmath::math::Matrix3x3Default_obj::__new((int)1,(int)0,(int)0,(int)0,c1,-(s1),(int)0,s1,c1);
HXDLIN(  54)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,v1,"v") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN(  54)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,a3,"a") =  ::hxmath::math::Vector3Default_obj::__new((((a2->m00 * v1->x) + (a2->m10 * v1->y)) + (a2->m20 * v1->z)),(((a2->m01 * v1->x) + (a2->m11 * v1->y)) + (a2->m21 * v1->z)),(((a2->m02 * v1->x) + (a2->m12 * v1->y)) + (a2->m22 * v1->z)));
HXDLIN(  54)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,b1,"b") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)1.0),((Float)0.0));
HXDLIN(  54)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self2,"self") =  ::hxmath::math::Vector3Default_obj::__new(a3->x,a3->y,a3->z);
HXDLIN(  54)		hx::AddEq(self2->x,b1->x);
HXDLIN(  54)		hx::AddEq(self2->y,b1->y);
HXDLIN(  54)		hx::AddEq(self2->z,b1->z);
HXDLIN(  54)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self3,"self") = self2;
HXDLIN(  54)		Float _hx_tmp2 = (((self3->x * self3->x) + (self3->y * self3->y)) + (self3->z * self3->z));
HXDLIN(  54)		Float _hx_tmp3 = ::Math_obj::sqrt(_hx_tmp2);
HXDLIN(  54)		this->assertApproxEquals(_hx_tmp3,((Float)0.0),null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),54,HX_("test.Test3D",3f,be,21,72),HX_("testAxialRotation",a9,db,2a,2f)));
HXLINE(  59)		HX_VARI_NAME( Float,angleRadians2,"angleRadians") = (((Float)::Math_obj::PI / (Float)(int)180) * ((Float)90.0));
HXDLIN(  59)		HX_VARI_NAME( Float,s2,"s") = ::Math_obj::sin(angleRadians2);
HXDLIN(  59)		HX_VARI_NAME( Float,c2,"c") = ::Math_obj::cos(angleRadians2);
HXDLIN(  59)		HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,a4,"a") =  ::hxmath::math::Matrix3x3Default_obj::__new(c2,(int)0,s2,(int)0,(int)1,(int)0,-(s2),(int)0,c2);
HXDLIN(  59)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,v2,"v") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN(  59)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,a5,"a") =  ::hxmath::math::Vector3Default_obj::__new((((a4->m00 * v2->x) + (a4->m10 * v2->y)) + (a4->m20 * v2->z)),(((a4->m01 * v2->x) + (a4->m11 * v2->y)) + (a4->m21 * v2->z)),(((a4->m02 * v2->x) + (a4->m12 * v2->y)) + (a4->m22 * v2->z)));
HXDLIN(  59)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,b2,"b") =  ::hxmath::math::Vector3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0));
HXDLIN(  59)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self4,"self") =  ::hxmath::math::Vector3Default_obj::__new(a5->x,a5->y,a5->z);
HXDLIN(  59)		hx::SubEq(self4->x,b2->x);
HXDLIN(  59)		hx::SubEq(self4->y,b2->y);
HXDLIN(  59)		hx::SubEq(self4->z,b2->z);
HXDLIN(  59)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self5,"self") = self4;
HXDLIN(  59)		Float _hx_tmp4 = (((self5->x * self5->x) + (self5->y * self5->y)) + (self5->z * self5->z));
HXDLIN(  59)		Float _hx_tmp5 = ::Math_obj::sqrt(_hx_tmp4);
HXDLIN(  59)		this->assertApproxEquals(_hx_tmp5,((Float)0.0),null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),59,HX_("test.Test3D",3f,be,21,72),HX_("testAxialRotation",a9,db,2a,2f)));
HXLINE(  60)		HX_VARI_NAME( Float,angleRadians3,"angleRadians") = (((Float)::Math_obj::PI / (Float)(int)180) * ((Float)90.0));
HXDLIN(  60)		HX_VARI_NAME( Float,s3,"s") = ::Math_obj::sin(angleRadians3);
HXDLIN(  60)		HX_VARI_NAME( Float,c3,"c") = ::Math_obj::cos(angleRadians3);
HXDLIN(  60)		HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,a6,"a") =  ::hxmath::math::Matrix3x3Default_obj::__new(c3,(int)0,s3,(int)0,(int)1,(int)0,-(s3),(int)0,c3);
HXDLIN(  60)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,v3,"v") =  ::hxmath::math::Vector3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0));
HXDLIN(  60)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,a7,"a") =  ::hxmath::math::Vector3Default_obj::__new((((a6->m00 * v3->x) + (a6->m10 * v3->y)) + (a6->m20 * v3->z)),(((a6->m01 * v3->x) + (a6->m11 * v3->y)) + (a6->m21 * v3->z)),(((a6->m02 * v3->x) + (a6->m12 * v3->y)) + (a6->m22 * v3->z)));
HXDLIN(  60)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,b3,"b") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN(  60)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self6,"self") =  ::hxmath::math::Vector3Default_obj::__new(a7->x,a7->y,a7->z);
HXDLIN(  60)		hx::AddEq(self6->x,b3->x);
HXDLIN(  60)		hx::AddEq(self6->y,b3->y);
HXDLIN(  60)		hx::AddEq(self6->z,b3->z);
HXDLIN(  60)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self7,"self") = self6;
HXDLIN(  60)		Float _hx_tmp6 = (((self7->x * self7->x) + (self7->y * self7->y)) + (self7->z * self7->z));
HXDLIN(  60)		Float _hx_tmp7 = ::Math_obj::sqrt(_hx_tmp6);
HXDLIN(  60)		this->assertApproxEquals(_hx_tmp7,((Float)0.0),null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),60,HX_("test.Test3D",3f,be,21,72),HX_("testAxialRotation",a9,db,2a,2f)));
HXLINE(  65)		HX_VARI_NAME( Float,angleRadians4,"angleRadians") = (((Float)::Math_obj::PI / (Float)(int)180) * ((Float)90.0));
HXDLIN(  65)		HX_VARI_NAME( Float,s4,"s") = ::Math_obj::sin(angleRadians4);
HXDLIN(  65)		HX_VARI_NAME( Float,c4,"c") = ::Math_obj::cos(angleRadians4);
HXDLIN(  65)		HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,a8,"a") =  ::hxmath::math::Matrix3x3Default_obj::__new(c4,-(s4),(int)0,s4,c4,(int)0,(int)0,(int)0,(int)1);
HXDLIN(  65)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,v4,"v") =  ::hxmath::math::Vector3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0));
HXDLIN(  65)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,a9,"a") =  ::hxmath::math::Vector3Default_obj::__new((((a8->m00 * v4->x) + (a8->m10 * v4->y)) + (a8->m20 * v4->z)),(((a8->m01 * v4->x) + (a8->m11 * v4->y)) + (a8->m21 * v4->z)),(((a8->m02 * v4->x) + (a8->m12 * v4->y)) + (a8->m22 * v4->z)));
HXDLIN(  65)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,b4,"b") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)1.0),((Float)0.0));
HXDLIN(  65)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self8,"self") =  ::hxmath::math::Vector3Default_obj::__new(a9->x,a9->y,a9->z);
HXDLIN(  65)		hx::SubEq(self8->x,b4->x);
HXDLIN(  65)		hx::SubEq(self8->y,b4->y);
HXDLIN(  65)		hx::SubEq(self8->z,b4->z);
HXDLIN(  65)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self9,"self") = self8;
HXDLIN(  65)		Float _hx_tmp8 = (((self9->x * self9->x) + (self9->y * self9->y)) + (self9->z * self9->z));
HXDLIN(  65)		Float _hx_tmp9 = ::Math_obj::sqrt(_hx_tmp8);
HXDLIN(  65)		this->assertApproxEquals(_hx_tmp9,((Float)0.0),null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),65,HX_("test.Test3D",3f,be,21,72),HX_("testAxialRotation",a9,db,2a,2f)));
HXLINE(  66)		HX_VARI_NAME( Float,angleRadians5,"angleRadians") = (((Float)::Math_obj::PI / (Float)(int)180) * ((Float)90.0));
HXDLIN(  66)		HX_VARI_NAME( Float,s5,"s") = ::Math_obj::sin(angleRadians5);
HXDLIN(  66)		HX_VARI_NAME( Float,c5,"c") = ::Math_obj::cos(angleRadians5);
HXDLIN(  66)		HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,a10,"a") =  ::hxmath::math::Matrix3x3Default_obj::__new(c5,-(s5),(int)0,s5,c5,(int)0,(int)0,(int)0,(int)1);
HXDLIN(  66)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,v5,"v") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)1.0),((Float)0.0));
HXDLIN(  66)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,a11,"a") =  ::hxmath::math::Vector3Default_obj::__new((((a10->m00 * v5->x) + (a10->m10 * v5->y)) + (a10->m20 * v5->z)),(((a10->m01 * v5->x) + (a10->m11 * v5->y)) + (a10->m21 * v5->z)),(((a10->m02 * v5->x) + (a10->m12 * v5->y)) + (a10->m22 * v5->z)));
HXDLIN(  66)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,b5,"b") =  ::hxmath::math::Vector3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0));
HXDLIN(  66)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self10,"self") =  ::hxmath::math::Vector3Default_obj::__new(a11->x,a11->y,a11->z);
HXDLIN(  66)		hx::AddEq(self10->x,b5->x);
HXDLIN(  66)		hx::AddEq(self10->y,b5->y);
HXDLIN(  66)		hx::AddEq(self10->z,b5->z);
HXDLIN(  66)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self11,"self") = self10;
HXDLIN(  66)		Float _hx_tmp10 = (((self11->x * self11->x) + (self11->y * self11->y)) + (self11->z * self11->z));
HXDLIN(  66)		Float _hx_tmp11 = ::Math_obj::sqrt(_hx_tmp10);
HXDLIN(  66)		this->assertApproxEquals(_hx_tmp11,((Float)0.0),null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),66,HX_("test.Test3D",3f,be,21,72),HX_("testAxialRotation",a9,db,2a,2f)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testAxialRotation,(void))

void Test3D_obj::testQuaternionToMatrix(){
            		HX_BEGIN_LOCAL_FUNC_S0(hx::LocalFunc,_hx_Closure_0) HXARGC(2)
            		 ::Dynamic _hx_run(Float unitAngle,Int axis){
            			HX_STACK_FRAME("test.Test3D","testQuaternionToMatrix",0x82519a9b,"test.Test3D.testQuaternionToMatrix","test/Test3D.hx",72,0x591b2dbe)
            			HX_STACK_ARG(unitAngle,"unitAngle")
            			HX_STACK_ARG(axis,"axis")
HXLINE(  73)			HX_VARI( ::Array< ::Dynamic>,axes) = ::Array_obj< ::Dynamic>::__new(3)->init(0, ::hxmath::math::Vector3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0)))->init(1, ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)1.0),((Float)0.0)))->init(2, ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0)));
HXLINE(  74)			HX_VARI_NAME( ::Array< ::Dynamic>,_hx_const,"const") = ::Array_obj< ::Dynamic>::__new(3)->init(0,::hxmath::math::_Matrix3x3::Matrix3x3_Impl__obj::rotationX_dyn())->init(1,::hxmath::math::_Matrix3x3::Matrix3x3_Impl__obj::rotationY_dyn())->init(2,::hxmath::math::_Matrix3x3::Matrix3x3_Impl__obj::rotationZ_dyn());
HXLINE(  75)			HX_VARI( Float,angle) = (unitAngle * ((Float)360.0));
HXLINE(  76)			HX_VARI_NAME(  ::hxmath::math::Vector3Default,axis1,"axis") = axes->__get(axis).StaticCast<  ::hxmath::math::Vector3Default >();
HXDLIN(  76)			HX_VARI( Float,angleRadians) = (((Float)::Math_obj::PI / (Float)(int)180) * angle);
HXDLIN(  76)			HX_VARI( Float,cosHalfAngle) = ::Math_obj::cos(((Float)angleRadians / (Float)((Float)2.0)));
HXDLIN(  76)			HX_VARI( Float,sinHalfAngle) = ::Math_obj::sin(((Float)angleRadians / (Float)((Float)2.0)));
HXDLIN(  76)			HX_VARI(  ::hxmath::math::QuaternionDefault,q) =  ::hxmath::math::QuaternionDefault_obj::__new(cosHalfAngle,(sinHalfAngle * axis1->x),(sinHalfAngle * axis1->y),(sinHalfAngle * axis1->z));
HXLINE(  77)			HX_VARI( Float,s) = q->s;
HXDLIN(  77)			HX_VARI( Float,x) = q->x;
HXDLIN(  77)			HX_VARI( Float,y) = q->y;
HXDLIN(  77)			HX_VARI( Float,z) = q->z;
HXDLIN(  77)			HX_VARI(  ::hxmath::math::Matrix3x3Default,m) =  ::hxmath::math::Matrix3x3Default_obj::__new(((int)1 - ((int)2 * ((y * y) + (z * z)))),((int)2 * ((x * y) - (s * z))),((int)2 * ((s * y) + (x * z))),((int)2 * ((x * y) + (s * z))),((int)1 - ((int)2 * ((x * x) + (z * z)))),((int)2 * ((y * z) - (s * x))),((int)2 * ((x * z) - (s * y))),((int)2 * ((y * z) + (s * x))),((int)1 - ((int)2 * ((x * x) + (y * y)))));
HXLINE(  78)			HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,m1,"m") = ( ( ::hxmath::math::Matrix3x3Default)(_hx_const->__get(axis)(angle)) );
HXLINE(  80)			return  ::Dynamic(hx::Anon_obj::Create(2)
            				->setFixed(0,HX_("m",6d,00,00,00),m1)
            				->setFixed(1,HX_("n",6e,00,00,00),m));
            		}
            		HX_END_LOCAL_FUNC2(return)

            	HX_STACK_FRAME("test.Test3D","testQuaternionToMatrix",0x82519a9b,"test.Test3D.testQuaternionToMatrix","test/Test3D.hx",70,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE(  71)		HX_VARI(  ::Dynamic,createMatrixPair) =  ::Dynamic(new _hx_Closure_0());
HXLINE(  83)		{
HXLINE(  83)			HX_VARI( Int,_g) = (int)0;
HXDLIN(  83)			while((_g < (int)3)){
HXLINE(  83)				HX_VARI_NAME( Int,axis2,"axis") = _g++;
HXLINE(  85)				HX_VARI_NAME( Float,unitAngle1,"unitAngle") = ((Float)0.0);
HXLINE(  87)				{
HXLINE(  87)					HX_VARI( Int,_g1) = (int)0;
HXDLIN(  87)					while((_g1 < (int)10)){
HXLINE(  87)						++_g1;
HXLINE(  89)						hx::AddEq(unitAngle1,((Float)0.01));
HXLINE(  90)						HX_VARI( Float,totalLength) = ((Float)0.0);
HXLINE(  92)						{
HXLINE(  92)							HX_VARI( Int,_g2) = (int)0;
HXDLIN(  92)							while((_g2 < (int)3)){
HXLINE(  92)								HX_VARI( Int,c) = _g2++;
HXLINE(  94)								HX_VARI(  ::Dynamic,pair) = createMatrixPair(unitAngle1,axis2);
HXLINE(  95)								HX_VARI(  ::hxmath::math::Matrix3x3Default,self) = ( ( ::hxmath::math::Matrix3x3Default)(pair->__Field(HX_("n",6e,00,00,00),hx::paccDynamic)) );
HXDLIN(  95)								 ::Dynamic _hx_tmp;
HXDLIN(  95)								switch((int)(c)){
            									case (int)0: {
HXLINE(  95)										_hx_tmp =  ::hxmath::math::Vector3Default_obj::__new(self->m00,self->m01,self->m02);
            									}
            									break;
            									case (int)1: {
HXLINE(  95)										_hx_tmp =  ::hxmath::math::Vector3Default_obj::__new(self->m10,self->m11,self->m12);
            									}
            									break;
            									case (int)2: {
HXLINE(  95)										_hx_tmp =  ::hxmath::math::Vector3Default_obj::__new(self->m20,self->m21,self->m22);
            									}
            									break;
            									default:{
HXLINE(  95)										HX_STACK_DO_THROW(HX_("Invalid column",ff,3c,03,94));
            									}
            								}
HXDLIN(  95)								HX_VARI(  ::hxmath::math::Vector3Default,a) = ( ( ::hxmath::math::Vector3Default)(_hx_tmp) );
HXDLIN(  95)								HX_VARI_NAME(  ::hxmath::math::Matrix3x3Default,self1,"self") = ( ( ::hxmath::math::Matrix3x3Default)(pair->__Field(HX_("m",6d,00,00,00),hx::paccDynamic)) );
HXDLIN(  95)								 ::Dynamic _hx_tmp1;
HXDLIN(  95)								switch((int)(c)){
            									case (int)0: {
HXLINE(  95)										_hx_tmp1 =  ::hxmath::math::Vector3Default_obj::__new(self1->m00,self1->m01,self1->m02);
            									}
            									break;
            									case (int)1: {
HXLINE(  95)										_hx_tmp1 =  ::hxmath::math::Vector3Default_obj::__new(self1->m10,self1->m11,self1->m12);
            									}
            									break;
            									case (int)2: {
HXLINE(  95)										_hx_tmp1 =  ::hxmath::math::Vector3Default_obj::__new(self1->m20,self1->m21,self1->m22);
            									}
            									break;
            									default:{
HXLINE(  95)										HX_STACK_DO_THROW(HX_("Invalid column",ff,3c,03,94));
            									}
            								}
HXDLIN(  95)								HX_VARI(  ::hxmath::math::Vector3Default,b) = ( ( ::hxmath::math::Vector3Default)(_hx_tmp1) );
HXDLIN(  95)								HX_VARI_NAME(  ::hxmath::math::Vector3Default,self2,"self") =  ::hxmath::math::Vector3Default_obj::__new(a->x,a->y,a->z);
HXDLIN(  95)								hx::SubEq(self2->x,b->x);
HXDLIN(  95)								hx::SubEq(self2->y,b->y);
HXDLIN(  95)								hx::SubEq(self2->z,b->z);
HXDLIN(  95)								HX_VARI_NAME(  ::hxmath::math::Vector3Default,self3,"self") = self2;
HXDLIN(  95)								Float _hx_tmp2 = (((self3->x * self3->x) + (self3->y * self3->y)) + (self3->z * self3->z));
HXDLIN(  95)								Float _hx_tmp3 = ::Math_obj::sqrt(_hx_tmp2);
HXDLIN(  95)								hx::AddEq(totalLength,_hx_tmp3);
            							}
            						}
HXLINE(  98)						this->assertApproxEquals(totalLength,((Float)0.0),null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),98,HX_("test.Test3D",3f,be,21,72),HX_("testQuaternionToMatrix",4c,5e,e0,35)));
            					}
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testQuaternionToMatrix,(void))

void Test3D_obj::testMatrixFrameInverse(){
            	HX_STACK_FRAME("test.Test3D","testMatrixFrameInverse",0x13df1025,"test.Test3D.testMatrixFrameInverse","test/Test3D.hx",105,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 105)		HX_VARI( Int,_g) = (int)0;
HXDLIN( 105)		while((_g < (int)10)){
HXLINE( 105)			++_g;
HXLINE( 108)			HX_VARI( ::Dynamic,frame) = this->randomFrame3(null());
HXLINE( 111)			HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,this1,"this") = ( ( ::hxmath::math::QuaternionDefault)( ::Dynamic(frame->__Field(HX_("get_orientation",67,a6,e0,be),hx::paccDynamic))()) );
HXDLIN( 111)			HX_VARI(  ::hxmath::math::QuaternionDefault,self) = this1;
HXDLIN( 111)			HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self1,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(self->s,self->x,self->y,self->z);
HXDLIN( 111)			self1->x = -(self1->x);
HXDLIN( 111)			self1->y = -(self1->y);
HXDLIN( 111)			self1->z = -(self1->z);
HXDLIN( 111)			HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self2,"self") = self1;
HXDLIN( 111)			Float _hx_tmp = ((((self2->s * self2->s) + (self2->x * self2->x)) + (self2->y * self2->y)) + (self2->z * self2->z));
HXDLIN( 111)			HX_VARI( Float,length) = ::Math_obj::sqrt(_hx_tmp);
HXDLIN( 111)			if ((length > ((Float)0.0))) {
HXLINE( 111)				HX_VARI( Float,k) = ((Float)((Float)1.0) / (Float)length);
HXDLIN( 111)				{
HXLINE( 111)					hx::MultEq(self2->s,k);
HXDLIN( 111)					hx::MultEq(self2->x,k);
HXDLIN( 111)					hx::MultEq(self2->y,k);
HXDLIN( 111)					hx::MultEq(self2->z,k);
            				}
            			}
HXDLIN( 111)			HX_VARI(  ::hxmath::math::Vector3Default,u) = ( ( ::hxmath::math::Vector3Default)( ::Dynamic(frame->__Field(HX_("get_offset",5c,07,c7,50),hx::paccDynamic))()) );
HXDLIN( 111)			HX_VARI( Float,a) = (((Float)2.0) * (((self2->x * u->x) + (self2->y * u->y)) + (self2->z * u->z)));
HXDLIN( 111)			HX_VARI( Float,b) = ((((self2->s * self2->s) - (self2->x * self2->x)) - (self2->y * self2->y)) - (self2->z * self2->z));
HXDLIN( 111)			HX_VARI( Float,c) = (((Float)2.0) * self2->s);
HXDLIN( 111)			HX_VARI_NAME(  ::hxmath::math::Vector3Default,self3,"self") =  ::hxmath::math::Vector3Default_obj::__new((((a * self2->x) + (b * u->x)) + (c * ((self2->y * u->z) - (self2->z * u->y)))),(((a * self2->y) + (b * u->y)) + (c * ((self2->z * u->x) - (self2->x * u->z)))),(((a * self2->z) + (b * u->z)) + (c * ((self2->x * u->y) - (self2->y * u->x)))));
HXDLIN( 111)			self3->x = -(self3->x);
HXDLIN( 111)			self3->y = -(self3->y);
HXDLIN( 111)			self3->z = -(self3->z);
HXDLIN( 111)			HX_VARI( ::Dynamic,invFrame) = ::hxmath::frames::_Frame3::Frame3_Impl__obj::_new(self3,self2);
HXLINE( 113)			::hxmath::frames::IFrame3_obj::get_matrix(frame);
HXLINE( 116)			HX_VARI(  ::hxmath::math::Matrix4x4Default,invFrameMatrix) = ::hxmath::frames::IFrame3_obj::get_matrix(invFrame);
HXLINE( 117)			HX_VARI_NAME(  ::hxmath::math::Matrix4x4Default,this2,"this") = ::hxmath::frames::IFrame3_obj::get_matrix(frame);
HXDLIN( 117)			HX_VARI_NAME(  ::hxmath::math::Matrix4x4Default,self4,"self") = this2;
HXDLIN( 117)			{
HXLINE( 117)				HX_VARI( Float,temp) = self4->m01;
HXDLIN( 117)				self4->m01 = self4->m10;
HXDLIN( 117)				self4->m10 = temp;
HXDLIN( 117)				temp = self4->m02;
HXDLIN( 117)				self4->m02 = self4->m20;
HXDLIN( 117)				self4->m20 = temp;
HXDLIN( 117)				temp = self4->m12;
HXDLIN( 117)				self4->m12 = self4->m21;
HXDLIN( 117)				self4->m21 = temp;
            			}
HXDLIN( 117)			HX_VARI( Float,tx) = -((((self4->m00 * self4->m30) + (self4->m10 * self4->m31)) + (self4->m20 * self4->m32)));
HXDLIN( 117)			HX_VARI( Float,ty) = -((((self4->m01 * self4->m30) + (self4->m11 * self4->m31)) + (self4->m21 * self4->m32)));
HXDLIN( 117)			HX_VARI( Float,tz) = -((((self4->m02 * self4->m30) + (self4->m12 * self4->m31)) + (self4->m22 * self4->m32)));
HXDLIN( 117)			self4->m30 = tx;
HXDLIN( 117)			self4->m31 = ty;
HXDLIN( 117)			self4->m32 = tz;
HXLINE( 120)			HX_VARI(  ::hxmath::math::Vector4Default,homogenous0) =  ::hxmath::math::Vector4Default_obj::__new(((Float)0.0),((Float)0.0),((Float)0.0),((Float)1.0));
HXLINE( 121)			HX_VARI(  ::hxmath::math::Vector4Default,homogenousX) =  ::hxmath::math::Vector4Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0),((Float)1.0));
HXLINE( 122)			HX_VARI(  ::hxmath::math::Vector4Default,homogenousY) =  ::hxmath::math::Vector4Default_obj::__new(((Float)0.0),((Float)1.0),((Float)0.0),((Float)1.0));
HXLINE( 123)			HX_VARI(  ::hxmath::math::Vector4Default,homogenousZ) =  ::hxmath::math::Vector4Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0),((Float)1.0));
HXLINE( 126)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,a1,"a") =  ::hxmath::math::Vector4Default_obj::__new(((((invFrameMatrix->m00 * homogenous0->x) + (invFrameMatrix->m10 * homogenous0->y)) + (invFrameMatrix->m20 * homogenous0->z)) + (invFrameMatrix->m30 * homogenous0->w)),((((invFrameMatrix->m01 * homogenous0->x) + (invFrameMatrix->m11 * homogenous0->y)) + (invFrameMatrix->m21 * homogenous0->z)) + (invFrameMatrix->m31 * homogenous0->w)),((((invFrameMatrix->m02 * homogenous0->x) + (invFrameMatrix->m12 * homogenous0->y)) + (invFrameMatrix->m22 * homogenous0->z)) + (invFrameMatrix->m32 * homogenous0->w)),((((invFrameMatrix->m03 * homogenous0->x) + (invFrameMatrix->m13 * homogenous0->y)) + (invFrameMatrix->m23 * homogenous0->z)) + (invFrameMatrix->m33 * homogenous0->w)));
HXDLIN( 126)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,b1,"b") =  ::hxmath::math::Vector4Default_obj::__new(((((self4->m00 * homogenous0->x) + (self4->m10 * homogenous0->y)) + (self4->m20 * homogenous0->z)) + (self4->m30 * homogenous0->w)),((((self4->m01 * homogenous0->x) + (self4->m11 * homogenous0->y)) + (self4->m21 * homogenous0->z)) + (self4->m31 * homogenous0->w)),((((self4->m02 * homogenous0->x) + (self4->m12 * homogenous0->y)) + (self4->m22 * homogenous0->z)) + (self4->m32 * homogenous0->w)),((((self4->m03 * homogenous0->x) + (self4->m13 * homogenous0->y)) + (self4->m23 * homogenous0->z)) + (self4->m33 * homogenous0->w)));
HXDLIN( 126)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,self5,"self") =  ::hxmath::math::Vector4Default_obj::__new(a1->x,a1->y,a1->z,a1->w);
HXDLIN( 126)			hx::SubEq(self5->x,b1->x);
HXDLIN( 126)			hx::SubEq(self5->y,b1->y);
HXDLIN( 126)			hx::SubEq(self5->z,b1->z);
HXDLIN( 126)			hx::SubEq(self5->w,b1->w);
HXDLIN( 126)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,self6,"self") = self5;
HXDLIN( 126)			Float _hx_tmp1 = ((((self6->x * self6->x) + (self6->y * self6->y)) + (self6->z * self6->z)) + (self6->w * self6->w));
HXDLIN( 126)			this->assertApproxEquals(((Float)0.0),_hx_tmp1,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),126,HX_("test.Test3D",3f,be,21,72),HX_("testMatrixFrameInverse",d6,d3,6d,c7)));
HXLINE( 127)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,a2,"a") =  ::hxmath::math::Vector4Default_obj::__new(((((invFrameMatrix->m00 * homogenousX->x) + (invFrameMatrix->m10 * homogenousX->y)) + (invFrameMatrix->m20 * homogenousX->z)) + (invFrameMatrix->m30 * homogenousX->w)),((((invFrameMatrix->m01 * homogenousX->x) + (invFrameMatrix->m11 * homogenousX->y)) + (invFrameMatrix->m21 * homogenousX->z)) + (invFrameMatrix->m31 * homogenousX->w)),((((invFrameMatrix->m02 * homogenousX->x) + (invFrameMatrix->m12 * homogenousX->y)) + (invFrameMatrix->m22 * homogenousX->z)) + (invFrameMatrix->m32 * homogenousX->w)),((((invFrameMatrix->m03 * homogenousX->x) + (invFrameMatrix->m13 * homogenousX->y)) + (invFrameMatrix->m23 * homogenousX->z)) + (invFrameMatrix->m33 * homogenousX->w)));
HXDLIN( 127)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,b2,"b") =  ::hxmath::math::Vector4Default_obj::__new(((((self4->m00 * homogenousX->x) + (self4->m10 * homogenousX->y)) + (self4->m20 * homogenousX->z)) + (self4->m30 * homogenousX->w)),((((self4->m01 * homogenousX->x) + (self4->m11 * homogenousX->y)) + (self4->m21 * homogenousX->z)) + (self4->m31 * homogenousX->w)),((((self4->m02 * homogenousX->x) + (self4->m12 * homogenousX->y)) + (self4->m22 * homogenousX->z)) + (self4->m32 * homogenousX->w)),((((self4->m03 * homogenousX->x) + (self4->m13 * homogenousX->y)) + (self4->m23 * homogenousX->z)) + (self4->m33 * homogenousX->w)));
HXDLIN( 127)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,self7,"self") =  ::hxmath::math::Vector4Default_obj::__new(a2->x,a2->y,a2->z,a2->w);
HXDLIN( 127)			hx::SubEq(self7->x,b2->x);
HXDLIN( 127)			hx::SubEq(self7->y,b2->y);
HXDLIN( 127)			hx::SubEq(self7->z,b2->z);
HXDLIN( 127)			hx::SubEq(self7->w,b2->w);
HXDLIN( 127)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,self8,"self") = self7;
HXDLIN( 127)			Float _hx_tmp2 = ((((self8->x * self8->x) + (self8->y * self8->y)) + (self8->z * self8->z)) + (self8->w * self8->w));
HXDLIN( 127)			this->assertApproxEquals(((Float)0.0),_hx_tmp2,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),127,HX_("test.Test3D",3f,be,21,72),HX_("testMatrixFrameInverse",d6,d3,6d,c7)));
HXLINE( 128)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,a3,"a") =  ::hxmath::math::Vector4Default_obj::__new(((((invFrameMatrix->m00 * homogenousY->x) + (invFrameMatrix->m10 * homogenousY->y)) + (invFrameMatrix->m20 * homogenousY->z)) + (invFrameMatrix->m30 * homogenousY->w)),((((invFrameMatrix->m01 * homogenousY->x) + (invFrameMatrix->m11 * homogenousY->y)) + (invFrameMatrix->m21 * homogenousY->z)) + (invFrameMatrix->m31 * homogenousY->w)),((((invFrameMatrix->m02 * homogenousY->x) + (invFrameMatrix->m12 * homogenousY->y)) + (invFrameMatrix->m22 * homogenousY->z)) + (invFrameMatrix->m32 * homogenousY->w)),((((invFrameMatrix->m03 * homogenousY->x) + (invFrameMatrix->m13 * homogenousY->y)) + (invFrameMatrix->m23 * homogenousY->z)) + (invFrameMatrix->m33 * homogenousY->w)));
HXDLIN( 128)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,b3,"b") =  ::hxmath::math::Vector4Default_obj::__new(((((self4->m00 * homogenousY->x) + (self4->m10 * homogenousY->y)) + (self4->m20 * homogenousY->z)) + (self4->m30 * homogenousY->w)),((((self4->m01 * homogenousY->x) + (self4->m11 * homogenousY->y)) + (self4->m21 * homogenousY->z)) + (self4->m31 * homogenousY->w)),((((self4->m02 * homogenousY->x) + (self4->m12 * homogenousY->y)) + (self4->m22 * homogenousY->z)) + (self4->m32 * homogenousY->w)),((((self4->m03 * homogenousY->x) + (self4->m13 * homogenousY->y)) + (self4->m23 * homogenousY->z)) + (self4->m33 * homogenousY->w)));
HXDLIN( 128)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,self9,"self") =  ::hxmath::math::Vector4Default_obj::__new(a3->x,a3->y,a3->z,a3->w);
HXDLIN( 128)			hx::SubEq(self9->x,b3->x);
HXDLIN( 128)			hx::SubEq(self9->y,b3->y);
HXDLIN( 128)			hx::SubEq(self9->z,b3->z);
HXDLIN( 128)			hx::SubEq(self9->w,b3->w);
HXDLIN( 128)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,self10,"self") = self9;
HXDLIN( 128)			Float _hx_tmp3 = ((((self10->x * self10->x) + (self10->y * self10->y)) + (self10->z * self10->z)) + (self10->w * self10->w));
HXDLIN( 128)			this->assertApproxEquals(((Float)0.0),_hx_tmp3,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),128,HX_("test.Test3D",3f,be,21,72),HX_("testMatrixFrameInverse",d6,d3,6d,c7)));
HXLINE( 129)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,a4,"a") =  ::hxmath::math::Vector4Default_obj::__new(((((invFrameMatrix->m00 * homogenousZ->x) + (invFrameMatrix->m10 * homogenousZ->y)) + (invFrameMatrix->m20 * homogenousZ->z)) + (invFrameMatrix->m30 * homogenousZ->w)),((((invFrameMatrix->m01 * homogenousZ->x) + (invFrameMatrix->m11 * homogenousZ->y)) + (invFrameMatrix->m21 * homogenousZ->z)) + (invFrameMatrix->m31 * homogenousZ->w)),((((invFrameMatrix->m02 * homogenousZ->x) + (invFrameMatrix->m12 * homogenousZ->y)) + (invFrameMatrix->m22 * homogenousZ->z)) + (invFrameMatrix->m32 * homogenousZ->w)),((((invFrameMatrix->m03 * homogenousZ->x) + (invFrameMatrix->m13 * homogenousZ->y)) + (invFrameMatrix->m23 * homogenousZ->z)) + (invFrameMatrix->m33 * homogenousZ->w)));
HXDLIN( 129)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,b4,"b") =  ::hxmath::math::Vector4Default_obj::__new(((((self4->m00 * homogenousZ->x) + (self4->m10 * homogenousZ->y)) + (self4->m20 * homogenousZ->z)) + (self4->m30 * homogenousZ->w)),((((self4->m01 * homogenousZ->x) + (self4->m11 * homogenousZ->y)) + (self4->m21 * homogenousZ->z)) + (self4->m31 * homogenousZ->w)),((((self4->m02 * homogenousZ->x) + (self4->m12 * homogenousZ->y)) + (self4->m22 * homogenousZ->z)) + (self4->m32 * homogenousZ->w)),((((self4->m03 * homogenousZ->x) + (self4->m13 * homogenousZ->y)) + (self4->m23 * homogenousZ->z)) + (self4->m33 * homogenousZ->w)));
HXDLIN( 129)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,self11,"self") =  ::hxmath::math::Vector4Default_obj::__new(a4->x,a4->y,a4->z,a4->w);
HXDLIN( 129)			hx::SubEq(self11->x,b4->x);
HXDLIN( 129)			hx::SubEq(self11->y,b4->y);
HXDLIN( 129)			hx::SubEq(self11->z,b4->z);
HXDLIN( 129)			hx::SubEq(self11->w,b4->w);
HXDLIN( 129)			HX_VARI_NAME(  ::hxmath::math::Vector4Default,self12,"self") = self11;
HXDLIN( 129)			Float _hx_tmp4 = ((((self12->x * self12->x) + (self12->y * self12->y)) + (self12->z * self12->z)) + (self12->w * self12->w));
HXDLIN( 129)			this->assertApproxEquals(((Float)0.0),_hx_tmp4,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),129,HX_("test.Test3D",3f,be,21,72),HX_("testMatrixFrameInverse",d6,d3,6d,c7)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testMatrixFrameInverse,(void))

void Test3D_obj::testQuaternionInverse(){
            	HX_STACK_FRAME("test.Test3D","testQuaternionInverse",0x19ebe411,"test.Test3D.testQuaternionInverse","test/Test3D.hx",135,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 135)		HX_VARI( Int,_g) = (int)0;
HXDLIN( 135)		while((_g < (int)10)){
HXLINE( 135)			++_g;
HXLINE( 137)			HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,this1,"this") = this->randomQuaternion(null());
HXDLIN( 137)			HX_VARI(  ::hxmath::math::QuaternionDefault,self) = this1;
HXDLIN( 137)			Float _hx_tmp = ((((self->s * self->s) + (self->x * self->x)) + (self->y * self->y)) + (self->z * self->z));
HXDLIN( 137)			Float _hx_tmp1 = ::Math_obj::sqrt(_hx_tmp);
HXDLIN( 137)			HX_VARI_NAME( Float,_g1,"_g") = ((Float)((Float)1.0) / (Float)_hx_tmp1);
HXDLIN( 137)			HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self1,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(self->s,self->x,self->y,self->z);
HXDLIN( 137)			hx::MultEq(self1->s,_g1);
HXDLIN( 137)			hx::MultEq(self1->x,_g1);
HXDLIN( 137)			hx::MultEq(self1->y,_g1);
HXDLIN( 137)			hx::MultEq(self1->z,_g1);
HXLINE( 138)			HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self2,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(self1->s,self1->x,self1->y,self1->z);
HXDLIN( 138)			self2->x = -(self2->x);
HXDLIN( 138)			self2->y = -(self2->y);
HXDLIN( 138)			self2->z = -(self2->z);
HXLINE( 140)			HX_VARI(  ::hxmath::math::QuaternionDefault,p) =  ::hxmath::math::QuaternionDefault_obj::__new(((((self1->s * self2->s) - (self1->x * self2->x)) - (self1->y * self2->y)) - (self1->z * self2->z)),((((self1->s * self2->x) + (self2->s * self1->x)) + (self1->y * self2->z)) - (self1->z * self2->y)),((((self1->s * self2->y) + (self2->s * self1->y)) + (self1->z * self2->x)) - (self1->x * self2->z)),((((self1->s * self2->z) + (self2->s * self1->z)) + (self1->x * self2->y)) - (self1->y * self2->x)));
HXLINE( 142)			this->assertApproxEquals(((Float)1.0),p->s,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),142,HX_("test.Test3D",3f,be,21,72),HX_("testQuaternionInverse",80,e1,7a,c3)));
HXLINE( 143)			HX_VARI_NAME(  ::hxmath::math::Vector3Default,self3,"self") =  ::hxmath::math::Vector3Default_obj::__new(p->x,p->y,p->z);
HXDLIN( 143)			Float _hx_tmp2 = (((self3->x * self3->x) + (self3->y * self3->y)) + (self3->z * self3->z));
HXDLIN( 143)			Float _hx_tmp3 = ::Math_obj::sqrt(_hx_tmp2);
HXDLIN( 143)			this->assertApproxEquals(((Float)0.0),_hx_tmp3,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),143,HX_("test.Test3D",3f,be,21,72),HX_("testQuaternionInverse",80,e1,7a,c3)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testQuaternionInverse,(void))

void Test3D_obj::testOrthoNormalize(){
            	HX_STACK_FRAME("test.Test3D","testOrthoNormalize",0xc5f809f6,"test.Test3D.testOrthoNormalize","test/Test3D.hx",149,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 149)		HX_VARI( Int,_g) = (int)0;
HXDLIN( 149)		while((_g < (int)10)){
HXLINE( 149)			++_g;
HXLINE( 151)			HX_VARI(  ::hxmath::math::Vector3Default,u) = this->randomVector3(null());
HXLINE( 152)			HX_VARI(  ::hxmath::math::Vector3Default,v) = this->randomVector3(null());
HXLINE( 153)			HX_VARI(  ::hxmath::math::Vector3Default,w) = this->randomVector3(null());
HXLINE( 155)			{
HXLINE( 155)				{
HXLINE( 155)					Float _hx_tmp = (((u->x * u->x) + (u->y * u->y)) + (u->z * u->z));
HXDLIN( 155)					HX_VARI( Float,length) = ::Math_obj::sqrt(_hx_tmp);
HXDLIN( 155)					if ((length > ((Float)0.0))) {
HXLINE( 155)						hx::DivEq(u->x,length);
HXDLIN( 155)						hx::DivEq(u->y,length);
HXDLIN( 155)						hx::DivEq(u->z,length);
            					}
            				}
HXDLIN( 155)				{
HXLINE( 155)					HX_VARI(  ::hxmath::math::Vector3Default,self) =  ::hxmath::math::Vector3Default_obj::__new(v->x,v->y,v->z);
HXDLIN( 155)					HX_VARI( Float,s) = ((Float)(((self->x * u->x) + (self->y * u->y)) + (self->z * u->z)) / (Float)(((u->x * u->x) + (u->y * u->y)) + (u->z * u->z)));
HXDLIN( 155)					{
HXLINE( 155)						HX_VARI_NAME( Int,_g1,"_g") = (int)0;
HXDLIN( 155)						while((_g1 < (int)3)){
HXLINE( 155)							HX_VARI( Int,i) = _g1++;
HXDLIN( 155)							{
HXLINE( 155)								 ::Dynamic _hx_tmp1;
HXDLIN( 155)								switch((int)(i)){
            									case (int)0: {
HXLINE( 155)										_hx_tmp1 = u->x;
            									}
            									break;
            									case (int)1: {
HXLINE( 155)										_hx_tmp1 = u->y;
            									}
            									break;
            									case (int)2: {
HXLINE( 155)										_hx_tmp1 = u->z;
            									}
            									break;
            									default:{
HXLINE( 155)										HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            									}
            								}
HXDLIN( 155)								HX_VARI( Float,value) = ( (Float)(_hx_tmp1) );
HXDLIN( 155)								switch((int)(i)){
            									case (int)0: {
HXLINE( 155)										self->x = value;
            									}
            									break;
            									case (int)1: {
HXLINE( 155)										self->y = value;
            									}
            									break;
            									case (int)2: {
HXLINE( 155)										self->z = value;
            									}
            									break;
            									default:{
HXLINE( 155)										HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            									}
            								}
            							}
            						}
            					}
HXDLIN( 155)					{
HXLINE( 155)						hx::MultEq(self->x,s);
HXDLIN( 155)						hx::MultEq(self->y,s);
HXDLIN( 155)						hx::MultEq(self->z,s);
            					}
HXDLIN( 155)					hx::SubEq(v->x,self->x);
HXDLIN( 155)					hx::SubEq(v->y,self->y);
HXDLIN( 155)					hx::SubEq(v->z,self->z);
            				}
HXDLIN( 155)				{
HXLINE( 155)					Float _hx_tmp2 = (((v->x * v->x) + (v->y * v->y)) + (v->z * v->z));
HXDLIN( 155)					HX_VARI_NAME( Float,length1,"length") = ::Math_obj::sqrt(_hx_tmp2);
HXDLIN( 155)					if ((length1 > ((Float)0.0))) {
HXLINE( 155)						hx::DivEq(v->x,length1);
HXDLIN( 155)						hx::DivEq(v->y,length1);
HXDLIN( 155)						hx::DivEq(v->z,length1);
            					}
            				}
HXDLIN( 155)				{
HXLINE( 155)					HX_VARI_NAME(  ::hxmath::math::Vector3Default,self1,"self") =  ::hxmath::math::Vector3Default_obj::__new(w->x,w->y,w->z);
HXDLIN( 155)					HX_VARI_NAME( Float,s1,"s") = ((Float)(((self1->x * u->x) + (self1->y * u->y)) + (self1->z * u->z)) / (Float)(((u->x * u->x) + (u->y * u->y)) + (u->z * u->z)));
HXDLIN( 155)					{
HXLINE( 155)						HX_VARI_NAME( Int,_g2,"_g") = (int)0;
HXDLIN( 155)						while((_g2 < (int)3)){
HXLINE( 155)							HX_VARI_NAME( Int,i1,"i") = _g2++;
HXDLIN( 155)							{
HXLINE( 155)								 ::Dynamic _hx_tmp3;
HXDLIN( 155)								switch((int)(i1)){
            									case (int)0: {
HXLINE( 155)										_hx_tmp3 = u->x;
            									}
            									break;
            									case (int)1: {
HXLINE( 155)										_hx_tmp3 = u->y;
            									}
            									break;
            									case (int)2: {
HXLINE( 155)										_hx_tmp3 = u->z;
            									}
            									break;
            									default:{
HXLINE( 155)										HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            									}
            								}
HXDLIN( 155)								HX_VARI_NAME( Float,value1,"value") = ( (Float)(_hx_tmp3) );
HXDLIN( 155)								switch((int)(i1)){
            									case (int)0: {
HXLINE( 155)										self1->x = value1;
            									}
            									break;
            									case (int)1: {
HXLINE( 155)										self1->y = value1;
            									}
            									break;
            									case (int)2: {
HXLINE( 155)										self1->z = value1;
            									}
            									break;
            									default:{
HXLINE( 155)										HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            									}
            								}
            							}
            						}
            					}
HXDLIN( 155)					{
HXLINE( 155)						hx::MultEq(self1->x,s1);
HXDLIN( 155)						hx::MultEq(self1->y,s1);
HXDLIN( 155)						hx::MultEq(self1->z,s1);
            					}
HXDLIN( 155)					hx::SubEq(w->x,self1->x);
HXDLIN( 155)					hx::SubEq(w->y,self1->y);
HXDLIN( 155)					hx::SubEq(w->z,self1->z);
            				}
HXDLIN( 155)				{
HXLINE( 155)					HX_VARI_NAME(  ::hxmath::math::Vector3Default,self2,"self") =  ::hxmath::math::Vector3Default_obj::__new(w->x,w->y,w->z);
HXDLIN( 155)					HX_VARI_NAME( Float,s2,"s") = ((Float)(((self2->x * v->x) + (self2->y * v->y)) + (self2->z * v->z)) / (Float)(((v->x * v->x) + (v->y * v->y)) + (v->z * v->z)));
HXDLIN( 155)					{
HXLINE( 155)						HX_VARI_NAME( Int,_g3,"_g") = (int)0;
HXDLIN( 155)						while((_g3 < (int)3)){
HXLINE( 155)							HX_VARI_NAME( Int,i2,"i") = _g3++;
HXDLIN( 155)							{
HXLINE( 155)								 ::Dynamic _hx_tmp4;
HXDLIN( 155)								switch((int)(i2)){
            									case (int)0: {
HXLINE( 155)										_hx_tmp4 = v->x;
            									}
            									break;
            									case (int)1: {
HXLINE( 155)										_hx_tmp4 = v->y;
            									}
            									break;
            									case (int)2: {
HXLINE( 155)										_hx_tmp4 = v->z;
            									}
            									break;
            									default:{
HXLINE( 155)										HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            									}
            								}
HXDLIN( 155)								HX_VARI_NAME( Float,value2,"value") = ( (Float)(_hx_tmp4) );
HXDLIN( 155)								switch((int)(i2)){
            									case (int)0: {
HXLINE( 155)										self2->x = value2;
            									}
            									break;
            									case (int)1: {
HXLINE( 155)										self2->y = value2;
            									}
            									break;
            									case (int)2: {
HXLINE( 155)										self2->z = value2;
            									}
            									break;
            									default:{
HXLINE( 155)										HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            									}
            								}
            							}
            						}
            					}
HXDLIN( 155)					{
HXLINE( 155)						hx::MultEq(self2->x,s2);
HXDLIN( 155)						hx::MultEq(self2->y,s2);
HXDLIN( 155)						hx::MultEq(self2->z,s2);
            					}
HXDLIN( 155)					hx::SubEq(w->x,self2->x);
HXDLIN( 155)					hx::SubEq(w->y,self2->y);
HXDLIN( 155)					hx::SubEq(w->z,self2->z);
            				}
HXDLIN( 155)				{
HXLINE( 155)					Float _hx_tmp5 = (((w->x * w->x) + (w->y * w->y)) + (w->z * w->z));
HXDLIN( 155)					HX_VARI_NAME( Float,length2,"length") = ::Math_obj::sqrt(_hx_tmp5);
HXDLIN( 155)					if ((length2 > ((Float)0.0))) {
HXLINE( 155)						hx::DivEq(w->x,length2);
HXDLIN( 155)						hx::DivEq(w->y,length2);
HXDLIN( 155)						hx::DivEq(w->z,length2);
            					}
            				}
            			}
HXLINE( 157)			Float _hx_tmp6 = (((u->x * u->x) + (u->y * u->y)) + (u->z * u->z));
HXDLIN( 157)			Float _hx_tmp7 = ::Math_obj::sqrt(_hx_tmp6);
HXDLIN( 157)			this->assertApproxEquals(((Float)1.0),_hx_tmp7,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),157,HX_("test.Test3D",3f,be,21,72),HX_("testOrthoNormalize",27,e1,2c,f2)));
HXLINE( 158)			Float _hx_tmp8 = (((v->x * v->x) + (v->y * v->y)) + (v->z * v->z));
HXDLIN( 158)			Float _hx_tmp9 = ::Math_obj::sqrt(_hx_tmp8);
HXDLIN( 158)			this->assertApproxEquals(((Float)1.0),_hx_tmp9,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),158,HX_("test.Test3D",3f,be,21,72),HX_("testOrthoNormalize",27,e1,2c,f2)));
HXLINE( 159)			Float _hx_tmp10 = (((w->x * w->x) + (w->y * w->y)) + (w->z * w->z));
HXDLIN( 159)			Float _hx_tmp11 = ::Math_obj::sqrt(_hx_tmp10);
HXDLIN( 159)			this->assertApproxEquals(((Float)1.0),_hx_tmp11,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),159,HX_("test.Test3D",3f,be,21,72),HX_("testOrthoNormalize",27,e1,2c,f2)));
HXLINE( 160)			Float _hx_tmp12 = (((u->x * v->x) + (u->y * v->y)) + (u->z * v->z));
HXDLIN( 160)			this->assertApproxEquals(((Float)0.0),_hx_tmp12,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),160,HX_("test.Test3D",3f,be,21,72),HX_("testOrthoNormalize",27,e1,2c,f2)));
HXLINE( 161)			Float _hx_tmp13 = (((u->x * w->x) + (u->y * w->y)) + (u->z * w->z));
HXDLIN( 161)			this->assertApproxEquals(((Float)0.0),_hx_tmp13,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),161,HX_("test.Test3D",3f,be,21,72),HX_("testOrthoNormalize",27,e1,2c,f2)));
HXLINE( 162)			Float _hx_tmp14 = (((v->x * w->x) + (v->y * w->y)) + (v->z * w->z));
HXDLIN( 162)			this->assertApproxEquals(((Float)0.0),_hx_tmp14,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),162,HX_("test.Test3D",3f,be,21,72),HX_("testOrthoNormalize",27,e1,2c,f2)));
HXLINE( 164)			HX_VARI_NAME(  ::hxmath::math::Vector3Default,self3,"self") =  ::hxmath::math::Vector3Default_obj::__new(u->x,u->y,u->z);
HXDLIN( 164)			HX_VARI( Float,newX) = ((self3->y * v->z) - (self3->z * v->y));
HXDLIN( 164)			HX_VARI( Float,newY) = ((self3->z * v->x) - (self3->x * v->z));
HXDLIN( 164)			HX_VARI( Float,newZ) = ((self3->x * v->y) - (self3->y * v->x));
HXDLIN( 164)			self3->x = newX;
HXDLIN( 164)			self3->y = newY;
HXDLIN( 164)			self3->z = newZ;
HXDLIN( 164)			HX_VARI_NAME(  ::hxmath::math::Vector3Default,self4,"self") =  ::hxmath::math::Vector3Default_obj::__new(self3->x,self3->y,self3->z);
HXDLIN( 164)			HX_VARI_NAME( Float,newX1,"newX") = ((self4->y * w->z) - (self4->z * w->y));
HXDLIN( 164)			HX_VARI_NAME( Float,newY1,"newY") = ((self4->z * w->x) - (self4->x * w->z));
HXDLIN( 164)			HX_VARI_NAME( Float,newZ1,"newZ") = ((self4->x * w->y) - (self4->y * w->x));
HXDLIN( 164)			self4->x = newX1;
HXDLIN( 164)			self4->y = newY1;
HXDLIN( 164)			self4->z = newZ1;
HXDLIN( 164)			HX_VARI_NAME(  ::hxmath::math::Vector3Default,self5,"self") = self4;
HXDLIN( 164)			Float _hx_tmp15 = (((self5->x * self5->x) + (self5->y * self5->y)) + (self5->z * self5->z));
HXDLIN( 164)			Float _hx_tmp16 = ::Math_obj::sqrt(_hx_tmp15);
HXDLIN( 164)			this->assertApproxEquals(((Float)0.0),_hx_tmp16,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),164,HX_("test.Test3D",3f,be,21,72),HX_("testOrthoNormalize",27,e1,2c,f2)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testOrthoNormalize,(void))

void Test3D_obj::testAngles(){
            	HX_STACK_FRAME("test.Test3D","testAngles",0xd4fb9d01,"test.Test3D.testAngles","test/Test3D.hx",169,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 170)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,this1,"this") =  ::hxmath::math::Vector3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0));
HXDLIN( 170)		HX_VARI(  ::hxmath::math::Vector3Default,b) =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)1.0),((Float)0.0));
HXDLIN( 170)		HX_VARI(  ::hxmath::math::Vector3Default,self) = this1;
HXDLIN( 170)		Float _hx_tmp = (((self->x * b->x) + (self->y * b->y)) + (self->z * b->z));
HXDLIN( 170)		Float _hx_tmp1 = (((self->x * self->x) + (self->y * self->y)) + (self->z * self->z));
HXDLIN( 170)		Float _hx_tmp2 = ::Math_obj::sqrt(_hx_tmp1);
HXDLIN( 170)		Float _hx_tmp3 = (((b->x * b->x) + (b->y * b->y)) + (b->z * b->z));
HXDLIN( 170)		Float _hx_tmp4 = ::Math_obj::sqrt(_hx_tmp3);
HXDLIN( 170)		Float _hx_tmp5 = ::Math_obj::acos(((Float)_hx_tmp / (Float)(_hx_tmp2 * _hx_tmp4)));
HXDLIN( 170)		Float _hx_tmp6 = ((Float)::Math_obj::PI / (Float)((Float)2.0));
HXDLIN( 170)		this->assertApproxEquals(_hx_tmp5,_hx_tmp6,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),170,HX_("test.Test3D",3f,be,21,72),HX_("testAngles",32,5b,0d,7c)));
HXLINE( 171)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,this2,"this") =  ::hxmath::math::Vector3Default_obj::__new(((Float)1.0),((Float)0.0),((Float)0.0));
HXDLIN( 171)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,b1,"b") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN( 171)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self1,"self") = this2;
HXDLIN( 171)		Float _hx_tmp7 = (((self1->x * b1->x) + (self1->y * b1->y)) + (self1->z * b1->z));
HXDLIN( 171)		Float _hx_tmp8 = (((self1->x * self1->x) + (self1->y * self1->y)) + (self1->z * self1->z));
HXDLIN( 171)		Float _hx_tmp9 = ::Math_obj::sqrt(_hx_tmp8);
HXDLIN( 171)		Float _hx_tmp10 = (((b1->x * b1->x) + (b1->y * b1->y)) + (b1->z * b1->z));
HXDLIN( 171)		Float _hx_tmp11 = ::Math_obj::sqrt(_hx_tmp10);
HXDLIN( 171)		Float _hx_tmp12 = ::Math_obj::acos(((Float)_hx_tmp7 / (Float)(_hx_tmp9 * _hx_tmp11)));
HXDLIN( 171)		Float _hx_tmp13 = ((Float)::Math_obj::PI / (Float)((Float)2.0));
HXDLIN( 171)		this->assertApproxEquals(_hx_tmp12,_hx_tmp13,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),171,HX_("test.Test3D",3f,be,21,72),HX_("testAngles",32,5b,0d,7c)));
HXLINE( 172)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,this3,"this") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)1.0),((Float)0.0));
HXDLIN( 172)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,b2,"b") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN( 172)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,self2,"self") = this3;
HXDLIN( 172)		Float _hx_tmp14 = (((self2->x * b2->x) + (self2->y * b2->y)) + (self2->z * b2->z));
HXDLIN( 172)		Float _hx_tmp15 = (((self2->x * self2->x) + (self2->y * self2->y)) + (self2->z * self2->z));
HXDLIN( 172)		Float _hx_tmp16 = ::Math_obj::sqrt(_hx_tmp15);
HXDLIN( 172)		Float _hx_tmp17 = (((b2->x * b2->x) + (b2->y * b2->y)) + (b2->z * b2->z));
HXDLIN( 172)		Float _hx_tmp18 = ::Math_obj::sqrt(_hx_tmp17);
HXDLIN( 172)		Float _hx_tmp19 = ::Math_obj::acos(((Float)_hx_tmp14 / (Float)(_hx_tmp16 * _hx_tmp18)));
HXDLIN( 172)		Float _hx_tmp20 = ((Float)::Math_obj::PI / (Float)((Float)2.0));
HXDLIN( 172)		this->assertApproxEquals(_hx_tmp19,_hx_tmp20,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),172,HX_("test.Test3D",3f,be,21,72),HX_("testAngles",32,5b,0d,7c)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testAngles,(void))

void Test3D_obj::testReflect(){
            	HX_STACK_FRAME("test.Test3D","testReflect",0x1d7dc55c,"test.Test3D.testReflect","test/Test3D.hx",177,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 177)		HX_VARI( Int,_g) = (int)0;
HXDLIN( 177)		while((_g < (int)10)){
HXLINE( 177)			++_g;
HXLINE( 179)			HX_VARI(  ::hxmath::math::Vector3Default,u) = this->randomVector3(null());
HXLINE( 180)			HX_VARI(  ::hxmath::math::Vector3Default,normal) =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN( 180)			HX_VARI(  ::hxmath::math::Vector3Default,self) =  ::hxmath::math::Vector3Default_obj::__new(u->x,u->y,u->z);
HXDLIN( 180)			HX_VARI_NAME(  ::hxmath::math::Vector3Default,self1,"self") =  ::hxmath::math::Vector3Default_obj::__new(self->x,self->y,self->z);
HXDLIN( 180)			HX_VARI( Float,s) = ((Float)(((self1->x * normal->x) + (self1->y * normal->y)) + (self1->z * normal->z)) / (Float)(((normal->x * normal->x) + (normal->y * normal->y)) + (normal->z * normal->z)));
HXDLIN( 180)			{
HXLINE( 180)				HX_VARI_NAME( Int,_g1,"_g") = (int)0;
HXDLIN( 180)				while((_g1 < (int)3)){
HXLINE( 180)					HX_VARI( Int,i) = _g1++;
HXDLIN( 180)					{
HXLINE( 180)						 ::Dynamic _hx_tmp;
HXDLIN( 180)						switch((int)(i)){
            							case (int)0: {
HXLINE( 180)								_hx_tmp = normal->x;
            							}
            							break;
            							case (int)1: {
HXLINE( 180)								_hx_tmp = normal->y;
            							}
            							break;
            							case (int)2: {
HXLINE( 180)								_hx_tmp = normal->z;
            							}
            							break;
            							default:{
HXLINE( 180)								HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            							}
            						}
HXDLIN( 180)						HX_VARI( Float,value) = ( (Float)(_hx_tmp) );
HXDLIN( 180)						switch((int)(i)){
            							case (int)0: {
HXLINE( 180)								self1->x = value;
            							}
            							break;
            							case (int)1: {
HXLINE( 180)								self1->y = value;
            							}
            							break;
            							case (int)2: {
HXLINE( 180)								self1->z = value;
            							}
            							break;
            							default:{
HXLINE( 180)								HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            							}
            						}
            					}
            				}
            			}
HXDLIN( 180)			{
HXLINE( 180)				hx::MultEq(self1->x,s);
HXDLIN( 180)				hx::MultEq(self1->y,s);
HXDLIN( 180)				hx::MultEq(self1->z,s);
            			}
HXDLIN( 180)			{
HXLINE( 180)				hx::MultEq(self1->x,((Float)2.0));
HXDLIN( 180)				hx::MultEq(self1->y,((Float)2.0));
HXDLIN( 180)				hx::MultEq(self1->z,((Float)2.0));
            			}
HXDLIN( 180)			{
HXLINE( 180)				hx::SubEq(self->x,self1->x);
HXDLIN( 180)				hx::SubEq(self->y,self1->y);
HXDLIN( 180)				hx::SubEq(self->z,self1->z);
            			}
HXLINE( 182)			this->assertEquals(u->x,self->x,hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),182,HX_("test.Test3D",3f,be,21,72),HX_("testReflect",0b,72,f2,a5)));
HXLINE( 183)			this->assertEquals(u->y,self->y,hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),183,HX_("test.Test3D",3f,be,21,72),HX_("testReflect",0b,72,f2,a5)));
HXLINE( 184)			this->assertEquals(-(u->z),self->z,hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),184,HX_("test.Test3D",3f,be,21,72),HX_("testReflect",0b,72,f2,a5)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testReflect,(void))

void Test3D_obj::testProjectOntoPlane(){
            	HX_STACK_FRAME("test.Test3D","testProjectOntoPlane",0xc021288a,"test.Test3D.testProjectOntoPlane","test/Test3D.hx",190,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 190)		HX_VARI( Int,_g) = (int)0;
HXDLIN( 190)		while((_g < (int)10)){
HXLINE( 190)			++_g;
HXLINE( 192)			HX_VARI(  ::hxmath::math::Vector3Default,u) = this->randomVector3(null());
HXLINE( 193)			HX_VARI(  ::hxmath::math::Vector3Default,normal) = this->randomVector3(null());
HXLINE( 195)			{
HXLINE( 195)				HX_VARI(  ::hxmath::math::Vector3Default,self) =  ::hxmath::math::Vector3Default_obj::__new(u->x,u->y,u->z);
HXDLIN( 195)				HX_VARI( Float,s) = ((Float)(((self->x * normal->x) + (self->y * normal->y)) + (self->z * normal->z)) / (Float)(((normal->x * normal->x) + (normal->y * normal->y)) + (normal->z * normal->z)));
HXDLIN( 195)				{
HXLINE( 195)					HX_VARI_NAME( Int,_g1,"_g") = (int)0;
HXDLIN( 195)					while((_g1 < (int)3)){
HXLINE( 195)						HX_VARI( Int,i) = _g1++;
HXDLIN( 195)						{
HXLINE( 195)							 ::Dynamic _hx_tmp;
HXDLIN( 195)							switch((int)(i)){
            								case (int)0: {
HXLINE( 195)									_hx_tmp = normal->x;
            								}
            								break;
            								case (int)1: {
HXLINE( 195)									_hx_tmp = normal->y;
            								}
            								break;
            								case (int)2: {
HXLINE( 195)									_hx_tmp = normal->z;
            								}
            								break;
            								default:{
HXLINE( 195)									HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            								}
            							}
HXDLIN( 195)							HX_VARI( Float,value) = ( (Float)(_hx_tmp) );
HXDLIN( 195)							switch((int)(i)){
            								case (int)0: {
HXLINE( 195)									self->x = value;
            								}
            								break;
            								case (int)1: {
HXLINE( 195)									self->y = value;
            								}
            								break;
            								case (int)2: {
HXLINE( 195)									self->z = value;
            								}
            								break;
            								default:{
HXLINE( 195)									HX_STACK_DO_THROW(HX_("Invalid element",73,24,cd,01));
            								}
            							}
            						}
            					}
            				}
HXDLIN( 195)				{
HXLINE( 195)					hx::MultEq(self->x,s);
HXDLIN( 195)					hx::MultEq(self->y,s);
HXDLIN( 195)					hx::MultEq(self->z,s);
            				}
HXDLIN( 195)				hx::SubEq(u->x,self->x);
HXDLIN( 195)				hx::SubEq(u->y,self->y);
HXDLIN( 195)				hx::SubEq(u->z,self->z);
            			}
HXLINE( 197)			Float _hx_tmp1 = (((u->x * normal->x) + (u->y * normal->y)) + (u->z * normal->z));
HXDLIN( 197)			this->assertApproxEquals(((Float)0.0),_hx_tmp1,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),197,HX_("test.Test3D",3f,be,21,72),HX_("testProjectOntoPlane",fb,ed,9e,04)));
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testProjectOntoPlane,(void))

void Test3D_obj::testSlerpMidpointAngle(){
            	HX_STACK_FRAME("test.Test3D","testSlerpMidpointAngle",0xbcbe5b62,"test.Test3D.testSlerpMidpointAngle","test/Test3D.hx",202,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 203)		HX_VARI(  ::hxmath::math::Vector3Default,axis) =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN( 203)		HX_VARI( Float,angleRadians) = (((Float)::Math_obj::PI / (Float)(int)180) * (int)0);
HXDLIN( 203)		HX_VARI( Float,cosHalfAngle) = ::Math_obj::cos(((Float)angleRadians / (Float)((Float)2.0)));
HXDLIN( 203)		HX_VARI( Float,sinHalfAngle) = ::Math_obj::sin(((Float)angleRadians / (Float)((Float)2.0)));
HXDLIN( 203)		HX_VARI(  ::hxmath::math::QuaternionDefault,qA) =  ::hxmath::math::QuaternionDefault_obj::__new(cosHalfAngle,(sinHalfAngle * axis->x),(sinHalfAngle * axis->y),(sinHalfAngle * axis->z));
HXLINE( 204)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,axis1,"axis") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN( 204)		HX_VARI_NAME( Float,angleRadians1,"angleRadians") = (((Float)::Math_obj::PI / (Float)(int)180) * (int)90);
HXDLIN( 204)		HX_VARI_NAME( Float,cosHalfAngle1,"cosHalfAngle") = ::Math_obj::cos(((Float)angleRadians1 / (Float)((Float)2.0)));
HXDLIN( 204)		HX_VARI_NAME( Float,sinHalfAngle1,"sinHalfAngle") = ::Math_obj::sin(((Float)angleRadians1 / (Float)((Float)2.0)));
HXDLIN( 204)		HX_VARI(  ::hxmath::math::QuaternionDefault,qB) =  ::hxmath::math::QuaternionDefault_obj::__new(cosHalfAngle1,(sinHalfAngle1 * axis1->x),(sinHalfAngle1 * axis1->y),(sinHalfAngle1 * axis1->z));
HXLINE( 205)		HX_VARI( Float,cosHalfTheta) = ((((qA->s * qB->s) + (qA->x * qB->x)) + (qA->y * qB->y)) + (qA->z * qB->z));
HXDLIN( 205)		HX_VAR(  ::hxmath::math::QuaternionDefault,qC);
HXDLIN( 205)		Float _hx_tmp = ::Math_obj::abs(cosHalfTheta);
HXDLIN( 205)		if ((_hx_tmp >= ((Float)1.0))) {
HXLINE( 205)			qC = qA;
            		}
            		else {
HXLINE( 205)			HX_VARI( Float,halfTheta) = ::Math_obj::acos(cosHalfTheta);
HXDLIN( 205)			HX_VARI( Float,sinHalfTheta) = ::Math_obj::sqrt((((Float)1.0) - (cosHalfTheta * cosHalfTheta)));
HXDLIN( 205)			Float _hx_tmp1 = ::Math_obj::abs(sinHalfTheta);
HXDLIN( 205)			if ((_hx_tmp1 < ((Float)1e-3))) {
HXLINE( 205)				HX_VARI(  ::hxmath::math::QuaternionDefault,self) =  ::hxmath::math::QuaternionDefault_obj::__new(qA->s,qA->x,qA->y,qA->z);
HXDLIN( 205)				hx::MultEq(self->s,((Float)0.5));
HXDLIN( 205)				hx::MultEq(self->x,((Float)0.5));
HXDLIN( 205)				hx::MultEq(self->y,((Float)0.5));
HXDLIN( 205)				hx::MultEq(self->z,((Float)0.5));
HXDLIN( 205)				HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self1,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(qB->s,qB->x,qB->y,qB->z);
HXDLIN( 205)				hx::MultEq(self1->s,((Float)0.5));
HXDLIN( 205)				hx::MultEq(self1->x,((Float)0.5));
HXDLIN( 205)				hx::MultEq(self1->y,((Float)0.5));
HXDLIN( 205)				hx::MultEq(self1->z,((Float)0.5));
HXDLIN( 205)				HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self2,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(self->s,self->x,self->y,self->z);
HXDLIN( 205)				hx::AddEq(self2->s,self1->s);
HXDLIN( 205)				hx::AddEq(self2->x,self1->x);
HXDLIN( 205)				hx::AddEq(self2->y,self1->y);
HXDLIN( 205)				hx::AddEq(self2->z,self1->z);
HXDLIN( 205)				HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self3,"self") = self2;
HXDLIN( 205)				Float _hx_tmp2 = ((((self3->s * self3->s) + (self3->x * self3->x)) + (self3->y * self3->y)) + (self3->z * self3->z));
HXDLIN( 205)				HX_VARI( Float,length) = ::Math_obj::sqrt(_hx_tmp2);
HXDLIN( 205)				if ((length > ((Float)0.0))) {
HXLINE( 205)					HX_VARI( Float,k) = ((Float)((Float)1.0) / (Float)length);
HXDLIN( 205)					{
HXLINE( 205)						hx::MultEq(self3->s,k);
HXDLIN( 205)						hx::MultEq(self3->x,k);
HXDLIN( 205)						hx::MultEq(self3->y,k);
HXDLIN( 205)						hx::MultEq(self3->z,k);
            					}
            				}
HXDLIN( 205)				qC = self3;
            			}
            			else {
HXLINE( 205)				Float _hx_tmp3 = ::Math_obj::sin((((Float)0.5) * halfTheta));
HXDLIN( 205)				HX_VARI( Float,ta) = ((Float)_hx_tmp3 / (Float)sinHalfTheta);
HXDLIN( 205)				Float _hx_tmp4 = ::Math_obj::sin((((Float)0.5) * halfTheta));
HXDLIN( 205)				HX_VARI( Float,tb) = ((Float)_hx_tmp4 / (Float)sinHalfTheta);
HXDLIN( 205)				HX_VARI(  ::hxmath::math::QuaternionDefault,result) =  ::hxmath::math::QuaternionDefault_obj::__new((int)0,(int)0,(int)0,(int)0);
HXDLIN( 205)				Float _hx_tmp5 = (qA->x * ta);
HXDLIN( 205)				Float _hx_tmp6 = (qB->x * tb);
HXDLIN( 205)				result->x = (_hx_tmp5 + _hx_tmp6);
HXDLIN( 205)				Float _hx_tmp7 = (qA->y * ta);
HXDLIN( 205)				Float _hx_tmp8 = (qB->y * tb);
HXDLIN( 205)				result->y = (_hx_tmp7 + _hx_tmp8);
HXDLIN( 205)				Float _hx_tmp9 = (qA->z * ta);
HXDLIN( 205)				Float _hx_tmp10 = (qB->z * tb);
HXDLIN( 205)				result->z = (_hx_tmp9 + _hx_tmp10);
HXDLIN( 205)				Float _hx_tmp11 = (qA->s * ta);
HXDLIN( 205)				Float _hx_tmp12 = (qB->s * tb);
HXDLIN( 205)				result->s = (_hx_tmp11 + _hx_tmp12);
HXDLIN( 205)				qC = result;
            			}
            		}
HXLINE( 207)		Float _hx_tmp13 = ((((qA->s * qC->s) + (qA->x * qC->x)) + (qA->y * qC->y)) + (qA->z * qC->z));
HXDLIN( 207)		Float _hx_tmp14 = ((((qA->s * qA->s) + (qA->x * qA->x)) + (qA->y * qA->y)) + (qA->z * qA->z));
HXDLIN( 207)		Float _hx_tmp15 = ::Math_obj::sqrt(_hx_tmp14);
HXDLIN( 207)		HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self4,"self") = qC;
HXDLIN( 207)		Float _hx_tmp16 = ((((self4->s * self4->s) + (self4->x * self4->x)) + (self4->y * self4->y)) + (self4->z * self4->z));
HXDLIN( 207)		Float _hx_tmp17 = ::Math_obj::sqrt(_hx_tmp16);
HXDLIN( 207)		Float _hx_tmp18 = ::Math_obj::acos(((Float)_hx_tmp13 / (Float)(_hx_tmp15 * _hx_tmp17)));
HXDLIN( 207)		HX_VARI( Float,angleAC) = ((Float)((((Float)2.0) * _hx_tmp18) * ((Float)180.0)) / (Float)::Math_obj::PI);
HXLINE( 208)		HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self5,"self") = qC;
HXDLIN( 208)		Float _hx_tmp19 = ((((self5->s * qB->s) + (self5->x * qB->x)) + (self5->y * qB->y)) + (self5->z * qB->z));
HXDLIN( 208)		Float _hx_tmp20 = ((((self5->s * self5->s) + (self5->x * self5->x)) + (self5->y * self5->y)) + (self5->z * self5->z));
HXDLIN( 208)		Float _hx_tmp21 = ::Math_obj::sqrt(_hx_tmp20);
HXDLIN( 208)		Float _hx_tmp22 = ((((qB->s * qB->s) + (qB->x * qB->x)) + (qB->y * qB->y)) + (qB->z * qB->z));
HXDLIN( 208)		Float _hx_tmp23 = ::Math_obj::sqrt(_hx_tmp22);
HXDLIN( 208)		Float _hx_tmp24 = ::Math_obj::acos(((Float)_hx_tmp19 / (Float)(_hx_tmp21 * _hx_tmp23)));
HXDLIN( 208)		HX_VARI( Float,angleCB) = ((Float)((((Float)2.0) * _hx_tmp24) * ((Float)180.0)) / (Float)::Math_obj::PI);
HXLINE( 209)		this->assertApproxEquals(((Float)45.0),angleAC,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),209,HX_("test.Test3D",3f,be,21,72),HX_("testSlerpMidpointAngle",13,1f,4d,70)));
HXLINE( 210)		this->assertApproxEquals(((Float)45.0),angleCB,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),210,HX_("test.Test3D",3f,be,21,72),HX_("testSlerpMidpointAngle",13,1f,4d,70)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testSlerpMidpointAngle,(void))

void Test3D_obj::testSlerpMonotonicity(){
            	HX_STACK_FRAME("test.Test3D","testSlerpMonotonicity",0xb472bfad,"test.Test3D.testSlerpMonotonicity","test/Test3D.hx",215,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 215)		HX_VARI( Int,_g) = (int)0;
HXDLIN( 215)		while((_g < (int)10)){
HXLINE( 215)			++_g;
HXLINE( 217)			HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,this1,"this") = this->randomQuaternion(null());
HXDLIN( 217)			HX_VARI(  ::hxmath::math::QuaternionDefault,self) = this1;
HXDLIN( 217)			Float _hx_tmp = ((((self->s * self->s) + (self->x * self->x)) + (self->y * self->y)) + (self->z * self->z));
HXDLIN( 217)			HX_VARI( Float,length) = ::Math_obj::sqrt(_hx_tmp);
HXDLIN( 217)			if ((length > ((Float)0.0))) {
HXLINE( 217)				HX_VARI( Float,k) = ((Float)((Float)1.0) / (Float)length);
HXDLIN( 217)				{
HXLINE( 217)					hx::MultEq(self->s,k);
HXDLIN( 217)					hx::MultEq(self->x,k);
HXDLIN( 217)					hx::MultEq(self->y,k);
HXDLIN( 217)					hx::MultEq(self->z,k);
            				}
            			}
HXLINE( 218)			HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,this2,"this") = this->randomQuaternion(null());
HXDLIN( 218)			HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self1,"self") = this2;
HXDLIN( 218)			Float _hx_tmp1 = ((((self1->s * self1->s) + (self1->x * self1->x)) + (self1->y * self1->y)) + (self1->z * self1->z));
HXDLIN( 218)			HX_VARI_NAME( Float,length1,"length") = ::Math_obj::sqrt(_hx_tmp1);
HXDLIN( 218)			if ((length1 > ((Float)0.0))) {
HXLINE( 218)				HX_VARI_NAME( Float,k1,"k") = ((Float)((Float)1.0) / (Float)length1);
HXDLIN( 218)				{
HXLINE( 218)					hx::MultEq(self1->s,k1);
HXDLIN( 218)					hx::MultEq(self1->x,k1);
HXDLIN( 218)					hx::MultEq(self1->y,k1);
HXDLIN( 218)					hx::MultEq(self1->z,k1);
            				}
            			}
HXLINE( 220)			HX_VARI( Float,lastAC) = ::Math_obj::NEGATIVE_INFINITY;
HXLINE( 221)			HX_VARI( Float,lastCB) = ::Math_obj::POSITIVE_INFINITY;
HXLINE( 223)			{
HXLINE( 223)				HX_VARI( Int,_g1) = (int)1;
HXDLIN( 223)				while((_g1 < (int)12)){
HXLINE( 223)					HX_VARI( Int,step) = _g1++;
HXLINE( 225)					HX_VARI( Float,t) = ((Float)step / (Float)(int)12);
HXLINE( 226)					HX_VARI( Float,cosHalfTheta) = ((((self->s * self1->s) + (self->x * self1->x)) + (self->y * self1->y)) + (self->z * self1->z));
HXDLIN( 226)					HX_VAR(  ::hxmath::math::QuaternionDefault,qC);
HXDLIN( 226)					Float _hx_tmp2 = ::Math_obj::abs(cosHalfTheta);
HXDLIN( 226)					if ((_hx_tmp2 >= ((Float)1.0))) {
HXLINE( 226)						qC = self;
            					}
            					else {
HXLINE( 226)						HX_VARI( Float,halfTheta) = ::Math_obj::acos(cosHalfTheta);
HXDLIN( 226)						HX_VARI( Float,sinHalfTheta) = ::Math_obj::sqrt((((Float)1.0) - (cosHalfTheta * cosHalfTheta)));
HXDLIN( 226)						Float _hx_tmp3 = ::Math_obj::abs(sinHalfTheta);
HXDLIN( 226)						if ((_hx_tmp3 < ((Float)1e-3))) {
HXLINE( 226)							HX_VARI( Float,s) = (((Float)1.0) - t);
HXDLIN( 226)							HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self2,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(self->s,self->x,self->y,self->z);
HXDLIN( 226)							hx::MultEq(self2->s,s);
HXDLIN( 226)							hx::MultEq(self2->x,s);
HXDLIN( 226)							hx::MultEq(self2->y,s);
HXDLIN( 226)							hx::MultEq(self2->z,s);
HXDLIN( 226)							HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self3,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(self1->s,self1->x,self1->y,self1->z);
HXDLIN( 226)							hx::MultEq(self3->s,t);
HXDLIN( 226)							hx::MultEq(self3->x,t);
HXDLIN( 226)							hx::MultEq(self3->y,t);
HXDLIN( 226)							hx::MultEq(self3->z,t);
HXDLIN( 226)							HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self4,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(self2->s,self2->x,self2->y,self2->z);
HXDLIN( 226)							hx::AddEq(self4->s,self3->s);
HXDLIN( 226)							hx::AddEq(self4->x,self3->x);
HXDLIN( 226)							hx::AddEq(self4->y,self3->y);
HXDLIN( 226)							hx::AddEq(self4->z,self3->z);
HXDLIN( 226)							HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self5,"self") = self4;
HXDLIN( 226)							Float _hx_tmp4 = ((((self5->s * self5->s) + (self5->x * self5->x)) + (self5->y * self5->y)) + (self5->z * self5->z));
HXDLIN( 226)							HX_VARI_NAME( Float,length2,"length") = ::Math_obj::sqrt(_hx_tmp4);
HXDLIN( 226)							if ((length2 > ((Float)0.0))) {
HXLINE( 226)								HX_VARI_NAME( Float,k2,"k") = ((Float)((Float)1.0) / (Float)length2);
HXDLIN( 226)								{
HXLINE( 226)									hx::MultEq(self5->s,k2);
HXDLIN( 226)									hx::MultEq(self5->x,k2);
HXDLIN( 226)									hx::MultEq(self5->y,k2);
HXDLIN( 226)									hx::MultEq(self5->z,k2);
            								}
            							}
HXDLIN( 226)							qC = self5;
            						}
            						else {
HXLINE( 226)							Float _hx_tmp5 = ::Math_obj::sin((((int)1 - t) * halfTheta));
HXDLIN( 226)							HX_VARI( Float,ta) = ((Float)_hx_tmp5 / (Float)sinHalfTheta);
HXDLIN( 226)							Float _hx_tmp6 = ::Math_obj::sin((t * halfTheta));
HXDLIN( 226)							HX_VARI( Float,tb) = ((Float)_hx_tmp6 / (Float)sinHalfTheta);
HXDLIN( 226)							HX_VARI(  ::hxmath::math::QuaternionDefault,result) =  ::hxmath::math::QuaternionDefault_obj::__new((int)0,(int)0,(int)0,(int)0);
HXDLIN( 226)							Float _hx_tmp7 = (self->x * ta);
HXDLIN( 226)							Float _hx_tmp8 = (self1->x * tb);
HXDLIN( 226)							result->x = (_hx_tmp7 + _hx_tmp8);
HXDLIN( 226)							Float _hx_tmp9 = (self->y * ta);
HXDLIN( 226)							Float _hx_tmp10 = (self1->y * tb);
HXDLIN( 226)							result->y = (_hx_tmp9 + _hx_tmp10);
HXDLIN( 226)							Float _hx_tmp11 = (self->z * ta);
HXDLIN( 226)							Float _hx_tmp12 = (self1->z * tb);
HXDLIN( 226)							result->z = (_hx_tmp11 + _hx_tmp12);
HXDLIN( 226)							Float _hx_tmp13 = (self->s * ta);
HXDLIN( 226)							Float _hx_tmp14 = (self1->s * tb);
HXDLIN( 226)							result->s = (_hx_tmp13 + _hx_tmp14);
HXDLIN( 226)							qC = result;
            						}
            					}
HXLINE( 227)					Float _hx_tmp15 = ((((self->s * qC->s) + (self->x * qC->x)) + (self->y * qC->y)) + (self->z * qC->z));
HXDLIN( 227)					Float _hx_tmp16 = ((((self->s * self->s) + (self->x * self->x)) + (self->y * self->y)) + (self->z * self->z));
HXDLIN( 227)					Float _hx_tmp17 = ::Math_obj::sqrt(_hx_tmp16);
HXDLIN( 227)					HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self6,"self") = qC;
HXDLIN( 227)					Float _hx_tmp18 = ((((self6->s * self6->s) + (self6->x * self6->x)) + (self6->y * self6->y)) + (self6->z * self6->z));
HXDLIN( 227)					Float _hx_tmp19 = ::Math_obj::sqrt(_hx_tmp18);
HXDLIN( 227)					Float _hx_tmp20 = ::Math_obj::acos(((Float)_hx_tmp15 / (Float)(_hx_tmp17 * _hx_tmp19)));
HXDLIN( 227)					HX_VARI( Float,angleAC) = ((Float)((((Float)2.0) * _hx_tmp20) * ((Float)180.0)) / (Float)::Math_obj::PI);
HXLINE( 228)					HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self7,"self") = qC;
HXDLIN( 228)					Float _hx_tmp21 = ((((self7->s * self1->s) + (self7->x * self1->x)) + (self7->y * self1->y)) + (self7->z * self1->z));
HXDLIN( 228)					Float _hx_tmp22 = ((((self7->s * self7->s) + (self7->x * self7->x)) + (self7->y * self7->y)) + (self7->z * self7->z));
HXDLIN( 228)					Float _hx_tmp23 = ::Math_obj::sqrt(_hx_tmp22);
HXDLIN( 228)					Float _hx_tmp24 = ((((self1->s * self1->s) + (self1->x * self1->x)) + (self1->y * self1->y)) + (self1->z * self1->z));
HXDLIN( 228)					Float _hx_tmp25 = ::Math_obj::sqrt(_hx_tmp24);
HXDLIN( 228)					Float _hx_tmp26 = ::Math_obj::acos(((Float)_hx_tmp21 / (Float)(_hx_tmp23 * _hx_tmp25)));
HXDLIN( 228)					HX_VARI( Float,angleCB) = ((Float)((((Float)2.0) * _hx_tmp26) * ((Float)180.0)) / (Float)::Math_obj::PI);
HXLINE( 230)					this->assertTrue((angleAC > lastAC),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),230,HX_("test.Test3D",3f,be,21,72),HX_("testSlerpMonotonicity",1c,bd,01,5e)));
HXLINE( 231)					this->assertTrue((angleCB < lastCB),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),231,HX_("test.Test3D",3f,be,21,72),HX_("testSlerpMonotonicity",1c,bd,01,5e)));
HXLINE( 232)					lastAC = angleAC;
HXLINE( 233)					lastCB = angleCB;
            				}
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testSlerpMonotonicity,(void))

void Test3D_obj::testSlerpLargeAngleStability(){
            	HX_STACK_FRAME("test.Test3D","testSlerpLargeAngleStability",0x5f606ba8,"test.Test3D.testSlerpLargeAngleStability","test/Test3D.hx",239,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 240)		HX_VARI(  ::hxmath::math::Vector3Default,axis) =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN( 240)		HX_VARI( Float,angleRadians) = (((Float)::Math_obj::PI / (Float)(int)180) * (int)0);
HXDLIN( 240)		HX_VARI( Float,cosHalfAngle) = ::Math_obj::cos(((Float)angleRadians / (Float)((Float)2.0)));
HXDLIN( 240)		HX_VARI( Float,sinHalfAngle) = ::Math_obj::sin(((Float)angleRadians / (Float)((Float)2.0)));
HXDLIN( 240)		HX_VARI(  ::hxmath::math::QuaternionDefault,qA) =  ::hxmath::math::QuaternionDefault_obj::__new(cosHalfAngle,(sinHalfAngle * axis->x),(sinHalfAngle * axis->y),(sinHalfAngle * axis->z));
HXLINE( 241)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,axis1,"axis") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN( 241)		HX_VARI_NAME( Float,angleRadians1,"angleRadians") = (((Float)::Math_obj::PI / (Float)(int)180) * (int)180);
HXDLIN( 241)		HX_VARI_NAME( Float,cosHalfAngle1,"cosHalfAngle") = ::Math_obj::cos(((Float)angleRadians1 / (Float)((Float)2.0)));
HXDLIN( 241)		HX_VARI_NAME( Float,sinHalfAngle1,"sinHalfAngle") = ::Math_obj::sin(((Float)angleRadians1 / (Float)((Float)2.0)));
HXDLIN( 241)		HX_VARI(  ::hxmath::math::QuaternionDefault,qB) =  ::hxmath::math::QuaternionDefault_obj::__new(cosHalfAngle1,(sinHalfAngle1 * axis1->x),(sinHalfAngle1 * axis1->y),(sinHalfAngle1 * axis1->z));
HXLINE( 242)		HX_VARI( Float,cosHalfTheta) = ((((qA->s * qB->s) + (qA->x * qB->x)) + (qA->y * qB->y)) + (qA->z * qB->z));
HXDLIN( 242)		HX_VAR(  ::hxmath::math::QuaternionDefault,qC);
HXDLIN( 242)		Float _hx_tmp = ::Math_obj::abs(cosHalfTheta);
HXDLIN( 242)		if ((_hx_tmp >= ((Float)1.0))) {
HXLINE( 242)			qC = qA;
            		}
            		else {
HXLINE( 242)			HX_VARI( Float,halfTheta) = ::Math_obj::acos(cosHalfTheta);
HXDLIN( 242)			HX_VARI( Float,sinHalfTheta) = ::Math_obj::sqrt((((Float)1.0) - (cosHalfTheta * cosHalfTheta)));
HXDLIN( 242)			Float _hx_tmp1 = ::Math_obj::abs(sinHalfTheta);
HXDLIN( 242)			if ((_hx_tmp1 < ((Float)1e-3))) {
HXLINE( 242)				HX_VARI(  ::hxmath::math::QuaternionDefault,self) =  ::hxmath::math::QuaternionDefault_obj::__new(qA->s,qA->x,qA->y,qA->z);
HXDLIN( 242)				hx::MultEq(self->s,((Float)0.5));
HXDLIN( 242)				hx::MultEq(self->x,((Float)0.5));
HXDLIN( 242)				hx::MultEq(self->y,((Float)0.5));
HXDLIN( 242)				hx::MultEq(self->z,((Float)0.5));
HXDLIN( 242)				HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self1,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(qB->s,qB->x,qB->y,qB->z);
HXDLIN( 242)				hx::MultEq(self1->s,((Float)0.5));
HXDLIN( 242)				hx::MultEq(self1->x,((Float)0.5));
HXDLIN( 242)				hx::MultEq(self1->y,((Float)0.5));
HXDLIN( 242)				hx::MultEq(self1->z,((Float)0.5));
HXDLIN( 242)				HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self2,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(self->s,self->x,self->y,self->z);
HXDLIN( 242)				hx::AddEq(self2->s,self1->s);
HXDLIN( 242)				hx::AddEq(self2->x,self1->x);
HXDLIN( 242)				hx::AddEq(self2->y,self1->y);
HXDLIN( 242)				hx::AddEq(self2->z,self1->z);
HXDLIN( 242)				HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self3,"self") = self2;
HXDLIN( 242)				Float _hx_tmp2 = ((((self3->s * self3->s) + (self3->x * self3->x)) + (self3->y * self3->y)) + (self3->z * self3->z));
HXDLIN( 242)				HX_VARI( Float,length) = ::Math_obj::sqrt(_hx_tmp2);
HXDLIN( 242)				if ((length > ((Float)0.0))) {
HXLINE( 242)					HX_VARI( Float,k) = ((Float)((Float)1.0) / (Float)length);
HXDLIN( 242)					{
HXLINE( 242)						hx::MultEq(self3->s,k);
HXDLIN( 242)						hx::MultEq(self3->x,k);
HXDLIN( 242)						hx::MultEq(self3->y,k);
HXDLIN( 242)						hx::MultEq(self3->z,k);
            					}
            				}
HXDLIN( 242)				qC = self3;
            			}
            			else {
HXLINE( 242)				Float _hx_tmp3 = ::Math_obj::sin((((Float)0.5) * halfTheta));
HXDLIN( 242)				HX_VARI( Float,ta) = ((Float)_hx_tmp3 / (Float)sinHalfTheta);
HXDLIN( 242)				Float _hx_tmp4 = ::Math_obj::sin((((Float)0.5) * halfTheta));
HXDLIN( 242)				HX_VARI( Float,tb) = ((Float)_hx_tmp4 / (Float)sinHalfTheta);
HXDLIN( 242)				HX_VARI(  ::hxmath::math::QuaternionDefault,result) =  ::hxmath::math::QuaternionDefault_obj::__new((int)0,(int)0,(int)0,(int)0);
HXDLIN( 242)				Float _hx_tmp5 = (qA->x * ta);
HXDLIN( 242)				Float _hx_tmp6 = (qB->x * tb);
HXDLIN( 242)				result->x = (_hx_tmp5 + _hx_tmp6);
HXDLIN( 242)				Float _hx_tmp7 = (qA->y * ta);
HXDLIN( 242)				Float _hx_tmp8 = (qB->y * tb);
HXDLIN( 242)				result->y = (_hx_tmp7 + _hx_tmp8);
HXDLIN( 242)				Float _hx_tmp9 = (qA->z * ta);
HXDLIN( 242)				Float _hx_tmp10 = (qB->z * tb);
HXDLIN( 242)				result->z = (_hx_tmp9 + _hx_tmp10);
HXDLIN( 242)				Float _hx_tmp11 = (qA->s * ta);
HXDLIN( 242)				Float _hx_tmp12 = (qB->s * tb);
HXDLIN( 242)				result->s = (_hx_tmp11 + _hx_tmp12);
HXDLIN( 242)				qC = result;
            			}
            		}
HXLINE( 244)		HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self4,"self") = qC;
HXDLIN( 244)		Float _hx_tmp13 = ((((self4->s * qA->s) + (self4->x * qA->x)) + (self4->y * qA->y)) + (self4->z * qA->z));
HXDLIN( 244)		Float _hx_tmp14 = ((((self4->s * self4->s) + (self4->x * self4->x)) + (self4->y * self4->y)) + (self4->z * self4->z));
HXDLIN( 244)		Float _hx_tmp15 = ::Math_obj::sqrt(_hx_tmp14);
HXDLIN( 244)		Float _hx_tmp16 = ((((qA->s * qA->s) + (qA->x * qA->x)) + (qA->y * qA->y)) + (qA->z * qA->z));
HXDLIN( 244)		Float _hx_tmp17 = ::Math_obj::sqrt(_hx_tmp16);
HXDLIN( 244)		Float _hx_tmp18 = ::Math_obj::acos(((Float)_hx_tmp13 / (Float)(_hx_tmp15 * _hx_tmp17)));
HXDLIN( 244)		Float _hx_tmp19 = ((Float)((((Float)2.0) * _hx_tmp18) * ((Float)180.0)) / (Float)::Math_obj::PI);
HXDLIN( 244)		this->assertApproxEquals((int)90,_hx_tmp19,null(),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),244,HX_("test.Test3D",3f,be,21,72),HX_("testSlerpLargeAngleStability",19,8a,3a,cb)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testSlerpLargeAngleStability,(void))

void Test3D_obj::testSlerpSmallAngleStability(){
            	HX_STACK_FRAME("test.Test3D","testSlerpSmallAngleStability",0xa40c65b4,"test.Test3D.testSlerpSmallAngleStability","test/Test3D.hx",248,0x591b2dbe)
            	HX_STACK_THIS(this)
HXLINE( 249)		HX_VARI(  ::hxmath::math::Vector3Default,axis) =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN( 249)		HX_VARI( Float,angleRadians) = (((Float)::Math_obj::PI / (Float)(int)180) * (int)0);
HXDLIN( 249)		HX_VARI( Float,cosHalfAngle) = ::Math_obj::cos(((Float)angleRadians / (Float)((Float)2.0)));
HXDLIN( 249)		HX_VARI( Float,sinHalfAngle) = ::Math_obj::sin(((Float)angleRadians / (Float)((Float)2.0)));
HXDLIN( 249)		HX_VARI(  ::hxmath::math::QuaternionDefault,qA) =  ::hxmath::math::QuaternionDefault_obj::__new(cosHalfAngle,(sinHalfAngle * axis->x),(sinHalfAngle * axis->y),(sinHalfAngle * axis->z));
HXLINE( 250)		HX_VARI_NAME(  ::hxmath::math::Vector3Default,axis1,"axis") =  ::hxmath::math::Vector3Default_obj::__new(((Float)0.0),((Float)0.0),((Float)1.0));
HXDLIN( 250)		HX_VARI_NAME( Float,angleRadians1,"angleRadians") = (((Float)::Math_obj::PI / (Float)(int)180) * ((Float)1e-2));
HXDLIN( 250)		HX_VARI_NAME( Float,cosHalfAngle1,"cosHalfAngle") = ::Math_obj::cos(((Float)angleRadians1 / (Float)((Float)2.0)));
HXDLIN( 250)		HX_VARI_NAME( Float,sinHalfAngle1,"sinHalfAngle") = ::Math_obj::sin(((Float)angleRadians1 / (Float)((Float)2.0)));
HXDLIN( 250)		HX_VARI(  ::hxmath::math::QuaternionDefault,qB) =  ::hxmath::math::QuaternionDefault_obj::__new(cosHalfAngle1,(sinHalfAngle1 * axis1->x),(sinHalfAngle1 * axis1->y),(sinHalfAngle1 * axis1->z));
HXLINE( 251)		HX_VARI( Float,cosHalfTheta) = ((((qA->s * qB->s) + (qA->x * qB->x)) + (qA->y * qB->y)) + (qA->z * qB->z));
HXDLIN( 251)		HX_VAR(  ::hxmath::math::QuaternionDefault,qC);
HXDLIN( 251)		Float _hx_tmp = ::Math_obj::abs(cosHalfTheta);
HXDLIN( 251)		if ((_hx_tmp >= ((Float)1.0))) {
HXLINE( 251)			qC = qA;
            		}
            		else {
HXLINE( 251)			HX_VARI( Float,halfTheta) = ::Math_obj::acos(cosHalfTheta);
HXDLIN( 251)			HX_VARI( Float,sinHalfTheta) = ::Math_obj::sqrt((((Float)1.0) - (cosHalfTheta * cosHalfTheta)));
HXDLIN( 251)			Float _hx_tmp1 = ::Math_obj::abs(sinHalfTheta);
HXDLIN( 251)			if ((_hx_tmp1 < ((Float)1e-3))) {
HXLINE( 251)				HX_VARI(  ::hxmath::math::QuaternionDefault,self) =  ::hxmath::math::QuaternionDefault_obj::__new(qA->s,qA->x,qA->y,qA->z);
HXDLIN( 251)				hx::MultEq(self->s,((Float)0.5));
HXDLIN( 251)				hx::MultEq(self->x,((Float)0.5));
HXDLIN( 251)				hx::MultEq(self->y,((Float)0.5));
HXDLIN( 251)				hx::MultEq(self->z,((Float)0.5));
HXDLIN( 251)				HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self1,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(qB->s,qB->x,qB->y,qB->z);
HXDLIN( 251)				hx::MultEq(self1->s,((Float)0.5));
HXDLIN( 251)				hx::MultEq(self1->x,((Float)0.5));
HXDLIN( 251)				hx::MultEq(self1->y,((Float)0.5));
HXDLIN( 251)				hx::MultEq(self1->z,((Float)0.5));
HXDLIN( 251)				HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self2,"self") =  ::hxmath::math::QuaternionDefault_obj::__new(self->s,self->x,self->y,self->z);
HXDLIN( 251)				hx::AddEq(self2->s,self1->s);
HXDLIN( 251)				hx::AddEq(self2->x,self1->x);
HXDLIN( 251)				hx::AddEq(self2->y,self1->y);
HXDLIN( 251)				hx::AddEq(self2->z,self1->z);
HXDLIN( 251)				HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self3,"self") = self2;
HXDLIN( 251)				Float _hx_tmp2 = ((((self3->s * self3->s) + (self3->x * self3->x)) + (self3->y * self3->y)) + (self3->z * self3->z));
HXDLIN( 251)				HX_VARI( Float,length) = ::Math_obj::sqrt(_hx_tmp2);
HXDLIN( 251)				if ((length > ((Float)0.0))) {
HXLINE( 251)					HX_VARI( Float,k) = ((Float)((Float)1.0) / (Float)length);
HXDLIN( 251)					{
HXLINE( 251)						hx::MultEq(self3->s,k);
HXDLIN( 251)						hx::MultEq(self3->x,k);
HXDLIN( 251)						hx::MultEq(self3->y,k);
HXDLIN( 251)						hx::MultEq(self3->z,k);
            					}
            				}
HXDLIN( 251)				qC = self3;
            			}
            			else {
HXLINE( 251)				Float _hx_tmp3 = ::Math_obj::sin((((Float)0.5) * halfTheta));
HXDLIN( 251)				HX_VARI( Float,ta) = ((Float)_hx_tmp3 / (Float)sinHalfTheta);
HXDLIN( 251)				Float _hx_tmp4 = ::Math_obj::sin((((Float)0.5) * halfTheta));
HXDLIN( 251)				HX_VARI( Float,tb) = ((Float)_hx_tmp4 / (Float)sinHalfTheta);
HXDLIN( 251)				HX_VARI(  ::hxmath::math::QuaternionDefault,result) =  ::hxmath::math::QuaternionDefault_obj::__new((int)0,(int)0,(int)0,(int)0);
HXDLIN( 251)				Float _hx_tmp5 = (qA->x * ta);
HXDLIN( 251)				Float _hx_tmp6 = (qB->x * tb);
HXDLIN( 251)				result->x = (_hx_tmp5 + _hx_tmp6);
HXDLIN( 251)				Float _hx_tmp7 = (qA->y * ta);
HXDLIN( 251)				Float _hx_tmp8 = (qB->y * tb);
HXDLIN( 251)				result->y = (_hx_tmp7 + _hx_tmp8);
HXDLIN( 251)				Float _hx_tmp9 = (qA->z * ta);
HXDLIN( 251)				Float _hx_tmp10 = (qB->z * tb);
HXDLIN( 251)				result->z = (_hx_tmp9 + _hx_tmp10);
HXDLIN( 251)				Float _hx_tmp11 = (qA->s * ta);
HXDLIN( 251)				Float _hx_tmp12 = (qB->s * tb);
HXDLIN( 251)				result->s = (_hx_tmp11 + _hx_tmp12);
HXDLIN( 251)				qC = result;
            			}
            		}
HXLINE( 253)		Float _hx_tmp13 = ((((qA->s * qC->s) + (qA->x * qC->x)) + (qA->y * qC->y)) + (qA->z * qC->z));
HXDLIN( 253)		Float _hx_tmp14 = ((((qA->s * qA->s) + (qA->x * qA->x)) + (qA->y * qA->y)) + (qA->z * qA->z));
HXDLIN( 253)		Float _hx_tmp15 = ::Math_obj::sqrt(_hx_tmp14);
HXDLIN( 253)		HX_VARI_NAME(  ::hxmath::math::QuaternionDefault,self4,"self") = qC;
HXDLIN( 253)		Float _hx_tmp16 = ((((self4->s * self4->s) + (self4->x * self4->x)) + (self4->y * self4->y)) + (self4->z * self4->z));
HXDLIN( 253)		Float _hx_tmp17 = ::Math_obj::sqrt(_hx_tmp16);
HXDLIN( 253)		Float _hx_tmp18 = ::Math_obj::acos(((Float)_hx_tmp13 / (Float)(_hx_tmp15 * _hx_tmp17)));
HXDLIN( 253)		this->assertTrue(((((Float)2.0) * _hx_tmp18) <= ((Float)1e-2)),hx::SourceInfo(HX_("Test3D.hx",fb,08,2d,62),253,HX_("test.Test3D",3f,be,21,72),HX_("testSlerpSmallAngleStability",25,84,e6,0f)));
            	}


HX_DEFINE_DYNAMIC_FUNC0(Test3D_obj,testSlerpSmallAngleStability,(void))


Test3D_obj::Test3D_obj()
{
}

hx::Val Test3D_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 10:
		if (HX_FIELD_EQ(inName,"testAddSub") ) { return hx::Val( testAddSub_dyn()); }
		if (HX_FIELD_EQ(inName,"testAngles") ) { return hx::Val( testAngles_dyn()); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"testReflect") ) { return hx::Val( testReflect_dyn()); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"testMatrixMult") ) { return hx::Val( testMatrixMult_dyn()); }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"testAxialRotation") ) { return hx::Val( testAxialRotation_dyn()); }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"testOrthoNormalize") ) { return hx::Val( testOrthoNormalize_dyn()); }
		break;
	case 20:
		if (HX_FIELD_EQ(inName,"testProjectOntoPlane") ) { return hx::Val( testProjectOntoPlane_dyn()); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"testQuaternionInverse") ) { return hx::Val( testQuaternionInverse_dyn()); }
		if (HX_FIELD_EQ(inName,"testSlerpMonotonicity") ) { return hx::Val( testSlerpMonotonicity_dyn()); }
		break;
	case 22:
		if (HX_FIELD_EQ(inName,"testQuaternionToMatrix") ) { return hx::Val( testQuaternionToMatrix_dyn()); }
		if (HX_FIELD_EQ(inName,"testMatrixFrameInverse") ) { return hx::Val( testMatrixFrameInverse_dyn()); }
		if (HX_FIELD_EQ(inName,"testSlerpMidpointAngle") ) { return hx::Val( testSlerpMidpointAngle_dyn()); }
		break;
	case 26:
		if (HX_FIELD_EQ(inName,"testCrossProductPrecedence") ) { return hx::Val( testCrossProductPrecedence_dyn()); }
		break;
	case 28:
		if (HX_FIELD_EQ(inName,"testSlerpLargeAngleStability") ) { return hx::Val( testSlerpLargeAngleStability_dyn()); }
		if (HX_FIELD_EQ(inName,"testSlerpSmallAngleStability") ) { return hx::Val( testSlerpSmallAngleStability_dyn()); }
	}
	return super::__Field(inName,inCallProp);
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Test3D_obj_sMemberStorageInfo = 0;
static hx::StaticInfo *Test3D_obj_sStaticStorageInfo = 0;
#endif

static ::String Test3D_obj_sMemberFields[] = {
	HX_HCSTRING("testMatrixMult","\xc3","\xa5","\x58","\x23"),
	HX_HCSTRING("testAddSub","\xd1","\xff","\xfc","\xb7"),
	HX_HCSTRING("testCrossProductPrecedence","\x6b","\x14","\xf7","\x15"),
	HX_HCSTRING("testAxialRotation","\xa9","\xdb","\x2a","\x2f"),
	HX_HCSTRING("testQuaternionToMatrix","\x4c","\x5e","\xe0","\x35"),
	HX_HCSTRING("testMatrixFrameInverse","\xd6","\xd3","\x6d","\xc7"),
	HX_HCSTRING("testQuaternionInverse","\x80","\xe1","\x7a","\xc3"),
	HX_HCSTRING("testOrthoNormalize","\x27","\xe1","\x2c","\xf2"),
	HX_HCSTRING("testAngles","\x32","\x5b","\x0d","\x7c"),
	HX_HCSTRING("testReflect","\x0b","\x72","\xf2","\xa5"),
	HX_HCSTRING("testProjectOntoPlane","\xfb","\xed","\x9e","\x04"),
	HX_HCSTRING("testSlerpMidpointAngle","\x13","\x1f","\x4d","\x70"),
	HX_HCSTRING("testSlerpMonotonicity","\x1c","\xbd","\x01","\x5e"),
	HX_HCSTRING("testSlerpLargeAngleStability","\x19","\x8a","\x3a","\xcb"),
	HX_HCSTRING("testSlerpSmallAngleStability","\x25","\x84","\xe6","\x0f"),
	::String(null()) };

static void Test3D_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Test3D_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Test3D_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Test3D_obj::__mClass,"__mClass");
};

#endif

hx::Class Test3D_obj::__mClass;

void Test3D_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("test.Test3D","\x3f","\xbe","\x21","\x72");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = Test3D_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(Test3D_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< Test3D_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Test3D_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Test3D_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Test3D_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace test
