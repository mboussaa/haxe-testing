<?php

// Generated by Haxe 3.3.0
class hxmath_math__Vector4_Vector4_Impl_ {
	public function __construct(){}
	static $elementCount = 4;
	static function _new($x, $y, $z, $w) {
		$this1 = new hxmath_math_Vector4Default($x, $y, $z, $w);
		return $this1;
	}
	static function fromArray($rawData) {
		if($rawData->length !== 4) {
			throw new HException("Invalid rawData.");
		}
		$this1 = new hxmath_math_Vector4Default($rawData[0], $rawData[1], $rawData[2], $rawData[3]);
		return $this1;
	}
	static function fromVector4Shape($other) {
		$this1 = new hxmath_math_Vector4Default($other->x, $other->y, $other->z, $other->w);
		return $this1;
	}
	static function dot($a, $b) {
		return $a->x * $b->x + $a->y * $b->y + $a->z * $b->z + $a->w * $b->w;
	}
	static function multiply($a, $s) {
		$this1 = new hxmath_math_Vector4Default($a->x, $a->y, $a->z, $a->w);
		$self = $this1;
		$self->x *= $s;
		$self->y *= $s;
		$self->z *= $s;
		$self->w *= $s;
		return $self;
	}
	static function divide($a, $s) {
		$this1 = new hxmath_math_Vector4Default($a->x, $a->y, $a->z, $a->w);
		$self = $this1;
		$self->x /= $s;
		$self->y /= $s;
		$self->z /= $s;
		$self->w /= $s;
		return $self;
	}
	static function add($a, $b) {
		$this1 = new hxmath_math_Vector4Default($a->x, $a->y, $a->z, $a->w);
		$self = $this1;
		$self->x += $b->x;
		$self->y += $b->y;
		$self->z += $b->z;
		$self->w += $b->w;
		return $self;
	}
	static function subtract($a, $b) {
		$this1 = new hxmath_math_Vector4Default($a->x, $a->y, $a->z, $a->w);
		$self = $this1;
		$self->x -= $b->x;
		$self->y -= $b->y;
		$self->z -= $b->z;
		$self->w -= $b->w;
		return $self;
	}
	static function negate($a) {
		$this1 = new hxmath_math_Vector4Default(-$a->x, -$a->y, -$a->z, -$a->w);
		return $this1;
	}
	static function equals($a, $b) {
		$tmp = null;
		if($a === null) {
			$tmp = $b === null;
		} else {
			$tmp = false;
		}
		if(!$tmp) {
			$tmp1 = null;
			$tmp2 = null;
			$tmp3 = null;
			$tmp4 = null;
			if($a !== null) {
				$tmp4 = $b !== null;
			} else {
				$tmp4 = false;
			}
			if($tmp4) {
				$tmp3 = $a->x === $b->x;
			} else {
				$tmp3 = false;
			}
			if($tmp3) {
				$tmp2 = $a->y === $b->y;
			} else {
				$tmp2 = false;
			}
			if($tmp2) {
				$tmp1 = $a->z === $b->z;
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				return $a->w === $b->w;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static function lerp($a, $b, $t) {
		$this1 = new hxmath_math_Vector4Default((1.0 - $t) * $a->x + $t * $b->x, (1.0 - $t) * $a->y + $t * $b->y, (1.0 - $t) * $a->z + $t * $b->z, (1.0 - $t) * $a->w + $t * $b->w);
		return $this1;
	}
	static function max($a, $b) {
		$this1 = new hxmath_math_Vector4Default($a->x, $a->y, $a->z, $a->w);
		$self = $this1;
		$self->x = Math::max($self->x, $b->x);
		$self->y = Math::max($self->y, $b->y);
		$self->z = Math::max($self->z, $b->z);
		$self->w = Math::max($self->w, $b->w);
		return $self;
	}
	static function min($a, $b) {
		$this1 = new hxmath_math_Vector4Default($a->x, $a->y, $a->z, $a->w);
		$self = $this1;
		$self->x = Math::min($self->x, $b->x);
		$self->y = Math::min($self->y, $b->y);
		$self->z = Math::min($self->z, $b->z);
		$self->w = Math::min($self->w, $b->w);
		return $self;
	}
	static function project($a, $b) {
		$this1 = new hxmath_math_Vector4Default($a->x, $a->y, $a->z, $a->w);
		$self = $this1;
		$s = ($self->x * $b->x + $self->y * $b->y + $self->z * $b->z + $self->w * $b->w) / ($b->x * $b->x + $b->y * $b->y + $b->z * $b->z + $b->w * $b->w);
		{
			$_g = 0;
			while($_g < 4) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $b->x;
					}break;
					case 1:{
						$tmp = $b->y;
					}break;
					case 2:{
						$tmp = $b->z;
					}break;
					case 3:{
						$tmp = $b->w;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = $tmp;
					switch($i) {
					case 0:{
						$self->x = $value;
					}break;
					case 1:{
						$self->y = $value;
					}break;
					case 2:{
						$self->z = $value;
					}break;
					case 3:{
						$self->w = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
		{
			$self->x *= $s;
			$self->y *= $s;
			$self->z *= $s;
			$self->w *= $s;
		}
		return $self;
	}
	static function set($this1, $x, $y, $z, $w) {
		$self = $this1;
		$self->x = $x;
		$self->y = $y;
		$self->z = $z;
		$self->w = $w;
		return $self;
	}
	static function multiplyWith($this1, $s) {
		$self = $this1;
		$self->x *= $s;
		$self->y *= $s;
		$self->z *= $s;
		$self->w *= $s;
		return $self;
	}
	static function divideWith($this1, $s) {
		$self = $this1;
		$self->x /= $s;
		$self->y /= $s;
		$self->z /= $s;
		$self->w /= $s;
		return $self;
	}
	static function addWith($this1, $a) {
		$self = $this1;
		$self->x += $a->x;
		$self->y += $a->y;
		$self->z += $a->z;
		$self->w += $a->w;
		return $self;
	}
	static function subtractWith($this1, $a) {
		$self = $this1;
		$self->x -= $a->x;
		$self->y -= $a->y;
		$self->z -= $a->z;
		$self->w -= $a->w;
		return $self;
	}
	static function maxWith($this1, $a) {
		$self = $this1;
		$self->x = Math::max($self->x, $a->x);
		$self->y = Math::max($self->y, $a->y);
		$self->z = Math::max($self->z, $a->z);
		$self->w = Math::max($self->w, $a->w);
		return $self;
	}
	static function minWith($this1, $a) {
		$self = $this1;
		$self->x = Math::min($self->x, $a->x);
		$self->y = Math::min($self->y, $a->y);
		$self->z = Math::min($self->z, $a->z);
		$self->w = Math::min($self->w, $a->w);
		return $self;
	}
	static function projectOnto($this1, $a) {
		$self = $this1;
		$s = ($self->x * $a->x + $self->y * $a->y + $self->z * $a->z + $self->w * $a->w) / ($a->x * $a->x + $a->y * $a->y + $a->z * $a->z + $a->w * $a->w);
		{
			$_g = 0;
			while($_g < 4) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $a->x;
					}break;
					case 1:{
						$tmp = $a->y;
					}break;
					case 2:{
						$tmp = $a->z;
					}break;
					case 3:{
						$tmp = $a->w;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = $tmp;
					switch($i) {
					case 0:{
						$self->x = $value;
					}break;
					case 1:{
						$self->y = $value;
					}break;
					case 2:{
						$self->z = $value;
					}break;
					case 3:{
						$self->w = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
		{
			$self->x *= $s;
			$self->y *= $s;
			$self->z *= $s;
			$self->w *= $s;
		}
		return $self;
	}
	static function copyTo($this1, $target) {
		$self = $this1;
		{
			$_g = 0;
			while($_g < 4) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $self->x;
					}break;
					case 1:{
						$tmp = $self->y;
					}break;
					case 2:{
						$tmp = $self->z;
					}break;
					case 3:{
						$tmp = $self->w;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = $tmp;
					switch($i) {
					case 0:{
						$target->x = $value;
					}break;
					case 1:{
						$target->y = $value;
					}break;
					case 2:{
						$target->z = $value;
					}break;
					case 3:{
						$target->w = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
	}
	static function copyToShape($this1, $target) {
		$self = $this1;
		$target->x = $self->x;
		$target->y = $self->y;
		$target->z = $self->z;
		$target->w = $self->w;
	}
	static function copyFromShape($this1, $source) {
		$self = $this1;
		$self->x = $source->x;
		$self->y = $source->y;
		$self->z = $source->z;
		$self->w = $source->w;
	}
	static function hclone($this1) {
		$self = $this1;
		$this2 = new hxmath_math_Vector4Default($self->x, $self->y, $self->z, $self->w);
		return $this2;
	}
	static function getArrayElement($this1, $i) {
		$self = $this1;
		switch($i) {
		case 0:{
			return $self->x;
		}break;
		case 1:{
			return $self->y;
		}break;
		case 2:{
			return $self->z;
		}break;
		case 3:{
			return $self->w;
		}break;
		default:{
			throw new HException("Invalid element");
		}break;
		}
	}
	static function setArrayElement($this1, $i, $value) {
		$self = $this1;
		switch($i) {
		case 0:{
			return $self->x = $value;
		}break;
		case 1:{
			return $self->y = $value;
		}break;
		case 2:{
			return $self->z = $value;
		}break;
		case 3:{
			return $self->w = $value;
		}break;
		default:{
			throw new HException("Invalid element");
		}break;
		}
	}
	static function applyScalarFunc($this1, $func) {
		$self = $this1;
		{
			$_g = 0;
			while($_g < 4) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $self->x;
					}break;
					case 1:{
						$tmp = $self->y;
					}break;
					case 2:{
						$tmp = $self->z;
					}break;
					case 3:{
						$tmp = $self->w;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = call_user_func_array($func, array($tmp));
					switch($i) {
					case 0:{
						$self->x = $value;
					}break;
					case 1:{
						$self->y = $value;
					}break;
					case 2:{
						$self->z = $value;
					}break;
					case 3:{
						$self->w = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
		return $self;
	}
	static function distanceTo($this1, $b) {
		$self = $this1;
		$this2 = new hxmath_math_Vector4Default($self->x, $self->y, $self->z, $self->w);
		$self1 = $this2;
		$self1->x -= $b->x;
		$self1->y -= $b->y;
		$self1->z -= $b->z;
		$self1->w -= $b->w;
		$self2 = $self1;
		$tmp = $self2->x * $self2->x + $self2->y * $self2->y + $self2->z * $self2->z + $self2->w * $self2->w;
		return Math::sqrt($tmp);
	}
	static function normalize($this1) {
		$self = $this1;
		$tmp = $self->x * $self->x + $self->y * $self->y + $self->z * $self->z + $self->w * $self->w;
		$length = Math::sqrt($tmp);
		if($length > 0.0) {
			$self->x /= $length;
			$self->y /= $length;
			$self->z /= $length;
			$self->w /= $length;
		}
		return $self;
	}
	static function normalizeTo($this1, $newLength) {
		$self = $this1;
		{
			$tmp = $self->x * $self->x + $self->y * $self->y + $self->z * $self->z + $self->w * $self->w;
			$length = Math::sqrt($tmp);
			if($length > 0.0) {
				$self->x /= $length;
				$self->y /= $length;
				$self->z /= $length;
				$self->w /= $length;
			}
		}
		{
			$self->x *= $newLength;
			$self->y *= $newLength;
			$self->z *= $newLength;
			$self->w *= $newLength;
		}
		return $self;
	}
	static function clamp($this1, $min, $max) {
		$self = $this1;
		$tmp = $self->x * $self->x + $self->y * $self->y + $self->z * $self->z + $self->w * $self->w;
		$length = Math::sqrt($tmp);
		if($length < $min) {
			{
				$tmp1 = $self->x * $self->x + $self->y * $self->y + $self->z * $self->z + $self->w * $self->w;
				$length1 = Math::sqrt($tmp1);
				if($length1 > 0.0) {
					$self->x /= $length1;
					$self->y /= $length1;
					$self->z /= $length1;
					$self->w /= $length1;
				}
			}
			{
				$self->x *= $min;
				$self->y *= $min;
				$self->z *= $min;
				$self->w *= $min;
			}
		} else {
			if($length > $max) {
				{
					$tmp2 = $self->x * $self->x + $self->y * $self->y + $self->z * $self->z + $self->w * $self->w;
					$length2 = Math::sqrt($tmp2);
					if($length2 > 0.0) {
						$self->x /= $length2;
						$self->y /= $length2;
						$self->z /= $length2;
						$self->w /= $length2;
					}
				}
				{
					$self->x *= $max;
					$self->y *= $max;
					$self->z *= $max;
					$self->w *= $max;
				}
			}
		}
		return $self;
	}
	static function get_length($this1) {
		$self = $this1;
		$tmp = $self->x * $self->x + $self->y * $self->y + $self->z * $self->z + $self->w * $self->w;
		return Math::sqrt($tmp);
	}
	static function get_lengthSq($this1) {
		$self = $this1;
		return $self->x * $self->x + $self->y * $self->y + $self->z * $self->z + $self->w * $self->w;
	}
	static function get_zero() {
		$this1 = new hxmath_math_Vector4Default(0.0, 0.0, 0.0, 0.0);
		return $this1;
	}
	static function get_xAxis() {
		$this1 = new hxmath_math_Vector4Default(1.0, 0.0, 0.0, 0.0);
		return $this1;
	}
	static function get_yAxis() {
		$this1 = new hxmath_math_Vector4Default(0.0, 1.0, 0.0, 0.0);
		return $this1;
	}
	static function get_zAxis() {
		$this1 = new hxmath_math_Vector4Default(0.0, 0.0, 1.0, 0.0);
		return $this1;
	}
	static function get_wAxis() {
		$this1 = new hxmath_math_Vector4Default(0.0, 0.0, 0.0, 1.0);
		return $this1;
	}
	static $__properties__ = array("get_lengthSq" => "get_lengthSq","get_length" => "get_length","get_wAxis" => "get_wAxis","get_zAxis" => "get_zAxis","get_yAxis" => "get_yAxis","get_xAxis" => "get_xAxis","get_zero" => "get_zero");
	function __toString() { return 'hxmath.math._Vector4.Vector4_Impl_'; }
}
