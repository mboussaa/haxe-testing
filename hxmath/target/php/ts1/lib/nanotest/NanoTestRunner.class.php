<?php

// Generated by Haxe 3.3.0
class nanotest_NanoTestRunner {
	public function __construct($printError = null) {
		if(!isset($this->print)) $this->print = array(new _hx_lambda(array(&$this), "nanotest_NanoTestRunner_0"), 'execute');
		if(!php_Boot::$skip_constructor) {
		$this->cases = (new _hx_array(array()));
		if($printError === null) {
			$this->printError = (isset(nanotest_NanoTestRunner::$warning) ? nanotest_NanoTestRunner::$warning: array("nanotest_NanoTestRunner", "warning"));
		} else {
			$this->printError = $printError;
		}
	}}
	public $cases;
	public function hprint($d) {
		haxe_unit_TestRunner::hprint($d);
	}
	public $printError;

	public $hprint = null;
	public function add($testCase) {
		$this->cases->push($testCase);
	}
	public function run() {
		$results = (new _hx_array(array()));
		{
			$_g = 0;
			$_g1 = $this->cases;
			while($_g < $_g1->length) {
				$c = $_g1[$_g];
				++$_g;
				$rs = $c->run((isset($this->{"print"}) ? $this->{"print"}: array($this, "hprint")));
				{
					$_g2 = 0;
					while($_g2 < $rs->length) {
						$r = $rs[$_g2];
						++$_g2;
						$results->push($r);
						unset($r);
					}
					unset($_g2);
				}
				unset($rs,$c);
			}
		}
		$failures = 0;
		{
			$_g3 = 0;
			while($_g3 < $results->length) {
				$result = $results[$_g3];
				++$_g3;
				$tmp = $result->failed;
				if($tmp) {
					$this->hprint("* " . _hx_string_or_null($result->className) . "::" . _hx_string_or_null($result->method) . "()\x0A");
					{
						$_g11 = 0;
						$_g21 = $result->status;
						while($_g11 < $_g21->length) {
							$status = $_g21[$_g11];
							++$_g11;
							$tmp1 = $status->index;
							switch($tmp1) {
							case 0:{}break;
							case 1:{
								$this->printError("Test failed : " . _hx_string_or_null(_hx_deref($status)->params[0]), _hx_deref($status)->params[1]);
							}break;
							case 2:{
								$callStack = _hx_deref($status)->params[1];
								$message = _hx_deref($status)->params[0];
								{
									$first = true;
									{
										$_g31 = 0;
										while($_g31 < $callStack->length) {
											$item = $callStack[$_g31];
											++$_g31;
											$tmp2 = $item->index;
											switch($tmp2) {
											case 0:{
												$this->hprint("Called from" . " : a C function\x0A");
											}break;
											case 1:{
												$this->hprint("Called from" . " : module " . _hx_string_or_null(_hx_deref($item)->params[0]) . "\x0A");
											}break;
											case 2:{
												$posInfos = _hx_anonymous(array("fileName" => _hx_deref($item)->params[1], "lineNumber" => _hx_deref($item)->params[2], "className" => $result->className, "methodName" => $result->method));
												if($first) {
													$this->printError("exception thrown : " . _hx_string_or_null($message), $posInfos);
													$first = false;
												} else {
													$this->printError("Called from", $posInfos);
												}
											}break;
											case 3:{
												$this->hprint("Called from" . " : " . _hx_string_or_null(_hx_deref($item)->params[0]) . "." . _hx_string_or_null(_hx_deref($item)->params[1]) . "\x0A");
											}break;
											case 4:{
												$this->hprint("Called from" . " : local function #" . _hx_string_rec(_hx_deref($item)->params[0], "") . "\x0A");
											}break;
											}
											unset($tmp2,$item);
										}
									}
									if($first) {
										$this->printError("exception thrown : " . _hx_string_or_null($message), $result->testCase->posInfos);
									}
								}
							}break;
							}
							unset($tmp1,$status);
						}
						unset($_g21,$_g11);
					}
					$this->hprint("\x0A");
					++$failures;
				}
				unset($tmp,$result);
			}
		}
		if($failures === 0) {
			$this->hprint("OK ");
		} else {
			$this->hprint("FAILED ");
		}
		$tmp3 = _hx_string_rec($results->length, "") . " tests, " . _hx_string_rec($failures, "") . " failed, " . _hx_string_rec(($results->length - $failures), "");
		$this->hprint(_hx_string_or_null($tmp3) . " success\x0A");
		return $failures === 0;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function error($message, $position) {}
	static function warning($message, $position) {
		$tmp = nanotest_NanoTestRunner::fileFromPosInfos($position);
		$tmp1 = _hx_string_or_null($tmp) . ":" . _hx_string_rec($position->lineNumber, "") . ": " . _hx_string_or_null($message);
		haxe_unit_TestRunner::hprint(_hx_string_or_null($tmp1) . "\x0A");
	}
	static function fileFromPosInfos($posInfos) {
		if($posInfos->className === null) {
			return $posInfos->fileName;
		}
		if($posInfos->fileName === null) {
			return null;
		}
		$fsegs = _hx_deref(new EReg("\\\\|/", ""))->split($posInfos->fileName);
		if($fsegs->length > 1) {
			return $posInfos->fileName;
		}
		$f = $fsegs->pop();
		$tmp = strlen($f) - 3;
		$tmp1 = _hx_substr($f, $tmp, null);
		if($tmp1 !== ".hx") {
			return $posInfos->fileName;
		}
		$segs = _hx_explode(".", $posInfos->className);
		$segs->pop();
		$segs->push($f);
		return $segs->join("/");
	}
	static function posInfosToPosition($posInfos) {
		return _hx_anonymous(array("file" => $posInfos->fileName, "min" => 0, "max" => 0));
	}
	function __toString() { return 'nanotest.NanoTestRunner'; }
}
function nanotest_NanoTestRunner_0(&$__hx__this, $d) {
	{
		haxe_unit_TestRunner::hprint($d);
	}
}
