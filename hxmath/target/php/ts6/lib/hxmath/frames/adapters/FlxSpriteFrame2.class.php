<?php

// Generated by Haxe 3.3.0
class hxmath_frames_adapters_FlxSpriteFrame2 implements hxmath_frames_IFrame2{
	public function __construct($owner) {
		if(!php_Boot::$skip_constructor) {
		$this1 = new hxmath_math_Matrix3x2Default(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
		$this->internalMatrix = $this1;
		$this->owner = $owner;
	}}
	public $owner;
	public $internalMatrix;
	public function get_matrix() {
		$matrix = $this->internalMatrix;
		$this1 = new hxmath_math_Vector2Default($this->owner->x, $this->owner->y);
		$offset = $this1;
		$angleDegrees = $this->owner->angle;
		{
			$angle = Math::$PI / 180 * $angleDegrees;
			$s = Math::sin($angle);
			$c = Math::cos($angle);
			$matrix->a = $c;
			$matrix->b = -$s;
			$matrix->c = $s;
			$matrix->d = $c;
		}
		{
			$x = $offset->x;
			$y = $offset->y;
			$matrix->tx = $x;
			$matrix->ty = $y;
		}
		return $matrix;
	}
	public function get_offset() {
		$this1 = new hxmath_math_Vector2Default($this->owner->x, $this->owner->y);
		return $this1;
	}
	public function set_offset($offset) {
		$this->owner->set_x($offset->x);
		$this->owner->set_y($offset->y);
		return $offset;
	}
	public function get_angleDegrees() {
		return $this->owner->angle;
	}
	public function set_angleDegrees($angleDegrees) {
		return $this->owner->set_angle($angleDegrees);
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $__properties__ = array("set_angleDegrees" => "set_angleDegrees","get_angleDegrees" => "get_angleDegrees","set_offset" => "set_offset","get_offset" => "get_offset","get_matrix" => "get_matrix");
	function __toString() { return 'hxmath.frames.adapters.FlxSpriteFrame2'; }
}
