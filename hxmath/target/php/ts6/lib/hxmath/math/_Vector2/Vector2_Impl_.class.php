<?php

// Generated by Haxe 3.3.0
class hxmath_math__Vector2_Vector2_Impl_ {
	public function __construct(){}
	static $elementCount = 2;
	static function _new($x, $y) {
		$this1 = new hxmath_math_Vector2Default($x, $y);
		return $this1;
	}
	static function fromArray($rawData) {
		if($rawData->length !== 2) {
			throw new HException("Invalid rawData.");
		}
		$this1 = new hxmath_math_Vector2Default($rawData[0], $rawData[1]);
		return $this1;
	}
	static function fromPolar($angle, $radius) {
		$tmp = Math::cos($angle);
		$x = $radius * $tmp;
		$tmp1 = Math::sin($angle);
		$this1 = new hxmath_math_Vector2Default($x, $radius * $tmp1);
		return $this1;
	}
	static function fromVector2Shape($other) {
		$this1 = new hxmath_math_Vector2Default($other->x, $other->y);
		return $this1;
	}
	static function toIntVector2($this1, $func = null) {
		$self = $this1;
		$tmp = $func === null;
		if($tmp) {
			$func = (isset(Std::$int) ? Std::$int: array("Std", "int"));
		}
		$tmp1 = call_user_func_array($func, array($self->x));
		$tmp2 = call_user_func_array($func, array($self->y));
		return hxmath_math__IntVector2_IntVector2_Impl_::_new($tmp1, $tmp2);
	}
	static function dot($a, $b) {
		return $a->x * $b->x + $a->y * $b->y;
	}
	static function multiply($a, $s) {
		$this1 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self = $this1;
		$self->x *= $s;
		$self->y *= $s;
		return $self;
	}
	static function divide($a, $s) {
		$this1 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self = $this1;
		$self->x /= $s;
		$self->y /= $s;
		return $self;
	}
	static function add($a, $b) {
		$this1 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self = $this1;
		$self->x += $b->x;
		$self->y += $b->y;
		return $self;
	}
	static function subtract($a, $b) {
		$this1 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self = $this1;
		$self->x -= $b->x;
		$self->y -= $b->y;
		return $self;
	}
	static function negate($a) {
		$this1 = new hxmath_math_Vector2Default(-$a->x, -$a->y);
		return $this1;
	}
	static function equals($a, $b) {
		$tmp = null;
		if($a === null) {
			$tmp = $b === null;
		} else {
			$tmp = false;
		}
		if(!$tmp) {
			$tmp1 = null;
			$tmp2 = null;
			if($a !== null) {
				$tmp2 = $b !== null;
			} else {
				$tmp2 = false;
			}
			if($tmp2) {
				$tmp1 = $a->x === $b->x;
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				return $a->y === $b->y;
			} else {
				return false;
			}
		} else {
			return true;
		}
	}
	static function lerp($a, $b, $t) {
		$this1 = new hxmath_math_Vector2Default((1.0 - $t) * $a->x + $t * $b->x, (1.0 - $t) * $a->y + $t * $b->y);
		return $this1;
	}
	static function max($a, $b) {
		$this1 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self = $this1;
		$self->x = Math::max($self->x, $b->x);
		$self->y = Math::max($self->y, $b->y);
		return $self;
	}
	static function min($a, $b) {
		$this1 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self = $this1;
		$self->x = Math::min($self->x, $b->x);
		$self->y = Math::min($self->y, $b->y);
		return $self;
	}
	static function project($a, $b) {
		$this1 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self = $this1;
		$s = ($self->x * $b->x + $self->y * $b->y) / ($b->x * $b->x + $b->y * $b->y);
		{
			$_g = 0;
			while($_g < 2) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $b->x;
					}break;
					case 1:{
						$tmp = $b->y;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = $tmp;
					switch($i) {
					case 0:{
						$self->x = $value;
					}break;
					case 1:{
						$self->y = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
		{
			$self->x *= $s;
			$self->y *= $s;
		}
		return $self;
	}
	static function reflect($v, $normal) {
		$this1 = new hxmath_math_Vector2Default($v->x, $v->y);
		$self = $this1;
		$this2 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this2;
		$s = ($self1->x * $normal->x + $self1->y * $normal->y) / ($normal->x * $normal->x + $normal->y * $normal->y);
		{
			$_g = 0;
			while($_g < 2) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $normal->x;
					}break;
					case 1:{
						$tmp = $normal->y;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = $tmp;
					switch($i) {
					case 0:{
						$self1->x = $value;
					}break;
					case 1:{
						$self1->y = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
		{
			$self1->x *= $s;
			$self1->y *= $s;
		}
		{
			$self1->x *= 2.0;
			$self1->y *= 2.0;
		}
		{
			$self->x -= $self1->x;
			$self->y -= $self1->y;
		}
		return $self;
	}
	static function orthoNormalize($u, $v) {
		{
			$tmp = $u->x * $u->x + $u->y * $u->y;
			$length = Math::sqrt($tmp);
			if($length > 0.0) {
				$u->x /= $length;
				$u->y /= $length;
			}
		}
		{
			$this1 = new hxmath_math_Vector2Default($v->x, $v->y);
			$self = $this1;
			$s = ($self->x * $u->x + $self->y * $u->y) / ($u->x * $u->x + $u->y * $u->y);
			{
				$_g = 0;
				while($_g < 2) {
					$i = $_g++;
					{
						$tmp1 = null;
						switch($i) {
						case 0:{
							$tmp1 = $u->x;
						}break;
						case 1:{
							$tmp1 = $u->y;
						}break;
						default:{
							throw new HException("Invalid element");
						}break;
						}
						$value = $tmp1;
						switch($i) {
						case 0:{
							$self->x = $value;
						}break;
						case 1:{
							$self->y = $value;
						}break;
						default:{
							throw new HException("Invalid element");
						}break;
						}
						unset($value,$tmp1);
					}
					unset($i);
				}
			}
			{
				$self->x *= $s;
				$self->y *= $s;
			}
			$v->x -= $self->x;
			$v->y -= $self->y;
		}
		{
			$tmp2 = $v->x * $v->x + $v->y * $v->y;
			$length1 = Math::sqrt($tmp2);
			if($length1 > 0.0) {
				$v->x /= $length1;
				$v->y /= $length1;
			}
		}
	}
	static function set($this1, $x, $y) {
		$self = $this1;
		$self->x = $x;
		$self->y = $y;
		return $self;
	}
	static function multiplyWith($this1, $s) {
		$self = $this1;
		$self->x *= $s;
		$self->y *= $s;
		return $self;
	}
	static function divideWith($this1, $s) {
		$self = $this1;
		$self->x /= $s;
		$self->y /= $s;
		return $self;
	}
	static function addWith($this1, $a) {
		$self = $this1;
		$self->x += $a->x;
		$self->y += $a->y;
		return $self;
	}
	static function subtractWith($this1, $a) {
		$self = $this1;
		$self->x -= $a->x;
		$self->y -= $a->y;
		return $self;
	}
	static function maxWith($this1, $a) {
		$self = $this1;
		$self->x = Math::max($self->x, $a->x);
		$self->y = Math::max($self->y, $a->y);
		return $self;
	}
	static function minWith($this1, $a) {
		$self = $this1;
		$self->x = Math::min($self->x, $a->x);
		$self->y = Math::min($self->y, $a->y);
		return $self;
	}
	static function projectOnto($this1, $a) {
		$self = $this1;
		$s = ($self->x * $a->x + $self->y * $a->y) / ($a->x * $a->x + $a->y * $a->y);
		{
			$_g = 0;
			while($_g < 2) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $a->x;
					}break;
					case 1:{
						$tmp = $a->y;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = $tmp;
					switch($i) {
					case 0:{
						$self->x = $value;
					}break;
					case 1:{
						$self->y = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
		{
			$self->x *= $s;
			$self->y *= $s;
		}
		return $self;
	}
	static function reflectBy($this1, $normal) {
		$self = $this1;
		$this2 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this2;
		$s = ($self1->x * $normal->x + $self1->y * $normal->y) / ($normal->x * $normal->x + $normal->y * $normal->y);
		{
			$_g = 0;
			while($_g < 2) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $normal->x;
					}break;
					case 1:{
						$tmp = $normal->y;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = $tmp;
					switch($i) {
					case 0:{
						$self1->x = $value;
					}break;
					case 1:{
						$self1->y = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
		{
			$self1->x *= $s;
			$self1->y *= $s;
		}
		{
			$self1->x *= 2.0;
			$self1->y *= 2.0;
		}
		{
			$self->x -= $self1->x;
			$self->y -= $self1->y;
		}
		return $self;
	}
	static function copyTo($this1, $target) {
		$self = $this1;
		{
			$_g = 0;
			while($_g < 2) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $self->x;
					}break;
					case 1:{
						$tmp = $self->y;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = $tmp;
					switch($i) {
					case 0:{
						$target->x = $value;
					}break;
					case 1:{
						$target->y = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
	}
	static function copyToShape($this1, $target) {
		$self = $this1;
		$target->x = $self->x;
		$target->y = $self->y;
	}
	static function copyFromShape($this1, $source) {
		$self = $this1;
		$self->x = $source->x;
		$self->y = $source->y;
	}
	static function hclone($this1) {
		$self = $this1;
		$this2 = new hxmath_math_Vector2Default($self->x, $self->y);
		return $this2;
	}
	static function getArrayElement($this1, $i) {
		$self = $this1;
		switch($i) {
		case 0:{
			return $self->x;
		}break;
		case 1:{
			return $self->y;
		}break;
		default:{
			throw new HException("Invalid element");
		}break;
		}
	}
	static function setArrayElement($this1, $i, $value) {
		$self = $this1;
		switch($i) {
		case 0:{
			return $self->x = $value;
		}break;
		case 1:{
			return $self->y = $value;
		}break;
		default:{
			throw new HException("Invalid element");
		}break;
		}
	}
	static function applyNegate($this1) {
		$self = $this1;
		$self->x = -$self->x;
		$self->y = -$self->y;
		return $self;
	}
	static function applyScalarFunc($this1, $func) {
		$self = $this1;
		{
			$_g = 0;
			while($_g < 2) {
				$i = $_g++;
				{
					$tmp = null;
					switch($i) {
					case 0:{
						$tmp = $self->x;
					}break;
					case 1:{
						$tmp = $self->y;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					$value = call_user_func_array($func, array($tmp));
					switch($i) {
					case 0:{
						$self->x = $value;
					}break;
					case 1:{
						$self->y = $value;
					}break;
					default:{
						throw new HException("Invalid element");
					}break;
					}
					unset($value,$tmp);
				}
				unset($i);
			}
		}
		return $self;
	}
	static function angleWith($this1, $b) {
		$self = $this1;
		$tmp = $self->x * $b->x + $self->y * $b->y;
		$tmp1 = $self->x * $self->x + $self->y * $self->y;
		$tmp2 = Math::sqrt($tmp1);
		$tmp3 = $b->x * $b->x + $b->y * $b->y;
		$tmp4 = Math::sqrt($tmp3);
		return Math::acos($tmp / ($tmp2 * $tmp4));
	}
	static function signedAngleWith($this1, $b) {
		$self = $this1;
		$x = $self->x * $b->y - $b->x * $self->y;
		$tmp = null;
		$tmp1 = Math::abs($x);
		if($tmp1 < 0) {
			$tmp = 0;
		} else {
			if($x <= 0) {
				$tmp = -1;
			} else {
				$tmp = 1;
			}
		}
		$tmp2 = $self->x * $b->x + $self->y * $b->y;
		$tmp3 = $self->x * $self->x + $self->y * $self->y;
		$tmp4 = Math::sqrt($tmp3);
		$tmp5 = $b->x * $b->x + $b->y * $b->y;
		$tmp6 = Math::sqrt($tmp5);
		$tmp7 = Math::acos($tmp2 / ($tmp4 * $tmp6));
		return $tmp * $tmp7;
	}
	static function distanceTo($this1, $b) {
		$self = $this1;
		$this2 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this2;
		$self1->x -= $b->x;
		$self1->y -= $b->y;
		$self2 = $self1;
		$tmp = $self2->x * $self2->x + $self2->y * $self2->y;
		return Math::sqrt($tmp);
	}
	static function normalize($this1) {
		$self = $this1;
		$tmp = $self->x * $self->x + $self->y * $self->y;
		$length = Math::sqrt($tmp);
		if($length > 0.0) {
			$self->x /= $length;
			$self->y /= $length;
		}
		return $self;
	}
	static function normalizeTo($this1, $newLength) {
		$self = $this1;
		{
			$tmp = $self->x * $self->x + $self->y * $self->y;
			$length = Math::sqrt($tmp);
			if($length > 0.0) {
				$self->x /= $length;
				$self->y /= $length;
			}
		}
		{
			$self->x *= $newLength;
			$self->y *= $newLength;
		}
		return $self;
	}
	static function clamp($this1, $min, $max) {
		$self = $this1;
		$tmp = $self->x * $self->x + $self->y * $self->y;
		$length = Math::sqrt($tmp);
		if($length < $min) {
			{
				$tmp1 = $self->x * $self->x + $self->y * $self->y;
				$length1 = Math::sqrt($tmp1);
				if($length1 > 0.0) {
					$self->x /= $length1;
					$self->y /= $length1;
				}
			}
			{
				$self->x *= $min;
				$self->y *= $min;
			}
		} else {
			if($length > $max) {
				{
					$tmp2 = $self->x * $self->x + $self->y * $self->y;
					$length2 = Math::sqrt($tmp2);
					if($length2 > 0.0) {
						$self->x /= $length2;
						$self->y /= $length2;
					}
				}
				{
					$self->x *= $max;
					$self->y *= $max;
				}
			}
		}
		return $self;
	}
	static function rotate($this1, $angle, $pivot) {
		$self = $this1;
		Math::cos($angle);
		Math::sin($angle);
		$dx = $self->x - $pivot->x;
		$dy = $self->y - $pivot->y;
		$tmp = Math::cos($angle);
		$tmp1 = $dx * $tmp;
		$tmp2 = Math::sin($angle);
		$self->x = $tmp1 - $dy * $tmp2;
		$tmp3 = Math::sin($angle);
		$tmp4 = $dx * $tmp3;
		$tmp5 = Math::cos($angle);
		$self->y = $tmp4 + $dy * $tmp5;
		return $self;
	}
	static function rotateLeft($this1) {
		$self = $this1;
		$newX = -$self->y;
		$self->y = $self->x;
		$self->x = $newX;
		return $self;
	}
	static function rotateRight($this1) {
		$self = $this1;
		$newX = $self->y;
		$self->y = -$self->x;
		$self->x = $newX;
		return $self;
	}
	static function get_zero() {
		$this1 = new hxmath_math_Vector2Default(0.0, 0.0);
		return $this1;
	}
	static function get_xAxis() {
		$this1 = new hxmath_math_Vector2Default(1.0, 0.0);
		return $this1;
	}
	static function get_yAxis() {
		$this1 = new hxmath_math_Vector2Default(0.0, 1.0);
		return $this1;
	}
	static function get_length($this1) {
		$self = $this1;
		$tmp = $self->x * $self->x + $self->y * $self->y;
		return Math::sqrt($tmp);
	}
	static function get_lengthSq($this1) {
		$self = $this1;
		return $self->x * $self->x + $self->y * $self->y;
	}
	static function get_angle($this1) {
		$self = $this1;
		return Math::atan2($self->y, $self->x);
	}
	static function get_normal($this1) {
		$self = $this1;
		$this2 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this2;
		$tmp = $self1->x * $self1->x + $self1->y * $self1->y;
		$length = Math::sqrt($tmp);
		if($length > 0.0) {
			$self1->x /= $length;
			$self1->y /= $length;
		}
		return $self1;
	}
	static function get_rotatedLeft($this1) {
		$self = $this1;
		$this2 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this2;
		$newX = -$self1->y;
		$self1->y = $self1->x;
		$self1->x = $newX;
		return $self1;
	}
	static function get_rotatedRight($this1) {
		$self = $this1;
		$this2 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this2;
		$newX = $self1->y;
		$self1->y = -$self1->x;
		$self1->x = $newX;
		return $self1;
	}
	static $__properties__ = array("get_rotatedRight" => "get_rotatedRight","get_rotatedLeft" => "get_rotatedLeft","get_normal" => "get_normal","get_angle" => "get_angle","get_lengthSq" => "get_lengthSq","get_length" => "get_length","get_yAxis" => "get_yAxis","get_xAxis" => "get_xAxis","get_zero" => "get_zero");
	function __toString() { return 'hxmath.math._Vector2.Vector2_Impl_'; }
}
