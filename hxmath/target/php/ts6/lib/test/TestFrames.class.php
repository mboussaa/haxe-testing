<?php

// Generated by Haxe 3.3.0
class test_TestFrames extends test_MathTestCase {
	public function __construct($posInfos = null) { if(!php_Boot::$skip_constructor) {
		parent::__construct($posInfos);
	}}
	public function testFrame2Concat() {
		$this1 = new hxmath_math_Vector2Default(1.0, 1.0);
		$originA = $this1;
		$a = hxmath_frames__Frame2_Frame2_Impl_::_new($originA, 90.0);
		$this2 = new hxmath_math_Vector2Default(1.0, 0.0);
		$b = hxmath_frames__Frame2_Frame2_Impl_::_new($this2, 90.0);
		$tmp = $a->get_offset();
		$tmp1 = $a->get_angleDegrees();
		$self = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp, $tmp1);
		$this3 = $self->get_matrix();
		$self1 = $this3;
		$this4 = new hxmath_math_Matrix2x2Default($self1->a, $self1->b, $self1->c, $self1->d);
		$m = $this4;
		$v = $b->get_offset();
		$this5 = new hxmath_math_Vector2Default($m->a * $v->x + $m->b * $v->y, $m->c * $v->x + $m->d * $v->y);
		$a1 = $self->get_offset();
		$self2 = $this5;
		$self2->x += $a1->x;
		$self2->y += $a1->y;
		$tmp2 = $self->get_angleDegrees();
		$tmp3 = $b->get_angleDegrees();
		$x = $tmp2 + $tmp3;
		$tmp4 = null;
		if($x < 0) {
			$tmp4 = 360 - _hx_mod(-$x, 360);
		} else {
			$tmp4 = _hx_mod($x, 360);
		}
		$self->set_angleDegrees($tmp4);
		$self->set_offset($self2);
		$p = $b->get_offset();
		$m1 = $a->get_matrix();
		$this6 = new hxmath_math_Matrix2x2Default($m1->a, $m1->b, $m1->c, $m1->d);
		$m2 = $this6;
		$this7 = new hxmath_math_Vector2Default($m2->a * $p->x + $m2->b * $p->y, $m2->c * $p->x + $m2->d * $p->y);
		$a2 = $this7;
		$this8 = new hxmath_math_Vector2Default($m1->tx, $m1->ty);
		$b1 = $this8;
		$this9 = new hxmath_math_Vector2Default($a2->x, $a2->y);
		$self3 = $this9;
		$self3->x += $b1->x;
		$self3->y += $b1->y;
		$this10 = new hxmath_math_Vector2Default(0.0, 1.0);
		$a3 = $this10;
		$this11 = new hxmath_math_Vector2Default($a3->x, $a3->y);
		$self4 = $this11;
		$self4->x += $originA->x;
		$self4->y += $originA->y;
		$tmp5 = null;
		$tmp6 = null;
		if($self3 === null) {
			$tmp6 = $self4 === null;
		} else {
			$tmp6 = false;
		}
		if(!$tmp6) {
			$tmp7 = null;
			$tmp8 = null;
			if($self3 !== null) {
				$tmp8 = $self4 !== null;
			} else {
				$tmp8 = false;
			}
			if($tmp8) {
				$tmp7 = $self3->x === $self4->x;
			} else {
				$tmp7 = false;
			}
			if($tmp7) {
				$tmp5 = $self3->y === $self4->y;
			} else {
				$tmp5 = false;
			}
		} else {
			$tmp5 = true;
		}
		$this->assertTrue($tmp5, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 46, "className" => "test.TestFrames", "methodName" => "testFrame2Concat")));
		$a4 = $self->get_offset();
		$this12 = new hxmath_math_Vector2Default(0.0, 1.0);
		$a5 = $this12;
		$this13 = new hxmath_math_Vector2Default($a5->x, $a5->y);
		$self5 = $this13;
		$self5->x += $originA->x;
		$self5->y += $originA->y;
		$tmp9 = null;
		$tmp10 = null;
		if($a4 === null) {
			$tmp10 = $self5 === null;
		} else {
			$tmp10 = false;
		}
		if(!$tmp10) {
			$tmp11 = null;
			$tmp12 = null;
			if($a4 !== null) {
				$tmp12 = $self5 !== null;
			} else {
				$tmp12 = false;
			}
			if($tmp12) {
				$tmp11 = $a4->x === $self5->x;
			} else {
				$tmp11 = false;
			}
			if($tmp11) {
				$tmp9 = $a4->y === $self5->y;
			} else {
				$tmp9 = false;
			}
		} else {
			$tmp9 = true;
		}
		$this->assertTrue($tmp9, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 49, "className" => "test.TestFrames", "methodName" => "testFrame2Concat")));
		$tmp13 = $self->get_angleDegrees();
		$this->assertEquals($tmp13, 180.0, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 50, "className" => "test.TestFrames", "methodName" => "testFrame2Concat")));
		$m3 = $self->get_matrix();
		$this14 = new hxmath_math_Vector2Default(0.0, 0.0);
		$v1 = $this14;
		$this15 = new hxmath_math_Matrix2x2Default($m3->a, $m3->b, $m3->c, $m3->d);
		$m4 = $this15;
		$this16 = new hxmath_math_Vector2Default($m4->a * $v1->x + $m4->b * $v1->y, $m4->c * $v1->x + $m4->d * $v1->y);
		$a6 = $this16;
		$this17 = new hxmath_math_Vector2Default($m3->tx, $m3->ty);
		$b2 = $this17;
		$this18 = new hxmath_math_Vector2Default($a6->x, $a6->y);
		$self6 = $this18;
		$self6->x += $b2->x;
		$self6->y += $b2->y;
		$this19 = new hxmath_math_Vector2Default(0.0, 1.0);
		$a7 = $this19;
		$this20 = new hxmath_math_Vector2Default($a7->x, $a7->y);
		$self7 = $this20;
		$self7->x += $originA->x;
		$self7->y += $originA->y;
		$tmp14 = null;
		$tmp15 = null;
		if($self6 === null) {
			$tmp15 = $self7 === null;
		} else {
			$tmp15 = false;
		}
		if(!$tmp15) {
			$tmp16 = null;
			$tmp17 = null;
			if($self6 !== null) {
				$tmp17 = $self7 !== null;
			} else {
				$tmp17 = false;
			}
			if($tmp17) {
				$tmp16 = $self6->x === $self7->x;
			} else {
				$tmp16 = false;
			}
			if($tmp16) {
				$tmp14 = $self6->y === $self7->y;
			} else {
				$tmp14 = false;
			}
		} else {
			$tmp14 = true;
		}
		$this->assertTrue($tmp14, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 53, "className" => "test.TestFrames", "methodName" => "testFrame2Concat")));
	}
	public function testFrame3Concat() {
		$this1 = new hxmath_math_Vector3Default(1.0, 1.0, 0.0);
		$originA = $this1;
		$this2 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$axis = $this2;
		$angleRadians = Math::$PI / 180 * 90.0;
		$cosHalfAngle = Math::cos($angleRadians / 2.0);
		$sinHalfAngle = Math::sin($angleRadians / 2.0);
		$this3 = new hxmath_math_QuaternionDefault($cosHalfAngle, $sinHalfAngle * $axis->x, $sinHalfAngle * $axis->y, $sinHalfAngle * $axis->z);
		$a = hxmath_frames__Frame3_Frame3_Impl_::_new($originA, $this3);
		$this4 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$tmp = $this4;
		$this5 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$axis1 = $this5;
		$angleRadians1 = Math::$PI / 180 * 90.0;
		$cosHalfAngle1 = Math::cos($angleRadians1 / 2.0);
		$sinHalfAngle1 = Math::sin($angleRadians1 / 2.0);
		$this6 = new hxmath_math_QuaternionDefault($cosHalfAngle1, $sinHalfAngle1 * $axis1->x, $sinHalfAngle1 * $axis1->y, $sinHalfAngle1 * $axis1->z);
		$b = hxmath_frames__Frame3_Frame3_Impl_::_new($tmp, $this6);
		$tmp1 = $a->get_offset();
		$tmp2 = $a->get_orientation();
		$self = hxmath_frames__Frame3_Frame3_Impl_::_new($tmp1, $tmp2);
		$this7 = $self->get_orientation();
		$u = $b->get_offset();
		$self1 = $this7;
		$a1 = 2.0 * ($self1->x * $u->x + $self1->y * $u->y + $self1->z * $u->z);
		$b1 = $self1->s * $self1->s - $self1->x * $self1->x - $self1->y * $self1->y - $self1->z * $self1->z;
		$c = 2.0 * $self1->s;
		$this8 = new hxmath_math_Vector3Default($a1 * $self1->x + $b1 * $u->x + $c * ($self1->y * $u->z - $self1->z * $u->y), $a1 * $self1->y + $b1 * $u->y + $c * ($self1->z * $u->x - $self1->x * $u->z), $a1 * $self1->z + $b1 * $u->z + $c * ($self1->x * $u->y - $self1->y * $u->x));
		$a2 = $self->get_offset();
		$self2 = $this8;
		$self2->x += $a2->x;
		$self2->y += $a2->y;
		$self2->z += $a2->z;
		$a3 = $self->get_orientation();
		$b2 = $b->get_orientation();
		$this9 = new hxmath_math_QuaternionDefault($a3->s * $b2->s - $a3->x * $b2->x - $a3->y * $b2->y - $a3->z * $b2->z, $a3->s * $b2->x + $b2->s * $a3->x + $a3->y * $b2->z - $a3->z * $b2->y, $a3->s * $b2->y + $b2->s * $a3->y + $a3->z * $b2->x - $a3->x * $b2->z, $a3->s * $b2->z + $b2->s * $a3->z + $a3->x * $b2->y - $a3->y * $b2->x);
		$self3 = $this9;
		$tmp3 = $self3->s * $self3->s + $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
		$tmp4 = Math::sqrt($tmp3);
		$_g = 1.0 / $tmp4;
		$this10 = new hxmath_math_QuaternionDefault($self3->s, $self3->x, $self3->y, $self3->z);
		$self4 = $this10;
		$self4->s *= $_g;
		$self4->x *= $_g;
		$self4->y *= $_g;
		$self4->z *= $_g;
		$self->set_orientation($self4);
		$self->set_offset($self2);
		$p = $b->get_offset();
		$this11 = $a->get_orientation();
		$self5 = $this11;
		$a4 = 2.0 * ($self5->x * $p->x + $self5->y * $p->y + $self5->z * $p->z);
		$b3 = $self5->s * $self5->s - $self5->x * $self5->x - $self5->y * $self5->y - $self5->z * $self5->z;
		$c1 = 2.0 * $self5->s;
		$this12 = new hxmath_math_Vector3Default($a4 * $self5->x + $b3 * $p->x + $c1 * ($self5->y * $p->z - $self5->z * $p->y), $a4 * $self5->y + $b3 * $p->y + $c1 * ($self5->z * $p->x - $self5->x * $p->z), $a4 * $self5->z + $b3 * $p->z + $c1 * ($self5->x * $p->y - $self5->y * $p->x));
		$a5 = $a->get_offset();
		$self6 = $this12;
		$self6->x += $a5->x;
		$self6->y += $a5->y;
		$self6->z += $a5->z;
		$this13 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$a6 = $this13;
		$this14 = new hxmath_math_Vector3Default($a6->x, $a6->y, $a6->z);
		$self7 = $this14;
		$self7->x += $originA->x;
		$self7->y += $originA->y;
		$self7->z += $originA->z;
		$this15 = new hxmath_math_Vector3Default($self6->x, $self6->y, $self6->z);
		$self8 = $this15;
		$self8->x -= $self7->x;
		$self8->y -= $self7->y;
		$self8->z -= $self7->z;
		$self9 = $self8;
		$tmp5 = $self9->x * $self9->x + $self9->y * $self9->y + $self9->z * $self9->z;
		$tmp6 = Math::sqrt($tmp5);
		$this->assertApproxEquals(0.0, $tmp6, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 63, "className" => "test.TestFrames", "methodName" => "testFrame3Concat")));
		$a7 = $self->get_offset();
		$this16 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$a8 = $this16;
		$this17 = new hxmath_math_Vector3Default($a8->x, $a8->y, $a8->z);
		$self10 = $this17;
		$self10->x += $originA->x;
		$self10->y += $originA->y;
		$self10->z += $originA->z;
		$this18 = new hxmath_math_Vector3Default($a7->x, $a7->y, $a7->z);
		$self11 = $this18;
		$self11->x -= $self10->x;
		$self11->y -= $self10->y;
		$self11->z -= $self10->z;
		$self12 = $self11;
		$tmp7 = $self12->x * $self12->x + $self12->y * $self12->y + $self12->z * $self12->z;
		$tmp8 = Math::sqrt($tmp7);
		$this->assertApproxEquals(0.0, $tmp8, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 66, "className" => "test.TestFrames", "methodName" => "testFrame3Concat")));
		$a9 = $self->get_orientation();
		$this19 = new hxmath_math_QuaternionDefault(1, 0, 0, 0);
		$b4 = $this19;
		$tmp9 = $a9->s * $b4->s + $a9->x * $b4->x + $a9->y * $b4->y + $a9->z * $b4->z;
		$this->assertApproxEquals(0.0, $tmp9, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 69, "className" => "test.TestFrames", "methodName" => "testFrame3Concat")));
		$this20 = new hxmath_math_Vector3Default(0.0, 0.0, 0.0);
		$p1 = $this20;
		$this21 = $self->get_orientation();
		$self13 = $this21;
		$a10 = 2.0 * ($self13->x * $p1->x + $self13->y * $p1->y + $self13->z * $p1->z);
		$b5 = $self13->s * $self13->s - $self13->x * $self13->x - $self13->y * $self13->y - $self13->z * $self13->z;
		$c2 = 2.0 * $self13->s;
		$this22 = new hxmath_math_Vector3Default($a10 * $self13->x + $b5 * $p1->x + $c2 * ($self13->y * $p1->z - $self13->z * $p1->y), $a10 * $self13->y + $b5 * $p1->y + $c2 * ($self13->z * $p1->x - $self13->x * $p1->z), $a10 * $self13->z + $b5 * $p1->z + $c2 * ($self13->x * $p1->y - $self13->y * $p1->x));
		$a11 = $self->get_offset();
		$self14 = $this22;
		$self14->x += $a11->x;
		$self14->y += $a11->y;
		$self14->z += $a11->z;
		$this23 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$a12 = $this23;
		$this24 = new hxmath_math_Vector3Default($a12->x, $a12->y, $a12->z);
		$self15 = $this24;
		$self15->x += $originA->x;
		$self15->y += $originA->y;
		$self15->z += $originA->z;
		$this25 = new hxmath_math_Vector3Default($self14->x, $self14->y, $self14->z);
		$self16 = $this25;
		$self16->x -= $self15->x;
		$self16->y -= $self15->y;
		$self16->z -= $self15->z;
		$self17 = $self16;
		$tmp10 = $self17->x * $self17->x + $self17->y * $self17->y + $self17->z * $self17->z;
		$tmp11 = Math::sqrt($tmp10);
		$this->assertApproxEquals(0.0, $tmp11, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 72, "className" => "test.TestFrames", "methodName" => "testFrame3Concat")));
	}
	public function testFrame2LinearAffineTransform() {
		$this1 = new hxmath_math_Vector2Default(1.0, 1.0);
		$originA = $this1;
		$a = hxmath_frames__Frame2_Frame2_Impl_::_new($originA, 90.0);
		$this2 = new hxmath_math_Vector2Default(1.0, 1.0);
		$testInA = $this2;
		$this3 = $a->get_matrix();
		$self = $this3;
		$this4 = new hxmath_math_Matrix2x2Default($self->a, $self->b, $self->c, $self->d);
		$m = $this4;
		$this5 = new hxmath_math_Vector2Default($m->a * $testInA->x + $m->b * $testInA->y, $m->c * $testInA->x + $m->d * $testInA->y);
		$testLinearInOuter = $this5;
		$this6 = new hxmath_math_Vector2Default(-1.0, 1.0);
		$expectedLinearResult = $this6;
		$this7 = new hxmath_math_Vector2Default($testLinearInOuter->x, $testLinearInOuter->y);
		$self1 = $this7;
		$self1->x -= $expectedLinearResult->x;
		$self1->y -= $expectedLinearResult->y;
		$self2 = $self1;
		$tmp = $self2->x * $self2->x + $self2->y * $self2->y;
		$tmp1 = Math::sqrt($tmp);
		$this->assertApproxEquals($tmp1, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 95, "className" => "test.TestFrames", "methodName" => "testFrame2LinearAffineTransform")));
		$m1 = $a->get_matrix();
		$this8 = new hxmath_math_Matrix2x2Default($m1->a, $m1->b, $m1->c, $m1->d);
		$m2 = $this8;
		$this9 = new hxmath_math_Vector2Default($m2->a * $testInA->x + $m2->b * $testInA->y, $m2->c * $testInA->x + $m2->d * $testInA->y);
		$a1 = $this9;
		$this10 = new hxmath_math_Vector2Default($m1->tx, $m1->ty);
		$b = $this10;
		$this11 = new hxmath_math_Vector2Default($a1->x, $a1->y);
		$self3 = $this11;
		$self3->x += $b->x;
		$self3->y += $b->y;
		$this12 = new hxmath_math_Vector2Default($expectedLinearResult->x, $expectedLinearResult->y);
		$self4 = $this12;
		$self4->x += $originA->x;
		$self4->y += $originA->y;
		$this13 = new hxmath_math_Vector2Default($self3->x, $self3->y);
		$self5 = $this13;
		$self5->x -= $self4->x;
		$self5->y -= $self4->y;
		$self6 = $self5;
		$tmp2 = $self6->x * $self6->x + $self6->y * $self6->y;
		$tmp3 = Math::sqrt($tmp2);
		$this->assertApproxEquals($tmp3, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 100, "className" => "test.TestFrames", "methodName" => "testFrame2LinearAffineTransform")));
		$this14 = $a->get_matrix();
		$self7 = $this14;
		$this15 = new hxmath_math_Matrix2x2Default($self7->a, $self7->b, $self7->c, $self7->d);
		$self8 = $this15;
		$this16 = new hxmath_math_Vector2Default($self8->a * $testLinearInOuter->x + $self8->c * $testLinearInOuter->y, $self8->b * $testLinearInOuter->x + $self8->d * $testLinearInOuter->y);
		$testLinearBackToInner = $this16;
		$this17 = new hxmath_math_Vector2Default($testLinearBackToInner->x, $testLinearBackToInner->y);
		$self9 = $this17;
		$self9->x -= $testInA->x;
		$self9->y -= $testInA->y;
		$self10 = $self9;
		$tmp4 = $self10->x * $self10->x + $self10->y * $self10->y;
		$tmp5 = Math::sqrt($tmp4);
		$this->assertApproxEquals($tmp5, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 104, "className" => "test.TestFrames", "methodName" => "testFrame2LinearAffineTransform")));
		$this18 = $a->get_matrix();
		$self11 = $this18;
		$this19 = new hxmath_math_Matrix2x2Default($self11->a, $self11->b, $self11->c, $self11->d);
		$b1 = $a->get_offset();
		$this20 = new hxmath_math_Vector2Default($self3->x, $self3->y);
		$self12 = $this20;
		$self12->x -= $b1->x;
		$self12->y -= $b1->y;
		$self13 = $this19;
		$this21 = new hxmath_math_Vector2Default($self13->a * $self12->x + $self13->c * $self12->y, $self13->b * $self12->x + $self13->d * $self12->y);
		$testAffineBackToInner = $this21;
		$this22 = new hxmath_math_Vector2Default($testAffineBackToInner->x, $testAffineBackToInner->y);
		$self14 = $this22;
		$self14->x -= $testInA->x;
		$self14->y -= $testInA->y;
		$self15 = $self14;
		$tmp6 = $self15->x * $self15->x + $self15->y * $self15->y;
		$tmp7 = Math::sqrt($tmp6);
		$this->assertApproxEquals($tmp7, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 108, "className" => "test.TestFrames", "methodName" => "testFrame2LinearAffineTransform")));
	}
	public function testFrame2Inverse() {
		$this1 = new hxmath_math_Vector2Default(1.0, 1.0);
		$a = hxmath_frames__Frame2_Frame2_Impl_::_new($this1, 90.0);
		$this2 = $a->get_matrix();
		$self = $this2;
		$this3 = new hxmath_math_Matrix2x2Default($self->a, $self->b, $self->c, $self->d);
		$v = $a->get_offset();
		$self1 = $this3;
		$this4 = new hxmath_math_Vector2Default($self1->a * $v->x + $self1->c * $v->y, $self1->b * $v->x + $self1->d * $v->y);
		$self2 = $this4;
		$self2->x = -$self2->x;
		$self2->y = -$self2->y;
		$aInv = hxmath_frames__Frame2_Frame2_Impl_::_new($self2, -$a->get_angleDegrees());
		$tmp = $a->get_offset();
		$tmp1 = $a->get_angleDegrees();
		$self3 = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp, $tmp1);
		$this5 = $self3->get_matrix();
		$self4 = $this5;
		$this6 = new hxmath_math_Matrix2x2Default($self4->a, $self4->b, $self4->c, $self4->d);
		$m = $this6;
		$v1 = $aInv->get_offset();
		$this7 = new hxmath_math_Vector2Default($m->a * $v1->x + $m->b * $v1->y, $m->c * $v1->x + $m->d * $v1->y);
		$a1 = $self3->get_offset();
		$self5 = $this7;
		$self5->x += $a1->x;
		$self5->y += $a1->y;
		$tmp2 = $self3->get_angleDegrees();
		$tmp3 = $aInv->get_angleDegrees();
		$x = $tmp2 + $tmp3;
		$tmp4 = null;
		if($x < 0) {
			$tmp4 = 360 - _hx_mod(-$x, 360);
		} else {
			$tmp4 = _hx_mod($x, 360);
		}
		$self3->set_angleDegrees($tmp4);
		$self3->set_offset($self5);
		$a2 = $self3->get_offset();
		$this8 = new hxmath_math_Vector2Default(0.0, 0.0);
		$b = $this8;
		$this9 = new hxmath_math_Vector2Default($a2->x, $a2->y);
		$self6 = $this9;
		$self6->x -= $b->x;
		$self6->y -= $b->y;
		$self7 = $self6;
		$tmp5 = $self7->x * $self7->x + $self7->y * $self7->y;
		$tmp6 = Math::sqrt($tmp5);
		$this->assertApproxEquals($tmp6, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 121, "className" => "test.TestFrames", "methodName" => "testFrame2Inverse")));
		$tmp7 = $aInv->get_offset();
		$tmp8 = $aInv->get_angleDegrees();
		$self8 = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp7, $tmp8);
		$this10 = $self8->get_matrix();
		$self9 = $this10;
		$this11 = new hxmath_math_Matrix2x2Default($self9->a, $self9->b, $self9->c, $self9->d);
		$m1 = $this11;
		$v2 = $a->get_offset();
		$this12 = new hxmath_math_Vector2Default($m1->a * $v2->x + $m1->b * $v2->y, $m1->c * $v2->x + $m1->d * $v2->y);
		$a3 = $self8->get_offset();
		$self10 = $this12;
		$self10->x += $a3->x;
		$self10->y += $a3->y;
		$tmp9 = $self8->get_angleDegrees();
		$tmp10 = $a->get_angleDegrees();
		$x1 = $tmp9 + $tmp10;
		$tmp11 = null;
		if($x1 < 0) {
			$tmp11 = 360 - _hx_mod(-$x1, 360);
		} else {
			$tmp11 = _hx_mod($x1, 360);
		}
		$self8->set_angleDegrees($tmp11);
		$self8->set_offset($self10);
		$a4 = $self8->get_offset();
		$this13 = new hxmath_math_Vector2Default(0.0, 0.0);
		$b1 = $this13;
		$this14 = new hxmath_math_Vector2Default($a4->x, $a4->y);
		$self11 = $this14;
		$self11->x -= $b1->x;
		$self11->y -= $b1->y;
		$self12 = $self11;
		$tmp12 = $self12->x * $self12->x + $self12->y * $self12->y;
		$tmp13 = Math::sqrt($tmp12);
		$this->assertApproxEquals($tmp13, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 122, "className" => "test.TestFrames", "methodName" => "testFrame2Inverse")));
		$tmp14 = $a->get_offset();
		$tmp15 = $a->get_angleDegrees();
		$self13 = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp14, $tmp15);
		$this15 = $self13->get_matrix();
		$self14 = $this15;
		$this16 = new hxmath_math_Matrix2x2Default($self14->a, $self14->b, $self14->c, $self14->d);
		$m2 = $this16;
		$v3 = $aInv->get_offset();
		$this17 = new hxmath_math_Vector2Default($m2->a * $v3->x + $m2->b * $v3->y, $m2->c * $v3->x + $m2->d * $v3->y);
		$a5 = $self13->get_offset();
		$self15 = $this17;
		$self15->x += $a5->x;
		$self15->y += $a5->y;
		$tmp16 = $self13->get_angleDegrees();
		$tmp17 = $aInv->get_angleDegrees();
		$x2 = $tmp16 + $tmp17;
		$tmp18 = null;
		if($x2 < 0) {
			$tmp18 = 360 - _hx_mod(-$x2, 360);
		} else {
			$tmp18 = _hx_mod($x2, 360);
		}
		$self13->set_angleDegrees($tmp18);
		$self13->set_offset($self15);
		$tmp19 = $self13->get_angleDegrees();
		$this->assertApproxEquals($tmp19, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 123, "className" => "test.TestFrames", "methodName" => "testFrame2Inverse")));
		$tmp20 = $aInv->get_offset();
		$tmp21 = $aInv->get_angleDegrees();
		$self16 = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp20, $tmp21);
		$this18 = $self16->get_matrix();
		$self17 = $this18;
		$this19 = new hxmath_math_Matrix2x2Default($self17->a, $self17->b, $self17->c, $self17->d);
		$m3 = $this19;
		$v4 = $a->get_offset();
		$this20 = new hxmath_math_Vector2Default($m3->a * $v4->x + $m3->b * $v4->y, $m3->c * $v4->x + $m3->d * $v4->y);
		$a6 = $self16->get_offset();
		$self18 = $this20;
		$self18->x += $a6->x;
		$self18->y += $a6->y;
		$tmp22 = $self16->get_angleDegrees();
		$tmp23 = $a->get_angleDegrees();
		$x3 = $tmp22 + $tmp23;
		$tmp24 = null;
		if($x3 < 0) {
			$tmp24 = 360 - _hx_mod(-$x3, 360);
		} else {
			$tmp24 = _hx_mod($x3, 360);
		}
		$self16->set_angleDegrees($tmp24);
		$self16->set_offset($self18);
		$tmp25 = $self16->get_angleDegrees();
		$this->assertApproxEquals($tmp25, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 124, "className" => "test.TestFrames", "methodName" => "testFrame2Inverse")));
	}
	public function testFlxSpriteFrame2() {
		$dummySprite = new test_FlxObjectMock();
		$frame = new hxmath_frames_adapters_FlxSpriteFrame2($dummySprite);
		$this1 = new hxmath_math_Vector2Default(0.0, 0.0);
		$frame->set_offset($this1);
		$frame->set_angleDegrees(90);
		$this->assertEquals($frame->get_offset()->x, $dummySprite->x, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 134, "className" => "test.TestFrames", "methodName" => "testFlxSpriteFrame2")));
		$this->assertEquals($frame->get_offset()->y, $dummySprite->y, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 135, "className" => "test.TestFrames", "methodName" => "testFlxSpriteFrame2")));
		$tmp = $frame->get_angleDegrees();
		$this->assertEquals($tmp, $dummySprite->angle, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 136, "className" => "test.TestFrames", "methodName" => "testFlxSpriteFrame2")));
	}
	public function testLerpFrame2() {
		$this1 = new hxmath_math_Vector2Default(1.0, 0.0);
		$frameA = hxmath_frames__Frame2_Frame2_Impl_::_new($this1, 330.0);
		$this2 = new hxmath_math_Vector2Default(0.0, 1.0);
		$frameB = hxmath_frames__Frame2_Frame2_Impl_::_new($this2, 60.0);
		$a = $frameA->get_offset();
		$b = $frameB->get_offset();
		$this3 = new hxmath_math_Vector2Default(0.5 * $a->x + 0.5 * $b->x, 0.5 * $a->y + 0.5 * $b->y);
		$tmp = $this3;
		$a1 = $frameA->get_angleDegrees();
		$b1 = $frameB->get_angleDegrees();
		$tmp1 = Math::abs($a1 - $b1);
		if($tmp1 > 180.) {
			$tmp2 = $a1 < $b1;
			if($tmp2) {
				$a1 += 360;
			} else {
				$b1 += 360;
			}
		}
		$x = 0.5 * $a1 + 0.5 * $b1;
		$tmp3 = null;
		if($x < 0) {
			$tmp3 = 360 - _hx_mod(-$x, 360);
		} else {
			$tmp3 = _hx_mod($x, 360);
		}
		$frameC = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp, $tmp3);
		$a2 = $frameB->get_offset();
		$b2 = $frameA->get_offset();
		$this4 = new hxmath_math_Vector2Default(0.5 * $a2->x + 0.5 * $b2->x, 0.5 * $a2->y + 0.5 * $b2->y);
		$tmp4 = $this4;
		$a3 = $frameB->get_angleDegrees();
		$b3 = $frameA->get_angleDegrees();
		$tmp5 = Math::abs($a3 - $b3);
		if($tmp5 > 180.) {
			$tmp6 = $a3 < $b3;
			if($tmp6) {
				$a3 += 360;
			} else {
				$b3 += 360;
			}
		}
		$x1 = 0.5 * $a3 + 0.5 * $b3;
		$tmp7 = null;
		if($x1 < 0) {
			$tmp7 = 360 - _hx_mod(-$x1, 360);
		} else {
			$tmp7 = _hx_mod($x1, 360);
		}
		$frameC2 = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp4, $tmp7);
		$a4 = $frameC->get_offset();
		$this5 = new hxmath_math_Vector2Default(0.5, 0.5);
		$b4 = $this5;
		$this6 = new hxmath_math_Vector2Default($a4->x, $a4->y);
		$self = $this6;
		$self->x -= $b4->x;
		$self->y -= $b4->y;
		$self1 = $self;
		$tmp8 = $self1->x * $self1->x + $self1->y * $self1->y;
		$tmp9 = Math::sqrt($tmp8);
		$this->assertApproxEquals($tmp9, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 147, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$tmp10 = $frameC->get_angleDegrees();
		$this->assertApproxEquals($tmp10, 15.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 148, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$a5 = $frameC2->get_offset();
		$this7 = new hxmath_math_Vector2Default(0.5, 0.5);
		$b5 = $this7;
		$this8 = new hxmath_math_Vector2Default($a5->x, $a5->y);
		$self2 = $this8;
		$self2->x -= $b5->x;
		$self2->y -= $b5->y;
		$self3 = $self2;
		$tmp11 = $self3->x * $self3->x + $self3->y * $self3->y;
		$tmp12 = Math::sqrt($tmp11);
		$this->assertApproxEquals($tmp12, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 149, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$tmp13 = $frameC2->get_angleDegrees();
		$this->assertApproxEquals($tmp13, 15.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 150, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$a6 = $frameA->get_offset();
		$b6 = $frameB->get_offset();
		$this9 = new hxmath_math_Vector2Default(0.666666666666666741 * $a6->x + 0.333333333333333315 * $b6->x, 0.666666666666666741 * $a6->y + 0.333333333333333315 * $b6->y);
		$tmp14 = $this9;
		$a7 = $frameA->get_angleDegrees();
		$b7 = $frameB->get_angleDegrees();
		$tmp15 = Math::abs($a7 - $b7);
		if($tmp15 > 180.) {
			$tmp16 = $a7 < $b7;
			if($tmp16) {
				$a7 += 360;
			} else {
				$b7 += 360;
			}
		}
		$x2 = 0.666666666666666741 * $a7 + 0.333333333333333315 * $b7;
		$tmp17 = null;
		if($x2 < 0) {
			$tmp17 = 360 - _hx_mod(-$x2, 360);
		} else {
			$tmp17 = _hx_mod($x2, 360);
		}
		$frameD = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp14, $tmp17);
		$a8 = $frameB->get_offset();
		$b8 = $frameA->get_offset();
		$this10 = new hxmath_math_Vector2Default(0.33333333333333337 * $a8->x + 0.66666666666666663 * $b8->x, 0.33333333333333337 * $a8->y + 0.66666666666666663 * $b8->y);
		$tmp18 = $this10;
		$a9 = $frameB->get_angleDegrees();
		$b9 = $frameA->get_angleDegrees();
		$tmp19 = Math::abs($a9 - $b9);
		if($tmp19 > 180.) {
			$tmp20 = $a9 < $b9;
			if($tmp20) {
				$a9 += 360;
			} else {
				$b9 += 360;
			}
		}
		$x3 = 0.33333333333333337 * $a9 + 0.66666666666666663 * $b9;
		$tmp21 = null;
		if($x3 < 0) {
			$tmp21 = 360 - _hx_mod(-$x3, 360);
		} else {
			$tmp21 = _hx_mod($x3, 360);
		}
		$frameD2 = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp18, $tmp21);
		$a10 = $frameD->get_offset();
		$this11 = new hxmath_math_Vector2Default(0.66666666666666663, 0.333333333333333315);
		$b10 = $this11;
		$this12 = new hxmath_math_Vector2Default($a10->x, $a10->y);
		$self4 = $this12;
		$self4->x -= $b10->x;
		$self4->y -= $b10->y;
		$self5 = $self4;
		$tmp22 = $self5->x * $self5->x + $self5->y * $self5->y;
		$tmp23 = Math::sqrt($tmp22);
		$this->assertApproxEquals($tmp23, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 154, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$tmp24 = $frameD->get_angleDegrees();
		$this->assertApproxEquals($tmp24, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 155, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$a11 = $frameD2->get_offset();
		$this13 = new hxmath_math_Vector2Default(0.66666666666666663, 0.333333333333333315);
		$b11 = $this13;
		$this14 = new hxmath_math_Vector2Default($a11->x, $a11->y);
		$self6 = $this14;
		$self6->x -= $b11->x;
		$self6->y -= $b11->y;
		$self7 = $self6;
		$tmp25 = $self7->x * $self7->x + $self7->y * $self7->y;
		$tmp26 = Math::sqrt($tmp25);
		$this->assertApproxEquals($tmp26, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 156, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$tmp27 = $frameD2->get_angleDegrees();
		$this->assertApproxEquals($tmp27, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 157, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$a12 = $frameA->get_offset();
		$b12 = $frameB->get_offset();
		$this15 = new hxmath_math_Vector2Default(0.33333333333333337 * $a12->x + 0.66666666666666663 * $b12->x, 0.33333333333333337 * $a12->y + 0.66666666666666663 * $b12->y);
		$tmp28 = $this15;
		$a13 = $frameA->get_angleDegrees();
		$b13 = $frameB->get_angleDegrees();
		$tmp29 = Math::abs($a13 - $b13);
		if($tmp29 > 180.) {
			$tmp30 = $a13 < $b13;
			if($tmp30) {
				$a13 += 360;
			} else {
				$b13 += 360;
			}
		}
		$x4 = 0.33333333333333337 * $a13 + 0.66666666666666663 * $b13;
		$tmp31 = null;
		if($x4 < 0) {
			$tmp31 = 360 - _hx_mod(-$x4, 360);
		} else {
			$tmp31 = _hx_mod($x4, 360);
		}
		$frameE = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp28, $tmp31);
		$a14 = $frameB->get_offset();
		$b14 = $frameA->get_offset();
		$this16 = new hxmath_math_Vector2Default(0.666666666666666741 * $a14->x + 0.333333333333333315 * $b14->x, 0.666666666666666741 * $a14->y + 0.333333333333333315 * $b14->y);
		$tmp32 = $this16;
		$a15 = $frameB->get_angleDegrees();
		$b15 = $frameA->get_angleDegrees();
		$tmp33 = Math::abs($a15 - $b15);
		if($tmp33 > 180.) {
			$tmp34 = $a15 < $b15;
			if($tmp34) {
				$a15 += 360;
			} else {
				$b15 += 360;
			}
		}
		$x5 = 0.666666666666666741 * $a15 + 0.333333333333333315 * $b15;
		$tmp35 = null;
		if($x5 < 0) {
			$tmp35 = 360 - _hx_mod(-$x5, 360);
		} else {
			$tmp35 = _hx_mod($x5, 360);
		}
		$frameE2 = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp32, $tmp35);
		$a16 = $frameE->get_offset();
		$this17 = new hxmath_math_Vector2Default(0.333333333333333315, 0.66666666666666663);
		$b16 = $this17;
		$this18 = new hxmath_math_Vector2Default($a16->x, $a16->y);
		$self8 = $this18;
		$self8->x -= $b16->x;
		$self8->y -= $b16->y;
		$self9 = $self8;
		$tmp36 = $self9->x * $self9->x + $self9->y * $self9->y;
		$tmp37 = Math::sqrt($tmp36);
		$this->assertApproxEquals($tmp37, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 161, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$tmp38 = $frameE->get_angleDegrees();
		$this->assertApproxEquals($tmp38, 30.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 162, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$a17 = $frameE2->get_offset();
		$this19 = new hxmath_math_Vector2Default(0.333333333333333315, 0.66666666666666663);
		$b17 = $this19;
		$this20 = new hxmath_math_Vector2Default($a17->x, $a17->y);
		$self10 = $this20;
		$self10->x -= $b17->x;
		$self10->y -= $b17->y;
		$self11 = $self10;
		$tmp39 = $self11->x * $self11->x + $self11->y * $self11->y;
		$tmp40 = Math::sqrt($tmp39);
		$this->assertApproxEquals($tmp40, 0.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 163, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
		$tmp41 = $frameE2->get_angleDegrees();
		$this->assertApproxEquals($tmp41, 30.0, null, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 164, "className" => "test.TestFrames", "methodName" => "testLerpFrame2")));
	}
	public function testFramesHaveToString() {
		$this1 = new hxmath_math_Vector2Default(23.0, 0.0);
		$frame2 = hxmath_frames__Frame2_Frame2_Impl_::_new($this1, 42.0);
		$tmp = Std::string($frame2);
		$tmp1 = _hx_index_of(("" . _hx_string_or_null($tmp)), "23", null);
		$this->assertTrue($tmp1 !== -1, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 170, "className" => "test.TestFrames", "methodName" => "testFramesHaveToString")));
		$tmp2 = Std::string($frame2);
		$tmp3 = _hx_index_of(("" . _hx_string_or_null($tmp2)), "42", null);
		$this->assertTrue($tmp3 !== -1, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 171, "className" => "test.TestFrames", "methodName" => "testFramesHaveToString")));
		$this2 = new hxmath_math_Vector3Default(23.0, 0.0, 0.0);
		$tmp4 = $this2;
		$this3 = new hxmath_math_QuaternionDefault(42.0, 0.0, 0.0, 0.0);
		$frame3 = hxmath_frames__Frame3_Frame3_Impl_::_new($tmp4, $this3);
		$tmp5 = Std::string($frame3);
		$tmp6 = _hx_index_of(("" . _hx_string_or_null($tmp5)), "23", null);
		$this->assertTrue($tmp6 !== -1, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 174, "className" => "test.TestFrames", "methodName" => "testFramesHaveToString")));
		$tmp7 = Std::string($frame3);
		$tmp8 = _hx_index_of(("" . _hx_string_or_null($tmp7)), "42", null);
		$this->assertTrue($tmp8 !== -1, _hx_anonymous(array("fileName" => "TestFrames.hx", "lineNumber" => 175, "className" => "test.TestFrames", "methodName" => "testFramesHaveToString")));
	}
	function __toString() { return 'test.TestFrames'; }
}
