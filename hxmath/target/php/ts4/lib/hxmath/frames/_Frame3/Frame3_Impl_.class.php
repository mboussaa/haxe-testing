<?php

// Generated by Haxe 3.3.0
class hxmath_frames__Frame3_Frame3_Impl_ {
	public function __construct(){}
	static function _new($offset, $orientation) {
		$this1 = new hxmath_frames_Frame3Default($offset, $orientation, null);
		return $this1;
	}
	static function calculateMatrix($matrix, $offset, $orientation) {
		{
			$s = $orientation->s;
			$x = $orientation->x;
			$y = $orientation->y;
			$z = $orientation->z;
			$matrix->m00 = 1 - 2 * ($y * $y + $z * $z);
			$matrix->m10 = 2 * ($x * $y - $s * $z);
			$matrix->m20 = 2 * ($s * $y + $x * $z);
			$matrix->m01 = 2 * ($x * $y + $s * $z);
			$matrix->m11 = 1 - 2 * ($x * $x + $z * $z);
			$matrix->m21 = 2 * ($y * $z - $s * $x);
			$matrix->m02 = 2 * ($x * $z - $s * $y);
			$matrix->m12 = 2 * ($y * $z + $s * $x);
			$matrix->m22 = 1 - 2 * ($x * $x + $y * $y);
		}
		{
			$x1 = $offset->x;
			$y1 = $offset->y;
			$z1 = $offset->z;
			$matrix->m30 = $x1;
			$matrix->m31 = $y1;
			$matrix->m32 = $z1;
			$matrix->m33 = 1.0;
		}
		return $matrix;
	}
	static function lerp($frameA, $frameB, $t) {
		$a = $frameA->get_offset();
		$b = $frameB->get_offset();
		$this1 = new hxmath_math_Vector3Default((1.0 - $t) * $a->x + $t * $b->x, (1.0 - $t) * $a->y + $t * $b->y, (1.0 - $t) * $a->z + $t * $b->z);
		$tmp = $this1;
		$a1 = $frameA->get_orientation();
		$b1 = $frameB->get_orientation();
		$s = 1.0 - $t;
		$this2 = new hxmath_math_QuaternionDefault($a1->s, $a1->x, $a1->y, $a1->z);
		$self = $this2;
		$self->s *= $s;
		$self->x *= $s;
		$self->y *= $s;
		$self->z *= $s;
		$this3 = new hxmath_math_QuaternionDefault($b1->s, $b1->x, $b1->y, $b1->z);
		$self1 = $this3;
		$self1->s *= $t;
		$self1->x *= $t;
		$self1->y *= $t;
		$self1->z *= $t;
		$this4 = new hxmath_math_QuaternionDefault($self->s, $self->x, $self->y, $self->z);
		$self2 = $this4;
		$self2->s += $self1->s;
		$self2->x += $self1->x;
		$self2->y += $self1->y;
		$self2->z += $self1->z;
		return hxmath_frames__Frame3_Frame3_Impl_::_new($tmp, $self2);
	}
	static function concat($this1, $other) {
		$self = $this1;
		$tmp = $self->get_offset();
		$tmp1 = $self->get_orientation();
		$self1 = hxmath_frames__Frame3_Frame3_Impl_::_new($tmp, $tmp1);
		$this2 = $self1->get_orientation();
		$u = $other->get_offset();
		$self2 = $this2;
		$a = 2.0 * ($self2->x * $u->x + $self2->y * $u->y + $self2->z * $u->z);
		$b = $self2->s * $self2->s - $self2->x * $self2->x - $self2->y * $self2->y - $self2->z * $self2->z;
		$c = 2.0 * $self2->s;
		$this3 = new hxmath_math_Vector3Default($a * $self2->x + $b * $u->x + $c * ($self2->y * $u->z - $self2->z * $u->y), $a * $self2->y + $b * $u->y + $c * ($self2->z * $u->x - $self2->x * $u->z), $a * $self2->z + $b * $u->z + $c * ($self2->x * $u->y - $self2->y * $u->x));
		$a1 = $self1->get_offset();
		$self3 = $this3;
		$self3->x += $a1->x;
		$self3->y += $a1->y;
		$self3->z += $a1->z;
		$a2 = $self1->get_orientation();
		$b1 = $other->get_orientation();
		$this4 = new hxmath_math_QuaternionDefault($a2->s * $b1->s - $a2->x * $b1->x - $a2->y * $b1->y - $a2->z * $b1->z, $a2->s * $b1->x + $b1->s * $a2->x + $a2->y * $b1->z - $a2->z * $b1->y, $a2->s * $b1->y + $b1->s * $a2->y + $a2->z * $b1->x - $a2->x * $b1->z, $a2->s * $b1->z + $b1->s * $a2->z + $a2->x * $b1->y - $a2->y * $b1->x);
		$self4 = $this4;
		$tmp2 = $self4->s * $self4->s + $self4->x * $self4->x + $self4->y * $self4->y + $self4->z * $self4->z;
		$tmp3 = Math::sqrt($tmp2);
		$_g = 1.0 / $tmp3;
		$this5 = new hxmath_math_QuaternionDefault($self4->s, $self4->x, $self4->y, $self4->z);
		$self5 = $this5;
		$self5->s *= $_g;
		$self5->x *= $_g;
		$self5->y *= $_g;
		$self5->z *= $_g;
		$self1->set_orientation($self5);
		$self1->set_offset($self3);
		return $self1;
	}
	static function concatWith($this1, $other) {
		$self = $this1;
		$this2 = $self->get_orientation();
		$u = $other->get_offset();
		$self1 = $this2;
		$a = 2.0 * ($self1->x * $u->x + $self1->y * $u->y + $self1->z * $u->z);
		$b = $self1->s * $self1->s - $self1->x * $self1->x - $self1->y * $self1->y - $self1->z * $self1->z;
		$c = 2.0 * $self1->s;
		$this3 = new hxmath_math_Vector3Default($a * $self1->x + $b * $u->x + $c * ($self1->y * $u->z - $self1->z * $u->y), $a * $self1->y + $b * $u->y + $c * ($self1->z * $u->x - $self1->x * $u->z), $a * $self1->z + $b * $u->z + $c * ($self1->x * $u->y - $self1->y * $u->x));
		$a1 = $self->get_offset();
		$self2 = $this3;
		$self2->x += $a1->x;
		$self2->y += $a1->y;
		$self2->z += $a1->z;
		$a2 = $self->get_orientation();
		$b1 = $other->get_orientation();
		$this4 = new hxmath_math_QuaternionDefault($a2->s * $b1->s - $a2->x * $b1->x - $a2->y * $b1->y - $a2->z * $b1->z, $a2->s * $b1->x + $b1->s * $a2->x + $a2->y * $b1->z - $a2->z * $b1->y, $a2->s * $b1->y + $b1->s * $a2->y + $a2->z * $b1->x - $a2->x * $b1->z, $a2->s * $b1->z + $b1->s * $a2->z + $a2->x * $b1->y - $a2->y * $b1->x);
		$self3 = $this4;
		$tmp = $self3->s * $self3->s + $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
		$tmp1 = Math::sqrt($tmp);
		$_g = 1.0 / $tmp1;
		$this5 = new hxmath_math_QuaternionDefault($self3->s, $self3->x, $self3->y, $self3->z);
		$self4 = $this5;
		$self4->s *= $_g;
		$self4->x *= $_g;
		$self4->y *= $_g;
		$self4->z *= $_g;
		$self->set_orientation($self4);
		$self->set_offset($self2);
		return $self;
	}
	static function transformFrom($this1, $p) {
		$self = $this1;
		$this2 = $self->get_orientation();
		$self1 = $this2;
		$a = 2.0 * ($self1->x * $p->x + $self1->y * $p->y + $self1->z * $p->z);
		$b = $self1->s * $self1->s - $self1->x * $self1->x - $self1->y * $self1->y - $self1->z * $self1->z;
		$c = 2.0 * $self1->s;
		$this3 = new hxmath_math_Vector3Default($a * $self1->x + $b * $p->x + $c * ($self1->y * $p->z - $self1->z * $p->y), $a * $self1->y + $b * $p->y + $c * ($self1->z * $p->x - $self1->x * $p->z), $a * $self1->z + $b * $p->z + $c * ($self1->x * $p->y - $self1->y * $p->x));
		$a1 = $self->get_offset();
		$self2 = $this3;
		$self2->x += $a1->x;
		$self2->y += $a1->y;
		$self2->z += $a1->z;
		return $self2;
	}
	static function transformTo($this1, $p) {
		$self = $this1;
		$this2 = $self->get_orientation();
		$self1 = $this2;
		$this3 = new hxmath_math_QuaternionDefault($self1->s, $self1->x, $self1->y, $self1->z);
		$self2 = $this3;
		$self2->x = -$self2->x;
		$self2->y = -$self2->y;
		$self2->z = -$self2->z;
		$self3 = $self2;
		$tmp = $self3->s * $self3->s + $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
		$length = Math::sqrt($tmp);
		if($length > 0.0) {
			$k = 1.0 / $length;
			{
				$self3->s *= $k;
				$self3->x *= $k;
				$self3->y *= $k;
				$self3->z *= $k;
			}
		}
		$this4 = $self3;
		$b = $self->get_offset();
		$this5 = new hxmath_math_Vector3Default($p->x, $p->y, $p->z);
		$self4 = $this5;
		$self4->x -= $b->x;
		$self4->y -= $b->y;
		$self4->z -= $b->z;
		$self5 = $this4;
		$a = 2.0 * ($self5->x * $self4->x + $self5->y * $self4->y + $self5->z * $self4->z);
		$b1 = $self5->s * $self5->s - $self5->x * $self5->x - $self5->y * $self5->y - $self5->z * $self5->z;
		$c = 2.0 * $self5->s;
		$this6 = new hxmath_math_Vector3Default($a * $self5->x + $b1 * $self4->x + $c * ($self5->y * $self4->z - $self5->z * $self4->y), $a * $self5->y + $b1 * $self4->y + $c * ($self5->z * $self4->x - $self5->x * $self4->z), $a * $self5->z + $b1 * $self4->z + $c * ($self5->x * $self4->y - $self5->y * $self4->x));
		return $this6;
	}
	static function linearTransformFrom($this1, $v) {
		$self = $this1;
		$this2 = $self->get_orientation();
		$self1 = $this2;
		$a = 2.0 * ($self1->x * $v->x + $self1->y * $v->y + $self1->z * $v->z);
		$b = $self1->s * $self1->s - $self1->x * $self1->x - $self1->y * $self1->y - $self1->z * $self1->z;
		$c = 2.0 * $self1->s;
		$this3 = new hxmath_math_Vector3Default($a * $self1->x + $b * $v->x + $c * ($self1->y * $v->z - $self1->z * $v->y), $a * $self1->y + $b * $v->y + $c * ($self1->z * $v->x - $self1->x * $v->z), $a * $self1->z + $b * $v->z + $c * ($self1->x * $v->y - $self1->y * $v->x));
		return $this3;
	}
	static function linearTransformTo($this1, $v) {
		$self = $this1;
		$this2 = $self->get_orientation();
		$self1 = $this2;
		$this3 = new hxmath_math_QuaternionDefault($self1->s, $self1->x, $self1->y, $self1->z);
		$self2 = $this3;
		$self2->x = -$self2->x;
		$self2->y = -$self2->y;
		$self2->z = -$self2->z;
		$self3 = $self2;
		$tmp = $self3->s * $self3->s + $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
		$length = Math::sqrt($tmp);
		if($length > 0.0) {
			$k = 1.0 / $length;
			{
				$self3->s *= $k;
				$self3->x *= $k;
				$self3->y *= $k;
				$self3->z *= $k;
			}
		}
		$self4 = $self3;
		$a = 2.0 * ($self4->x * $v->x + $self4->y * $v->y + $self4->z * $v->z);
		$b = $self4->s * $self4->s - $self4->x * $self4->x - $self4->y * $self4->y - $self4->z * $self4->z;
		$c = 2.0 * $self4->s;
		$this4 = new hxmath_math_Vector3Default($a * $self4->x + $b * $v->x + $c * ($self4->y * $v->z - $self4->z * $v->y), $a * $self4->y + $b * $v->y + $c * ($self4->z * $v->x - $self4->x * $v->z), $a * $self4->z + $b * $v->z + $c * ($self4->x * $v->y - $self4->y * $v->x));
		return $this4;
	}
	static function inverse($this1) {
		$self = $this1;
		$this2 = $self->get_orientation();
		$self1 = $this2;
		$this3 = new hxmath_math_QuaternionDefault($self1->s, $self1->x, $self1->y, $self1->z);
		$self2 = $this3;
		$self2->x = -$self2->x;
		$self2->y = -$self2->y;
		$self2->z = -$self2->z;
		$self3 = $self2;
		$tmp = $self3->s * $self3->s + $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
		$length = Math::sqrt($tmp);
		if($length > 0.0) {
			$k = 1.0 / $length;
			{
				$self3->s *= $k;
				$self3->x *= $k;
				$self3->y *= $k;
				$self3->z *= $k;
			}
		}
		$u = $self->get_offset();
		$a = 2.0 * ($self3->x * $u->x + $self3->y * $u->y + $self3->z * $u->z);
		$b = $self3->s * $self3->s - $self3->x * $self3->x - $self3->y * $self3->y - $self3->z * $self3->z;
		$c = 2.0 * $self3->s;
		$this4 = new hxmath_math_Vector3Default($a * $self3->x + $b * $u->x + $c * ($self3->y * $u->z - $self3->z * $u->y), $a * $self3->y + $b * $u->y + $c * ($self3->z * $u->x - $self3->x * $u->z), $a * $self3->z + $b * $u->z + $c * ($self3->x * $u->y - $self3->y * $u->x));
		$self4 = $this4;
		$self4->x = -$self4->x;
		$self4->y = -$self4->y;
		$self4->z = -$self4->z;
		return hxmath_frames__Frame3_Frame3_Impl_::_new($self4, $self3);
	}
	static function hclone($this1) {
		$self = $this1;
		$tmp = $self->get_offset();
		$tmp1 = $self->get_orientation();
		return hxmath_frames__Frame3_Frame3_Impl_::_new($tmp, $tmp1);
	}
	static function get_linearMatrix($this1) {
		$self = $this1;
		$this2 = $self->get_matrix();
		$self1 = $this2;
		$this3 = new hxmath_math_Matrix3x3Default($self1->m00, $self1->m10, $self1->m20, $self1->m01, $self1->m11, $self1->m21, $self1->m02, $self1->m12, $self1->m22);
		return $this3;
	}
	static $__properties__ = array("get_linearMatrix" => "get_linearMatrix");
	function __toString() { return 'hxmath.frames._Frame3.Frame3_Impl_'; }
}
