<?php

// Generated by Haxe 3.3.0
class test_Test3D extends test_MathTestCase {
	public function __construct($posInfos = null) { if(!php_Boot::$skip_constructor) {
		parent::__construct($posInfos);
	}}
	public function testMatrixMult() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$a = $this->randomMatrix3x3(null);
			$this1 = new hxmath_math_Matrix3x3Default(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0);
			$a1 = $this1;
			$this2 = new hxmath_math_Matrix3x3Default($a1->m00 * $a->m00 + $a1->m10 * $a->m01 + $a1->m20 * $a->m02, $a1->m00 * $a->m10 + $a1->m10 * $a->m11 + $a1->m20 * $a->m12, $a1->m00 * $a->m20 + $a1->m10 * $a->m21 + $a1->m20 * $a->m22, $a1->m01 * $a->m00 + $a1->m11 * $a->m01 + $a1->m21 * $a->m02, $a1->m01 * $a->m10 + $a1->m11 * $a->m11 + $a1->m21 * $a->m12, $a1->m01 * $a->m20 + $a1->m11 * $a->m21 + $a1->m21 * $a->m22, $a1->m02 * $a->m00 + $a1->m12 * $a->m01 + $a1->m22 * $a->m02, $a1->m02 * $a->m10 + $a1->m12 * $a->m11 + $a1->m22 * $a->m12, $a1->m02 * $a->m20 + $a1->m12 * $a->m21 + $a1->m22 * $a->m22);
			$a2 = $this2;
			$tmp = null;
			$tmp1 = null;
			if($a2 === null) {
				$tmp1 = $a === null;
			} else {
				$tmp1 = false;
			}
			if(!$tmp1) {
				$tmp2 = null;
				$tmp3 = null;
				$tmp4 = null;
				$tmp5 = null;
				$tmp6 = null;
				$tmp7 = null;
				$tmp8 = null;
				$tmp9 = null;
				$tmp10 = null;
				if($a2 !== null) {
					$tmp10 = $a !== null;
				} else {
					$tmp10 = false;
				}
				if($tmp10) {
					$tmp9 = $a2->m00 === $a->m00;
				} else {
					$tmp9 = false;
				}
				if($tmp9) {
					$tmp8 = $a2->m10 === $a->m10;
				} else {
					$tmp8 = false;
				}
				if($tmp8) {
					$tmp7 = $a2->m20 === $a->m20;
				} else {
					$tmp7 = false;
				}
				if($tmp7) {
					$tmp6 = $a2->m01 === $a->m01;
				} else {
					$tmp6 = false;
				}
				if($tmp6) {
					$tmp5 = $a2->m11 === $a->m11;
				} else {
					$tmp5 = false;
				}
				if($tmp5) {
					$tmp4 = $a2->m21 === $a->m21;
				} else {
					$tmp4 = false;
				}
				if($tmp4) {
					$tmp3 = $a2->m02 === $a->m02;
				} else {
					$tmp3 = false;
				}
				if($tmp3) {
					$tmp2 = $a2->m12 === $a->m12;
				} else {
					$tmp2 = false;
				}
				if($tmp2) {
					$tmp = $a2->m22 === $a->m22;
				} else {
					$tmp = false;
				}
				unset($tmp9,$tmp8,$tmp7,$tmp6,$tmp5,$tmp4,$tmp3,$tmp2,$tmp10);
			} else {
				$tmp = true;
			}
			$this->assertTrue($tmp, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 18, "className" => "test.Test3D", "methodName" => "testMatrixMult")));
			unset($tmp1,$tmp,$this2,$this1,$a2,$a1,$a);
		}
	}
	public function testAddSub() {
		{
			$_g = 0;
			while($_g < 10) {
				++$_g;
				$a = $this->randomMatrix3x3(null);
				$b = $this->randomMatrix3x3(null);
				$this1 = new hxmath_math_Matrix3x3Default($a->m00, $a->m10, $a->m20, $a->m01, $a->m11, $a->m21, $a->m02, $a->m12, $a->m22);
				$c = $this1;
				$c->m00 += $b->m00;
				$c->m10 += $b->m10;
				$c->m20 += $b->m20;
				$c->m01 += $b->m01;
				$c->m11 += $b->m11;
				$c->m21 += $b->m21;
				$c->m02 += $b->m02;
				$c->m12 += $b->m12;
				$c->m22 += $b->m22;
				$this2 = new hxmath_math_Matrix3x3Default($a->m00, $a->m10, $a->m20, $a->m01, $a->m11, $a->m21, $a->m02, $a->m12, $a->m22);
				$self = $this2;
				$self->m00 += $b->m00;
				$self->m10 += $b->m10;
				$self->m20 += $b->m20;
				$self->m01 += $b->m01;
				$self->m11 += $b->m11;
				$self->m21 += $b->m21;
				$self->m02 += $b->m02;
				$self->m12 += $b->m12;
				$self->m22 += $b->m22;
				$tmp = null;
				$tmp1 = null;
				if($c === null) {
					$tmp1 = $self === null;
				} else {
					$tmp1 = false;
				}
				if(!$tmp1) {
					$tmp2 = null;
					$tmp3 = null;
					$tmp4 = null;
					$tmp5 = null;
					$tmp6 = null;
					$tmp7 = null;
					$tmp8 = null;
					$tmp9 = null;
					$tmp10 = null;
					if($c !== null) {
						$tmp10 = $self !== null;
					} else {
						$tmp10 = false;
					}
					if($tmp10) {
						$tmp9 = $c->m00 === $self->m00;
					} else {
						$tmp9 = false;
					}
					if($tmp9) {
						$tmp8 = $c->m10 === $self->m10;
					} else {
						$tmp8 = false;
					}
					if($tmp8) {
						$tmp7 = $c->m20 === $self->m20;
					} else {
						$tmp7 = false;
					}
					if($tmp7) {
						$tmp6 = $c->m01 === $self->m01;
					} else {
						$tmp6 = false;
					}
					if($tmp6) {
						$tmp5 = $c->m11 === $self->m11;
					} else {
						$tmp5 = false;
					}
					if($tmp5) {
						$tmp4 = $c->m21 === $self->m21;
					} else {
						$tmp4 = false;
					}
					if($tmp4) {
						$tmp3 = $c->m02 === $self->m02;
					} else {
						$tmp3 = false;
					}
					if($tmp3) {
						$tmp2 = $c->m12 === $self->m12;
					} else {
						$tmp2 = false;
					}
					if($tmp2) {
						$tmp = $c->m22 === $self->m22;
					} else {
						$tmp = false;
					}
					unset($tmp9,$tmp8,$tmp7,$tmp6,$tmp5,$tmp4,$tmp3,$tmp2,$tmp10);
				} else {
					$tmp = true;
				}
				$this->assertTrue($tmp, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 29, "className" => "test.Test3D", "methodName" => "testAddSub")));
				unset($tmp1,$tmp,$this2,$this1,$self,$c,$b,$a);
			}
		}
		{
			$_g1 = 0;
			while($_g1 < 10) {
				++$_g1;
				$a1 = $this->randomMatrix3x3(null);
				$b1 = $this->randomMatrix3x3(null);
				$this3 = new hxmath_math_Matrix3x3Default($a1->m00, $a1->m10, $a1->m20, $a1->m01, $a1->m11, $a1->m21, $a1->m02, $a1->m12, $a1->m22);
				$c1 = $this3;
				$c1->m00 -= $b1->m00;
				$c1->m10 -= $b1->m10;
				$c1->m20 -= $b1->m20;
				$c1->m01 -= $b1->m01;
				$c1->m11 -= $b1->m11;
				$c1->m21 -= $b1->m21;
				$c1->m02 -= $b1->m02;
				$c1->m12 -= $b1->m12;
				$c1->m22 -= $b1->m22;
				$this4 = new hxmath_math_Matrix3x3Default($a1->m00, $a1->m10, $a1->m20, $a1->m01, $a1->m11, $a1->m21, $a1->m02, $a1->m12, $a1->m22);
				$self1 = $this4;
				$self1->m00 -= $b1->m00;
				$self1->m10 -= $b1->m10;
				$self1->m20 -= $b1->m20;
				$self1->m01 -= $b1->m01;
				$self1->m11 -= $b1->m11;
				$self1->m21 -= $b1->m21;
				$self1->m02 -= $b1->m02;
				$self1->m12 -= $b1->m12;
				$self1->m22 -= $b1->m22;
				$tmp11 = null;
				$tmp12 = null;
				if($c1 === null) {
					$tmp12 = $self1 === null;
				} else {
					$tmp12 = false;
				}
				if(!$tmp12) {
					$tmp13 = null;
					$tmp14 = null;
					$tmp15 = null;
					$tmp16 = null;
					$tmp17 = null;
					$tmp18 = null;
					$tmp19 = null;
					$tmp20 = null;
					$tmp21 = null;
					if($c1 !== null) {
						$tmp21 = $self1 !== null;
					} else {
						$tmp21 = false;
					}
					if($tmp21) {
						$tmp20 = $c1->m00 === $self1->m00;
					} else {
						$tmp20 = false;
					}
					if($tmp20) {
						$tmp19 = $c1->m10 === $self1->m10;
					} else {
						$tmp19 = false;
					}
					if($tmp19) {
						$tmp18 = $c1->m20 === $self1->m20;
					} else {
						$tmp18 = false;
					}
					if($tmp18) {
						$tmp17 = $c1->m01 === $self1->m01;
					} else {
						$tmp17 = false;
					}
					if($tmp17) {
						$tmp16 = $c1->m11 === $self1->m11;
					} else {
						$tmp16 = false;
					}
					if($tmp16) {
						$tmp15 = $c1->m21 === $self1->m21;
					} else {
						$tmp15 = false;
					}
					if($tmp15) {
						$tmp14 = $c1->m02 === $self1->m02;
					} else {
						$tmp14 = false;
					}
					if($tmp14) {
						$tmp13 = $c1->m12 === $self1->m12;
					} else {
						$tmp13 = false;
					}
					if($tmp13) {
						$tmp11 = $c1->m22 === $self1->m22;
					} else {
						$tmp11 = false;
					}
					unset($tmp21,$tmp20,$tmp19,$tmp18,$tmp17,$tmp16,$tmp15,$tmp14,$tmp13);
				} else {
					$tmp11 = true;
				}
				$this->assertTrue($tmp11, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 37, "className" => "test.Test3D", "methodName" => "testAddSub")));
				unset($tmp12,$tmp11,$this4,$this3,$self1,$c1,$b1,$a1);
			}
		}
	}
	public function testCrossProductPrecedence() {
		$this1 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$a = $this1;
		$this2 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$a1 = $this2;
		$this3 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$b = $this3;
		$this4 = new hxmath_math_Vector3Default($a1->x, $a1->y, $a1->z);
		$self = $this4;
		$newX = $self->y * $b->z - $self->z * $b->y;
		$newY = $self->z * $b->x - $self->x * $b->z;
		$newZ = $self->x * $b->y - $self->y * $b->x;
		$self->x = $newX;
		$self->y = $newY;
		$self->z = $newZ;
		$this5 = new hxmath_math_Vector3Default($a->x, $a->y, $a->z);
		$self1 = $this5;
		$self1->x += $self->x;
		$self1->y += $self->y;
		$self1->z += $self->z;
		$this6 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$_g1 = $this6;
		$this7 = new hxmath_math_Vector3Default($_g1->x, $_g1->y, $_g1->z);
		$self2 = $this7;
		$self2->x *= 2.0;
		$self2->y *= 2.0;
		$self2->z *= 2.0;
		$tmp = null;
		$tmp1 = null;
		if($self1 === null) {
			$tmp1 = $self2 === null;
		} else {
			$tmp1 = false;
		}
		if(!$tmp1) {
			$tmp2 = null;
			$tmp3 = null;
			$tmp4 = null;
			if($self1 !== null) {
				$tmp4 = $self2 !== null;
			} else {
				$tmp4 = false;
			}
			if($tmp4) {
				$tmp3 = $self1->x === $self2->x;
			} else {
				$tmp3 = false;
			}
			if($tmp3) {
				$tmp2 = $self1->y === $self2->y;
			} else {
				$tmp2 = false;
			}
			if($tmp2) {
				$tmp = $self1->z === $self2->z;
			} else {
				$tmp = false;
			}
		} else {
			$tmp = true;
		}
		$this->assertTrue($tmp, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 43, "className" => "test.Test3D", "methodName" => "testCrossProductPrecedence")));
	}
	public function testAxialRotation() {
		$angleRadians = Math::$PI / 180 * 90.0;
		$s = Math::sin($angleRadians);
		$c = Math::cos($angleRadians);
		$this1 = new hxmath_math_Matrix3x3Default(1, 0, 0, 0, $c, -$s, 0, $s, $c);
		$a = $this1;
		$this2 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$v = $this2;
		$this3 = new hxmath_math_Vector3Default($a->m00 * $v->x + $a->m10 * $v->y + $a->m20 * $v->z, $a->m01 * $v->x + $a->m11 * $v->y + $a->m21 * $v->z, $a->m02 * $v->x + $a->m12 * $v->y + $a->m22 * $v->z);
		$a1 = $this3;
		$this4 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$b = $this4;
		$this5 = new hxmath_math_Vector3Default($a1->x, $a1->y, $a1->z);
		$self = $this5;
		$self->x -= $b->x;
		$self->y -= $b->y;
		$self->z -= $b->z;
		$self1 = $self;
		$tmp = $self1->x * $self1->x + $self1->y * $self1->y + $self1->z * $self1->z;
		$tmp1 = Math::sqrt($tmp);
		$this->assertApproxEquals($tmp1, 0.0, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 53, "className" => "test.Test3D", "methodName" => "testAxialRotation")));
		$angleRadians1 = Math::$PI / 180 * 90.0;
		$s1 = Math::sin($angleRadians1);
		$c1 = Math::cos($angleRadians1);
		$this6 = new hxmath_math_Matrix3x3Default(1, 0, 0, 0, $c1, -$s1, 0, $s1, $c1);
		$a2 = $this6;
		$this7 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$v1 = $this7;
		$this8 = new hxmath_math_Vector3Default($a2->m00 * $v1->x + $a2->m10 * $v1->y + $a2->m20 * $v1->z, $a2->m01 * $v1->x + $a2->m11 * $v1->y + $a2->m21 * $v1->z, $a2->m02 * $v1->x + $a2->m12 * $v1->y + $a2->m22 * $v1->z);
		$a3 = $this8;
		$this9 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$b1 = $this9;
		$this10 = new hxmath_math_Vector3Default($a3->x, $a3->y, $a3->z);
		$self2 = $this10;
		$self2->x += $b1->x;
		$self2->y += $b1->y;
		$self2->z += $b1->z;
		$self3 = $self2;
		$tmp2 = $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
		$tmp3 = Math::sqrt($tmp2);
		$this->assertApproxEquals($tmp3, 0.0, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 54, "className" => "test.Test3D", "methodName" => "testAxialRotation")));
		$angleRadians2 = Math::$PI / 180 * 90.0;
		$s2 = Math::sin($angleRadians2);
		$c2 = Math::cos($angleRadians2);
		$this11 = new hxmath_math_Matrix3x3Default($c2, 0, $s2, 0, 1, 0, -$s2, 0, $c2);
		$a4 = $this11;
		$this12 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$v2 = $this12;
		$this13 = new hxmath_math_Vector3Default($a4->m00 * $v2->x + $a4->m10 * $v2->y + $a4->m20 * $v2->z, $a4->m01 * $v2->x + $a4->m11 * $v2->y + $a4->m21 * $v2->z, $a4->m02 * $v2->x + $a4->m12 * $v2->y + $a4->m22 * $v2->z);
		$a5 = $this13;
		$this14 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$b2 = $this14;
		$this15 = new hxmath_math_Vector3Default($a5->x, $a5->y, $a5->z);
		$self4 = $this15;
		$self4->x -= $b2->x;
		$self4->y -= $b2->y;
		$self4->z -= $b2->z;
		$self5 = $self4;
		$tmp4 = $self5->x * $self5->x + $self5->y * $self5->y + $self5->z * $self5->z;
		$tmp5 = Math::sqrt($tmp4);
		$this->assertApproxEquals($tmp5, 0.0, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 59, "className" => "test.Test3D", "methodName" => "testAxialRotation")));
		$angleRadians3 = Math::$PI / 180 * 90.0;
		$s3 = Math::sin($angleRadians3);
		$c3 = Math::cos($angleRadians3);
		$this16 = new hxmath_math_Matrix3x3Default($c3, 0, $s3, 0, 1, 0, -$s3, 0, $c3);
		$a6 = $this16;
		$this17 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$v3 = $this17;
		$this18 = new hxmath_math_Vector3Default($a6->m00 * $v3->x + $a6->m10 * $v3->y + $a6->m20 * $v3->z, $a6->m01 * $v3->x + $a6->m11 * $v3->y + $a6->m21 * $v3->z, $a6->m02 * $v3->x + $a6->m12 * $v3->y + $a6->m22 * $v3->z);
		$a7 = $this18;
		$this19 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$b3 = $this19;
		$this20 = new hxmath_math_Vector3Default($a7->x, $a7->y, $a7->z);
		$self6 = $this20;
		$self6->x += $b3->x;
		$self6->y += $b3->y;
		$self6->z += $b3->z;
		$self7 = $self6;
		$tmp6 = $self7->x * $self7->x + $self7->y * $self7->y + $self7->z * $self7->z;
		$tmp7 = Math::sqrt($tmp6);
		$this->assertApproxEquals($tmp7, 0.0, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 60, "className" => "test.Test3D", "methodName" => "testAxialRotation")));
		$angleRadians4 = Math::$PI / 180 * 90.0;
		$s4 = Math::sin($angleRadians4);
		$c4 = Math::cos($angleRadians4);
		$this21 = new hxmath_math_Matrix3x3Default($c4, -$s4, 0, $s4, $c4, 0, 0, 0, 1);
		$a8 = $this21;
		$this22 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$v4 = $this22;
		$this23 = new hxmath_math_Vector3Default($a8->m00 * $v4->x + $a8->m10 * $v4->y + $a8->m20 * $v4->z, $a8->m01 * $v4->x + $a8->m11 * $v4->y + $a8->m21 * $v4->z, $a8->m02 * $v4->x + $a8->m12 * $v4->y + $a8->m22 * $v4->z);
		$a9 = $this23;
		$this24 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$b4 = $this24;
		$this25 = new hxmath_math_Vector3Default($a9->x, $a9->y, $a9->z);
		$self8 = $this25;
		$self8->x -= $b4->x;
		$self8->y -= $b4->y;
		$self8->z -= $b4->z;
		$self9 = $self8;
		$tmp8 = $self9->x * $self9->x + $self9->y * $self9->y + $self9->z * $self9->z;
		$tmp9 = Math::sqrt($tmp8);
		$this->assertApproxEquals($tmp9, 0.0, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 65, "className" => "test.Test3D", "methodName" => "testAxialRotation")));
		$angleRadians5 = Math::$PI / 180 * 90.0;
		$s5 = Math::sin($angleRadians5);
		$c5 = Math::cos($angleRadians5);
		$this26 = new hxmath_math_Matrix3x3Default($c5, -$s5, 0, $s5, $c5, 0, 0, 0, 1);
		$a10 = $this26;
		$this27 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$v5 = $this27;
		$this28 = new hxmath_math_Vector3Default($a10->m00 * $v5->x + $a10->m10 * $v5->y + $a10->m20 * $v5->z, $a10->m01 * $v5->x + $a10->m11 * $v5->y + $a10->m21 * $v5->z, $a10->m02 * $v5->x + $a10->m12 * $v5->y + $a10->m22 * $v5->z);
		$a11 = $this28;
		$this29 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$b5 = $this29;
		$this30 = new hxmath_math_Vector3Default($a11->x, $a11->y, $a11->z);
		$self10 = $this30;
		$self10->x += $b5->x;
		$self10->y += $b5->y;
		$self10->z += $b5->z;
		$self11 = $self10;
		$tmp10 = $self11->x * $self11->x + $self11->y * $self11->y + $self11->z * $self11->z;
		$tmp11 = Math::sqrt($tmp10);
		$this->assertApproxEquals($tmp11, 0.0, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 66, "className" => "test.Test3D", "methodName" => "testAxialRotation")));
	}
	public function testQuaternionToMatrix() {
		$createMatrixPair = array(new _hx_lambda(array(), "test_Test3D_0"), 'execute');
		{
			$_g = 0;
			while($_g < 3) {
				$axis2 = $_g++;
				$unitAngle1 = 0.0;
				{
					$_g1 = 0;
					while($_g1 < 10) {
						++$_g1;
						$unitAngle1 += 0.01;
						$totalLength = 0.0;
						{
							$_g2 = 0;
							while($_g2 < 3) {
								$c = $_g2++;
								$pair = call_user_func_array($createMatrixPair, array($unitAngle1, $axis2));
								$self = $pair->n;
								$tmp2 = null;
								switch($c) {
								case 0:{
									$this6 = new hxmath_math_Vector3Default($self->m00, $self->m01, $self->m02);
									$tmp2 = $this6;
								}break;
								case 1:{
									$this7 = new hxmath_math_Vector3Default($self->m10, $self->m11, $self->m12);
									$tmp2 = $this7;
								}break;
								case 2:{
									$this8 = new hxmath_math_Vector3Default($self->m20, $self->m21, $self->m22);
									$tmp2 = $this8;
								}break;
								default:{
									throw new HException("Invalid column");
								}break;
								}
								$a = $tmp2;
								$self1 = $pair->m;
								$tmp3 = null;
								switch($c) {
								case 0:{
									$this9 = new hxmath_math_Vector3Default($self1->m00, $self1->m01, $self1->m02);
									$tmp3 = $this9;
								}break;
								case 1:{
									$this10 = new hxmath_math_Vector3Default($self1->m10, $self1->m11, $self1->m12);
									$tmp3 = $this10;
								}break;
								case 2:{
									$this11 = new hxmath_math_Vector3Default($self1->m20, $self1->m21, $self1->m22);
									$tmp3 = $this11;
								}break;
								default:{
									throw new HException("Invalid column");
								}break;
								}
								$b = $tmp3;
								$this12 = new hxmath_math_Vector3Default($a->x, $a->y, $a->z);
								$self2 = $this12;
								$self2->x -= $b->x;
								$self2->y -= $b->y;
								$self2->z -= $b->z;
								$self3 = $self2;
								$tmp4 = $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
								$tmp5 = Math::sqrt($tmp4);
								$totalLength += $tmp5;
								unset($tmp5,$tmp4,$tmp3,$tmp2,$this12,$self3,$self2,$self1,$self,$pair,$c,$b,$a);
							}
							unset($_g2);
						}
						$this->assertApproxEquals($totalLength, 0.0, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 98, "className" => "test.Test3D", "methodName" => "testQuaternionToMatrix")));
						unset($totalLength);
					}
					unset($_g1);
				}
				unset($unitAngle1,$axis2);
			}
		}
	}
	public function testMatrixFrameInverse() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$frame = $this->randomFrame3(null);
			$this1 = $frame->get_orientation();
			$self = $this1;
			$this2 = new hxmath_math_QuaternionDefault($self->s, $self->x, $self->y, $self->z);
			$self1 = $this2;
			$self1->x = -$self1->x;
			$self1->y = -$self1->y;
			$self1->z = -$self1->z;
			$self2 = $self1;
			$tmp = $self2->s * $self2->s + $self2->x * $self2->x + $self2->y * $self2->y + $self2->z * $self2->z;
			$length = Math::sqrt($tmp);
			if($length > 0.0) {
				$k = 1.0 / $length;
				{
					$self2->s *= $k;
					$self2->x *= $k;
					$self2->y *= $k;
					$self2->z *= $k;
				}
				unset($k);
			}
			$u = $frame->get_offset();
			$a = 2.0 * ($self2->x * $u->x + $self2->y * $u->y + $self2->z * $u->z);
			$b = $self2->s * $self2->s - $self2->x * $self2->x - $self2->y * $self2->y - $self2->z * $self2->z;
			$c = 2.0 * $self2->s;
			$this3 = new hxmath_math_Vector3Default($a * $self2->x + $b * $u->x + $c * ($self2->y * $u->z - $self2->z * $u->y), $a * $self2->y + $b * $u->y + $c * ($self2->z * $u->x - $self2->x * $u->z), $a * $self2->z + $b * $u->z + $c * ($self2->x * $u->y - $self2->y * $u->x));
			$self3 = $this3;
			$self3->x = -$self3->x;
			$self3->y = -$self3->y;
			$self3->z = -$self3->z;
			$invFrame = hxmath_frames__Frame3_Frame3_Impl_::_new($self3, $self2);
			$frame->get_matrix();
			$invFrameMatrix = $invFrame->get_matrix();
			$this4 = $frame->get_matrix();
			$self4 = $this4;
			{
				$temp = $self4->m01;
				$self4->m01 = $self4->m10;
				$self4->m10 = $temp;
				$temp = $self4->m02;
				$self4->m02 = $self4->m20;
				$self4->m20 = $temp;
				$temp = $self4->m12;
				$self4->m12 = $self4->m21;
				$self4->m21 = $temp;
				unset($temp);
			}
			$tx = -($self4->m00 * $self4->m30 + $self4->m10 * $self4->m31 + $self4->m20 * $self4->m32);
			$ty = -($self4->m01 * $self4->m30 + $self4->m11 * $self4->m31 + $self4->m21 * $self4->m32);
			$tz = -($self4->m02 * $self4->m30 + $self4->m12 * $self4->m31 + $self4->m22 * $self4->m32);
			$self4->m30 = $tx;
			$self4->m31 = $ty;
			$self4->m32 = $tz;
			$this5 = new hxmath_math_Vector4Default(0.0, 0.0, 0.0, 1.0);
			$homogenous0 = $this5;
			$this6 = new hxmath_math_Vector4Default(1.0, 0.0, 0.0, 1.0);
			$homogenousX = $this6;
			$this7 = new hxmath_math_Vector4Default(0.0, 1.0, 0.0, 1.0);
			$homogenousY = $this7;
			$this8 = new hxmath_math_Vector4Default(0.0, 0.0, 1.0, 1.0);
			$homogenousZ = $this8;
			$this9 = new hxmath_math_Vector4Default($invFrameMatrix->m00 * $homogenous0->x + $invFrameMatrix->m10 * $homogenous0->y + $invFrameMatrix->m20 * $homogenous0->z + $invFrameMatrix->m30 * $homogenous0->w, $invFrameMatrix->m01 * $homogenous0->x + $invFrameMatrix->m11 * $homogenous0->y + $invFrameMatrix->m21 * $homogenous0->z + $invFrameMatrix->m31 * $homogenous0->w, $invFrameMatrix->m02 * $homogenous0->x + $invFrameMatrix->m12 * $homogenous0->y + $invFrameMatrix->m22 * $homogenous0->z + $invFrameMatrix->m32 * $homogenous0->w, $invFrameMatrix->m03 * $homogenous0->x + $invFrameMatrix->m13 * $homogenous0->y + $invFrameMatrix->m23 * $homogenous0->z + $invFrameMatrix->m33 * $homogenous0->w);
			$a1 = $this9;
			$this10 = new hxmath_math_Vector4Default($self4->m00 * $homogenous0->x + $self4->m10 * $homogenous0->y + $self4->m20 * $homogenous0->z + $self4->m30 * $homogenous0->w, $self4->m01 * $homogenous0->x + $self4->m11 * $homogenous0->y + $self4->m21 * $homogenous0->z + $self4->m31 * $homogenous0->w, $self4->m02 * $homogenous0->x + $self4->m12 * $homogenous0->y + $self4->m22 * $homogenous0->z + $self4->m32 * $homogenous0->w, $self4->m03 * $homogenous0->x + $self4->m13 * $homogenous0->y + $self4->m23 * $homogenous0->z + $self4->m33 * $homogenous0->w);
			$b1 = $this10;
			$this11 = new hxmath_math_Vector4Default($a1->x, $a1->y, $a1->z, $a1->w);
			$self5 = $this11;
			$self5->x -= $b1->x;
			$self5->y -= $b1->y;
			$self5->z -= $b1->z;
			$self5->w -= $b1->w;
			$self6 = $self5;
			$tmp1 = $self6->x * $self6->x + $self6->y * $self6->y + $self6->z * $self6->z + $self6->w * $self6->w;
			$this->assertApproxEquals(0.0, $tmp1, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 126, "className" => "test.Test3D", "methodName" => "testMatrixFrameInverse")));
			$this12 = new hxmath_math_Vector4Default($invFrameMatrix->m00 * $homogenousX->x + $invFrameMatrix->m10 * $homogenousX->y + $invFrameMatrix->m20 * $homogenousX->z + $invFrameMatrix->m30 * $homogenousX->w, $invFrameMatrix->m01 * $homogenousX->x + $invFrameMatrix->m11 * $homogenousX->y + $invFrameMatrix->m21 * $homogenousX->z + $invFrameMatrix->m31 * $homogenousX->w, $invFrameMatrix->m02 * $homogenousX->x + $invFrameMatrix->m12 * $homogenousX->y + $invFrameMatrix->m22 * $homogenousX->z + $invFrameMatrix->m32 * $homogenousX->w, $invFrameMatrix->m03 * $homogenousX->x + $invFrameMatrix->m13 * $homogenousX->y + $invFrameMatrix->m23 * $homogenousX->z + $invFrameMatrix->m33 * $homogenousX->w);
			$a2 = $this12;
			$this13 = new hxmath_math_Vector4Default($self4->m00 * $homogenousX->x + $self4->m10 * $homogenousX->y + $self4->m20 * $homogenousX->z + $self4->m30 * $homogenousX->w, $self4->m01 * $homogenousX->x + $self4->m11 * $homogenousX->y + $self4->m21 * $homogenousX->z + $self4->m31 * $homogenousX->w, $self4->m02 * $homogenousX->x + $self4->m12 * $homogenousX->y + $self4->m22 * $homogenousX->z + $self4->m32 * $homogenousX->w, $self4->m03 * $homogenousX->x + $self4->m13 * $homogenousX->y + $self4->m23 * $homogenousX->z + $self4->m33 * $homogenousX->w);
			$b2 = $this13;
			$this14 = new hxmath_math_Vector4Default($a2->x, $a2->y, $a2->z, $a2->w);
			$self7 = $this14;
			$self7->x -= $b2->x;
			$self7->y -= $b2->y;
			$self7->z -= $b2->z;
			$self7->w -= $b2->w;
			$self8 = $self7;
			$tmp2 = $self8->x * $self8->x + $self8->y * $self8->y + $self8->z * $self8->z + $self8->w * $self8->w;
			$this->assertApproxEquals(0.0, $tmp2, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 127, "className" => "test.Test3D", "methodName" => "testMatrixFrameInverse")));
			$this15 = new hxmath_math_Vector4Default($invFrameMatrix->m00 * $homogenousY->x + $invFrameMatrix->m10 * $homogenousY->y + $invFrameMatrix->m20 * $homogenousY->z + $invFrameMatrix->m30 * $homogenousY->w, $invFrameMatrix->m01 * $homogenousY->x + $invFrameMatrix->m11 * $homogenousY->y + $invFrameMatrix->m21 * $homogenousY->z + $invFrameMatrix->m31 * $homogenousY->w, $invFrameMatrix->m02 * $homogenousY->x + $invFrameMatrix->m12 * $homogenousY->y + $invFrameMatrix->m22 * $homogenousY->z + $invFrameMatrix->m32 * $homogenousY->w, $invFrameMatrix->m03 * $homogenousY->x + $invFrameMatrix->m13 * $homogenousY->y + $invFrameMatrix->m23 * $homogenousY->z + $invFrameMatrix->m33 * $homogenousY->w);
			$a3 = $this15;
			$this16 = new hxmath_math_Vector4Default($self4->m00 * $homogenousY->x + $self4->m10 * $homogenousY->y + $self4->m20 * $homogenousY->z + $self4->m30 * $homogenousY->w, $self4->m01 * $homogenousY->x + $self4->m11 * $homogenousY->y + $self4->m21 * $homogenousY->z + $self4->m31 * $homogenousY->w, $self4->m02 * $homogenousY->x + $self4->m12 * $homogenousY->y + $self4->m22 * $homogenousY->z + $self4->m32 * $homogenousY->w, $self4->m03 * $homogenousY->x + $self4->m13 * $homogenousY->y + $self4->m23 * $homogenousY->z + $self4->m33 * $homogenousY->w);
			$b3 = $this16;
			$this17 = new hxmath_math_Vector4Default($a3->x, $a3->y, $a3->z, $a3->w);
			$self9 = $this17;
			$self9->x -= $b3->x;
			$self9->y -= $b3->y;
			$self9->z -= $b3->z;
			$self9->w -= $b3->w;
			$self10 = $self9;
			$tmp3 = $self10->x * $self10->x + $self10->y * $self10->y + $self10->z * $self10->z + $self10->w * $self10->w;
			$this->assertApproxEquals(0.0, $tmp3, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 128, "className" => "test.Test3D", "methodName" => "testMatrixFrameInverse")));
			$this18 = new hxmath_math_Vector4Default($invFrameMatrix->m00 * $homogenousZ->x + $invFrameMatrix->m10 * $homogenousZ->y + $invFrameMatrix->m20 * $homogenousZ->z + $invFrameMatrix->m30 * $homogenousZ->w, $invFrameMatrix->m01 * $homogenousZ->x + $invFrameMatrix->m11 * $homogenousZ->y + $invFrameMatrix->m21 * $homogenousZ->z + $invFrameMatrix->m31 * $homogenousZ->w, $invFrameMatrix->m02 * $homogenousZ->x + $invFrameMatrix->m12 * $homogenousZ->y + $invFrameMatrix->m22 * $homogenousZ->z + $invFrameMatrix->m32 * $homogenousZ->w, $invFrameMatrix->m03 * $homogenousZ->x + $invFrameMatrix->m13 * $homogenousZ->y + $invFrameMatrix->m23 * $homogenousZ->z + $invFrameMatrix->m33 * $homogenousZ->w);
			$a4 = $this18;
			$this19 = new hxmath_math_Vector4Default($self4->m00 * $homogenousZ->x + $self4->m10 * $homogenousZ->y + $self4->m20 * $homogenousZ->z + $self4->m30 * $homogenousZ->w, $self4->m01 * $homogenousZ->x + $self4->m11 * $homogenousZ->y + $self4->m21 * $homogenousZ->z + $self4->m31 * $homogenousZ->w, $self4->m02 * $homogenousZ->x + $self4->m12 * $homogenousZ->y + $self4->m22 * $homogenousZ->z + $self4->m32 * $homogenousZ->w, $self4->m03 * $homogenousZ->x + $self4->m13 * $homogenousZ->y + $self4->m23 * $homogenousZ->z + $self4->m33 * $homogenousZ->w);
			$b4 = $this19;
			$this20 = new hxmath_math_Vector4Default($a4->x, $a4->y, $a4->z, $a4->w);
			$self11 = $this20;
			$self11->x -= $b4->x;
			$self11->y -= $b4->y;
			$self11->z -= $b4->z;
			$self11->w -= $b4->w;
			$self12 = $self11;
			$tmp4 = $self12->x * $self12->x + $self12->y * $self12->y + $self12->z * $self12->z + $self12->w * $self12->w;
			$this->assertApproxEquals(0.0, $tmp4, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 129, "className" => "test.Test3D", "methodName" => "testMatrixFrameInverse")));
			unset($u,$tz,$ty,$tx,$tmp4,$tmp3,$tmp2,$tmp1,$tmp,$this9,$this8,$this7,$this6,$this5,$this4,$this3,$this20,$this2,$this19,$this18,$this17,$this16,$this15,$this14,$this13,$this12,$this11,$this10,$this1,$self9,$self8,$self7,$self6,$self5,$self4,$self3,$self2,$self12,$self11,$self10,$self1,$self,$length,$invFrameMatrix,$invFrame,$homogenousZ,$homogenousY,$homogenousX,$homogenous0,$frame,$c,$b4,$b3,$b2,$b1,$b,$a4,$a3,$a2,$a1,$a);
		}
	}
	public function testQuaternionInverse() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$this1 = $this->randomQuaternion(null);
			$self = $this1;
			$tmp = $self->s * $self->s + $self->x * $self->x + $self->y * $self->y + $self->z * $self->z;
			$tmp1 = Math::sqrt($tmp);
			$_g1 = 1.0 / $tmp1;
			$this2 = new hxmath_math_QuaternionDefault($self->s, $self->x, $self->y, $self->z);
			$self1 = $this2;
			$self1->s *= $_g1;
			$self1->x *= $_g1;
			$self1->y *= $_g1;
			$self1->z *= $_g1;
			$this3 = new hxmath_math_QuaternionDefault($self1->s, $self1->x, $self1->y, $self1->z);
			$self2 = $this3;
			$self2->x = -$self2->x;
			$self2->y = -$self2->y;
			$self2->z = -$self2->z;
			$this4 = new hxmath_math_QuaternionDefault($self1->s * $self2->s - $self1->x * $self2->x - $self1->y * $self2->y - $self1->z * $self2->z, $self1->s * $self2->x + $self2->s * $self1->x + $self1->y * $self2->z - $self1->z * $self2->y, $self1->s * $self2->y + $self2->s * $self1->y + $self1->z * $self2->x - $self1->x * $self2->z, $self1->s * $self2->z + $self2->s * $self1->z + $self1->x * $self2->y - $self1->y * $self2->x);
			$p = $this4;
			$this->assertApproxEquals(1.0, $p->s, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 142, "className" => "test.Test3D", "methodName" => "testQuaternionInverse")));
			$this5 = new hxmath_math_Vector3Default($p->x, $p->y, $p->z);
			$self3 = $this5;
			$tmp2 = $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
			$tmp3 = Math::sqrt($tmp2);
			$this->assertApproxEquals(0.0, $tmp3, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 143, "className" => "test.Test3D", "methodName" => "testQuaternionInverse")));
			unset($tmp3,$tmp2,$tmp1,$tmp,$this5,$this4,$this3,$this2,$this1,$self3,$self2,$self1,$self,$p,$_g1);
		}
	}
	public function testOrthoNormalize() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$u = $this->randomVector3(null);
			$v = $this->randomVector3(null);
			$w = $this->randomVector3(null);
			{
				{
					$tmp = $u->x * $u->x + $u->y * $u->y + $u->z * $u->z;
					$length = Math::sqrt($tmp);
					if($length > 0.0) {
						$u->x /= $length;
						$u->y /= $length;
						$u->z /= $length;
					}
					unset($tmp,$length);
				}
				{
					$this1 = new hxmath_math_Vector3Default($v->x, $v->y, $v->z);
					$self = $this1;
					$s = ($self->x * $u->x + $self->y * $u->y + $self->z * $u->z) / ($u->x * $u->x + $u->y * $u->y + $u->z * $u->z);
					{
						$_g1 = 0;
						while($_g1 < 3) {
							$i = $_g1++;
							{
								$tmp1 = null;
								switch($i) {
								case 0:{
									$tmp1 = $u->x;
								}break;
								case 1:{
									$tmp1 = $u->y;
								}break;
								case 2:{
									$tmp1 = $u->z;
								}break;
								default:{
									throw new HException("Invalid element");
								}break;
								}
								$value = $tmp1;
								switch($i) {
								case 0:{
									$self->x = $value;
								}break;
								case 1:{
									$self->y = $value;
								}break;
								case 2:{
									$self->z = $value;
								}break;
								default:{
									throw new HException("Invalid element");
								}break;
								}
								unset($value,$tmp1);
							}
							unset($i);
						}
						unset($_g1);
					}
					{
						$self->x *= $s;
						$self->y *= $s;
						$self->z *= $s;
					}
					$v->x -= $self->x;
					$v->y -= $self->y;
					$v->z -= $self->z;
					unset($this1,$self,$s);
				}
				{
					$tmp2 = $v->x * $v->x + $v->y * $v->y + $v->z * $v->z;
					$length1 = Math::sqrt($tmp2);
					if($length1 > 0.0) {
						$v->x /= $length1;
						$v->y /= $length1;
						$v->z /= $length1;
					}
					unset($tmp2,$length1);
				}
				{
					$this2 = new hxmath_math_Vector3Default($w->x, $w->y, $w->z);
					$self1 = $this2;
					$s1 = ($self1->x * $u->x + $self1->y * $u->y + $self1->z * $u->z) / ($u->x * $u->x + $u->y * $u->y + $u->z * $u->z);
					{
						$_g2 = 0;
						while($_g2 < 3) {
							$i1 = $_g2++;
							{
								$tmp3 = null;
								switch($i1) {
								case 0:{
									$tmp3 = $u->x;
								}break;
								case 1:{
									$tmp3 = $u->y;
								}break;
								case 2:{
									$tmp3 = $u->z;
								}break;
								default:{
									throw new HException("Invalid element");
								}break;
								}
								$value1 = $tmp3;
								switch($i1) {
								case 0:{
									$self1->x = $value1;
								}break;
								case 1:{
									$self1->y = $value1;
								}break;
								case 2:{
									$self1->z = $value1;
								}break;
								default:{
									throw new HException("Invalid element");
								}break;
								}
								unset($value1,$tmp3);
							}
							unset($i1);
						}
						unset($_g2);
					}
					{
						$self1->x *= $s1;
						$self1->y *= $s1;
						$self1->z *= $s1;
					}
					$w->x -= $self1->x;
					$w->y -= $self1->y;
					$w->z -= $self1->z;
					unset($this2,$self1,$s1);
				}
				{
					$this3 = new hxmath_math_Vector3Default($w->x, $w->y, $w->z);
					$self2 = $this3;
					$s2 = ($self2->x * $v->x + $self2->y * $v->y + $self2->z * $v->z) / ($v->x * $v->x + $v->y * $v->y + $v->z * $v->z);
					{
						$_g3 = 0;
						while($_g3 < 3) {
							$i2 = $_g3++;
							{
								$tmp4 = null;
								switch($i2) {
								case 0:{
									$tmp4 = $v->x;
								}break;
								case 1:{
									$tmp4 = $v->y;
								}break;
								case 2:{
									$tmp4 = $v->z;
								}break;
								default:{
									throw new HException("Invalid element");
								}break;
								}
								$value2 = $tmp4;
								switch($i2) {
								case 0:{
									$self2->x = $value2;
								}break;
								case 1:{
									$self2->y = $value2;
								}break;
								case 2:{
									$self2->z = $value2;
								}break;
								default:{
									throw new HException("Invalid element");
								}break;
								}
								unset($value2,$tmp4);
							}
							unset($i2);
						}
						unset($_g3);
					}
					{
						$self2->x *= $s2;
						$self2->y *= $s2;
						$self2->z *= $s2;
					}
					$w->x -= $self2->x;
					$w->y -= $self2->y;
					$w->z -= $self2->z;
					unset($this3,$self2,$s2);
				}
				{
					$tmp5 = $w->x * $w->x + $w->y * $w->y + $w->z * $w->z;
					$length2 = Math::sqrt($tmp5);
					if($length2 > 0.0) {
						$w->x /= $length2;
						$w->y /= $length2;
						$w->z /= $length2;
					}
					unset($tmp5,$length2);
				}
			}
			$tmp6 = $u->x * $u->x + $u->y * $u->y + $u->z * $u->z;
			$tmp7 = Math::sqrt($tmp6);
			$this->assertApproxEquals(1.0, $tmp7, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 157, "className" => "test.Test3D", "methodName" => "testOrthoNormalize")));
			$tmp8 = $v->x * $v->x + $v->y * $v->y + $v->z * $v->z;
			$tmp9 = Math::sqrt($tmp8);
			$this->assertApproxEquals(1.0, $tmp9, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 158, "className" => "test.Test3D", "methodName" => "testOrthoNormalize")));
			$tmp10 = $w->x * $w->x + $w->y * $w->y + $w->z * $w->z;
			$tmp11 = Math::sqrt($tmp10);
			$this->assertApproxEquals(1.0, $tmp11, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 159, "className" => "test.Test3D", "methodName" => "testOrthoNormalize")));
			$tmp12 = $u->x * $v->x + $u->y * $v->y + $u->z * $v->z;
			$this->assertApproxEquals(0.0, $tmp12, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 160, "className" => "test.Test3D", "methodName" => "testOrthoNormalize")));
			$tmp13 = $u->x * $w->x + $u->y * $w->y + $u->z * $w->z;
			$this->assertApproxEquals(0.0, $tmp13, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 161, "className" => "test.Test3D", "methodName" => "testOrthoNormalize")));
			$tmp14 = $v->x * $w->x + $v->y * $w->y + $v->z * $w->z;
			$this->assertApproxEquals(0.0, $tmp14, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 162, "className" => "test.Test3D", "methodName" => "testOrthoNormalize")));
			$this4 = new hxmath_math_Vector3Default($u->x, $u->y, $u->z);
			$self3 = $this4;
			$newX = $self3->y * $v->z - $self3->z * $v->y;
			$newY = $self3->z * $v->x - $self3->x * $v->z;
			$newZ = $self3->x * $v->y - $self3->y * $v->x;
			$self3->x = $newX;
			$self3->y = $newY;
			$self3->z = $newZ;
			$this5 = new hxmath_math_Vector3Default($self3->x, $self3->y, $self3->z);
			$self4 = $this5;
			$newX1 = $self4->y * $w->z - $self4->z * $w->y;
			$newY1 = $self4->z * $w->x - $self4->x * $w->z;
			$newZ1 = $self4->x * $w->y - $self4->y * $w->x;
			$self4->x = $newX1;
			$self4->y = $newY1;
			$self4->z = $newZ1;
			$self5 = $self4;
			$tmp15 = $self5->x * $self5->x + $self5->y * $self5->y + $self5->z * $self5->z;
			$tmp16 = Math::sqrt($tmp15);
			$this->assertApproxEquals(0.0, $tmp16, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 164, "className" => "test.Test3D", "methodName" => "testOrthoNormalize")));
			unset($w,$v,$u,$tmp9,$tmp8,$tmp7,$tmp6,$tmp16,$tmp15,$tmp14,$tmp13,$tmp12,$tmp11,$tmp10,$this5,$this4,$self5,$self4,$self3,$newZ1,$newZ,$newY1,$newY,$newX1,$newX);
		}
	}
	public function testAngles() {
		$this1 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$this2 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$b = $this2;
		$self = $this1;
		$tmp = $self->x * $b->x + $self->y * $b->y + $self->z * $b->z;
		$tmp1 = $self->x * $self->x + $self->y * $self->y + $self->z * $self->z;
		$tmp2 = Math::sqrt($tmp1);
		$tmp3 = $b->x * $b->x + $b->y * $b->y + $b->z * $b->z;
		$tmp4 = Math::sqrt($tmp3);
		$tmp5 = Math::acos($tmp / ($tmp2 * $tmp4));
		$tmp6 = Math::$PI / 2.0;
		$this->assertApproxEquals($tmp5, $tmp6, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 170, "className" => "test.Test3D", "methodName" => "testAngles")));
		$this3 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$this4 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$b1 = $this4;
		$self1 = $this3;
		$tmp7 = $self1->x * $b1->x + $self1->y * $b1->y + $self1->z * $b1->z;
		$tmp8 = $self1->x * $self1->x + $self1->y * $self1->y + $self1->z * $self1->z;
		$tmp9 = Math::sqrt($tmp8);
		$tmp10 = $b1->x * $b1->x + $b1->y * $b1->y + $b1->z * $b1->z;
		$tmp11 = Math::sqrt($tmp10);
		$tmp12 = Math::acos($tmp7 / ($tmp9 * $tmp11));
		$tmp13 = Math::$PI / 2.0;
		$this->assertApproxEquals($tmp12, $tmp13, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 171, "className" => "test.Test3D", "methodName" => "testAngles")));
		$this5 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$this6 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$b2 = $this6;
		$self2 = $this5;
		$tmp14 = $self2->x * $b2->x + $self2->y * $b2->y + $self2->z * $b2->z;
		$tmp15 = $self2->x * $self2->x + $self2->y * $self2->y + $self2->z * $self2->z;
		$tmp16 = Math::sqrt($tmp15);
		$tmp17 = $b2->x * $b2->x + $b2->y * $b2->y + $b2->z * $b2->z;
		$tmp18 = Math::sqrt($tmp17);
		$tmp19 = Math::acos($tmp14 / ($tmp16 * $tmp18));
		$tmp20 = Math::$PI / 2.0;
		$this->assertApproxEquals($tmp19, $tmp20, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 172, "className" => "test.Test3D", "methodName" => "testAngles")));
	}
	public function testReflect() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$u = $this->randomVector3(null);
			$this1 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
			$normal = $this1;
			$this2 = new hxmath_math_Vector3Default($u->x, $u->y, $u->z);
			$self = $this2;
			$this3 = new hxmath_math_Vector3Default($self->x, $self->y, $self->z);
			$self1 = $this3;
			$s = ($self1->x * $normal->x + $self1->y * $normal->y + $self1->z * $normal->z) / ($normal->x * $normal->x + $normal->y * $normal->y + $normal->z * $normal->z);
			{
				$_g1 = 0;
				while($_g1 < 3) {
					$i = $_g1++;
					{
						$tmp = null;
						switch($i) {
						case 0:{
							$tmp = $normal->x;
						}break;
						case 1:{
							$tmp = $normal->y;
						}break;
						case 2:{
							$tmp = $normal->z;
						}break;
						default:{
							throw new HException("Invalid element");
						}break;
						}
						$value = $tmp;
						switch($i) {
						case 0:{
							$self1->x = $value;
						}break;
						case 1:{
							$self1->y = $value;
						}break;
						case 2:{
							$self1->z = $value;
						}break;
						default:{
							throw new HException("Invalid element");
						}break;
						}
						unset($value,$tmp);
					}
					unset($i);
				}
				unset($_g1);
			}
			{
				$self1->x *= $s;
				$self1->y *= $s;
				$self1->z *= $s;
			}
			{
				$self1->x *= 2.0;
				$self1->y *= 2.0;
				$self1->z *= 2.0;
			}
			{
				$self->x -= $self1->x;
				$self->y -= $self1->y;
				$self->z -= $self1->z;
			}
			$this->assertEquals($u->x, $self->x, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 182, "className" => "test.Test3D", "methodName" => "testReflect")));
			$this->assertEquals($u->y, $self->y, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 183, "className" => "test.Test3D", "methodName" => "testReflect")));
			$this->assertEquals(-$u->z, $self->z, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 184, "className" => "test.Test3D", "methodName" => "testReflect")));
			unset($u,$this3,$this2,$this1,$self1,$self,$s,$normal);
		}
	}
	public function testProjectOntoPlane() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$u = $this->randomVector3(null);
			$normal = $this->randomVector3(null);
			{
				$this1 = new hxmath_math_Vector3Default($u->x, $u->y, $u->z);
				$self = $this1;
				$s = ($self->x * $normal->x + $self->y * $normal->y + $self->z * $normal->z) / ($normal->x * $normal->x + $normal->y * $normal->y + $normal->z * $normal->z);
				{
					$_g1 = 0;
					while($_g1 < 3) {
						$i = $_g1++;
						{
							$tmp = null;
							switch($i) {
							case 0:{
								$tmp = $normal->x;
							}break;
							case 1:{
								$tmp = $normal->y;
							}break;
							case 2:{
								$tmp = $normal->z;
							}break;
							default:{
								throw new HException("Invalid element");
							}break;
							}
							$value = $tmp;
							switch($i) {
							case 0:{
								$self->x = $value;
							}break;
							case 1:{
								$self->y = $value;
							}break;
							case 2:{
								$self->z = $value;
							}break;
							default:{
								throw new HException("Invalid element");
							}break;
							}
							unset($value,$tmp);
						}
						unset($i);
					}
					unset($_g1);
				}
				{
					$self->x *= $s;
					$self->y *= $s;
					$self->z *= $s;
				}
				$u->x -= $self->x;
				$u->y -= $self->y;
				$u->z -= $self->z;
				unset($this1,$self,$s);
			}
			$tmp1 = $u->x * $normal->x + $u->y * $normal->y + $u->z * $normal->z;
			$this->assertApproxEquals(0.0, $tmp1, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 197, "className" => "test.Test3D", "methodName" => "testProjectOntoPlane")));
			unset($u,$tmp1,$normal);
		}
	}
	public function testSlerpMidpointAngle() {
		$this1 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$axis = $this1;
		$angleRadians = Math::$PI / 180 * 0;
		$cosHalfAngle = Math::cos($angleRadians / 2.0);
		$sinHalfAngle = Math::sin($angleRadians / 2.0);
		$this2 = new hxmath_math_QuaternionDefault($cosHalfAngle, $sinHalfAngle * $axis->x, $sinHalfAngle * $axis->y, $sinHalfAngle * $axis->z);
		$qA = $this2;
		$this3 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$axis1 = $this3;
		$angleRadians1 = Math::$PI / 180 * 90;
		$cosHalfAngle1 = Math::cos($angleRadians1 / 2.0);
		$sinHalfAngle1 = Math::sin($angleRadians1 / 2.0);
		$this4 = new hxmath_math_QuaternionDefault($cosHalfAngle1, $sinHalfAngle1 * $axis1->x, $sinHalfAngle1 * $axis1->y, $sinHalfAngle1 * $axis1->z);
		$qB = $this4;
		$cosHalfTheta = $qA->s * $qB->s + $qA->x * $qB->x + $qA->y * $qB->y + $qA->z * $qB->z;
		$qC = null;
		$tmp = Math::abs($cosHalfTheta);
		if($tmp >= 1.0) {
			$qC = $qA;
		} else {
			$halfTheta = Math::acos($cosHalfTheta);
			$sinHalfTheta = Math::sqrt(1.0 - $cosHalfTheta * $cosHalfTheta);
			$tmp1 = Math::abs($sinHalfTheta);
			if($tmp1 < 1e-3) {
				$this5 = new hxmath_math_QuaternionDefault($qA->s, $qA->x, $qA->y, $qA->z);
				$self = $this5;
				$self->s *= 0.5;
				$self->x *= 0.5;
				$self->y *= 0.5;
				$self->z *= 0.5;
				$this6 = new hxmath_math_QuaternionDefault($qB->s, $qB->x, $qB->y, $qB->z);
				$self1 = $this6;
				$self1->s *= 0.5;
				$self1->x *= 0.5;
				$self1->y *= 0.5;
				$self1->z *= 0.5;
				$this7 = new hxmath_math_QuaternionDefault($self->s, $self->x, $self->y, $self->z);
				$self2 = $this7;
				$self2->s += $self1->s;
				$self2->x += $self1->x;
				$self2->y += $self1->y;
				$self2->z += $self1->z;
				$self3 = $self2;
				$tmp2 = $self3->s * $self3->s + $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
				$length = Math::sqrt($tmp2);
				if($length > 0.0) {
					$k = 1.0 / $length;
					{
						$self3->s *= $k;
						$self3->x *= $k;
						$self3->y *= $k;
						$self3->z *= $k;
					}
				}
				$qC = $self3;
			} else {
				$tmp3 = Math::sin(0.5 * $halfTheta);
				$ta = $tmp3 / $sinHalfTheta;
				$tmp4 = Math::sin(0.5 * $halfTheta);
				$tb = $tmp4 / $sinHalfTheta;
				$this8 = new hxmath_math_QuaternionDefault(0, 0, 0, 0);
				$result = $this8;
				$tmp5 = $qA->x * $ta;
				$tmp6 = $qB->x * $tb;
				$result->x = $tmp5 + $tmp6;
				$tmp7 = $qA->y * $ta;
				$tmp8 = $qB->y * $tb;
				$result->y = $tmp7 + $tmp8;
				$tmp9 = $qA->z * $ta;
				$tmp10 = $qB->z * $tb;
				$result->z = $tmp9 + $tmp10;
				$tmp11 = $qA->s * $ta;
				$tmp12 = $qB->s * $tb;
				$result->s = $tmp11 + $tmp12;
				$qC = $result;
			}
		}
		$tmp13 = $qA->s * $qC->s + $qA->x * $qC->x + $qA->y * $qC->y + $qA->z * $qC->z;
		$tmp14 = $qA->s * $qA->s + $qA->x * $qA->x + $qA->y * $qA->y + $qA->z * $qA->z;
		$tmp15 = Math::sqrt($tmp14);
		$self4 = $qC;
		$tmp16 = $self4->s * $self4->s + $self4->x * $self4->x + $self4->y * $self4->y + $self4->z * $self4->z;
		$tmp17 = Math::sqrt($tmp16);
		$tmp18 = Math::acos($tmp13 / ($tmp15 * $tmp17));
		$angleAC = 2.0 * $tmp18 * 180.0 / Math::$PI;
		$self5 = $qC;
		$tmp19 = $self5->s * $qB->s + $self5->x * $qB->x + $self5->y * $qB->y + $self5->z * $qB->z;
		$tmp20 = $self5->s * $self5->s + $self5->x * $self5->x + $self5->y * $self5->y + $self5->z * $self5->z;
		$tmp21 = Math::sqrt($tmp20);
		$tmp22 = $qB->s * $qB->s + $qB->x * $qB->x + $qB->y * $qB->y + $qB->z * $qB->z;
		$tmp23 = Math::sqrt($tmp22);
		$tmp24 = Math::acos($tmp19 / ($tmp21 * $tmp23));
		$angleCB = 2.0 * $tmp24 * 180.0 / Math::$PI;
		$this->assertApproxEquals(45.0, $angleAC, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 209, "className" => "test.Test3D", "methodName" => "testSlerpMidpointAngle")));
		$this->assertApproxEquals(45.0, $angleCB, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 210, "className" => "test.Test3D", "methodName" => "testSlerpMidpointAngle")));
	}
	public function testSlerpMonotonicity() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$this1 = $this->randomQuaternion(null);
			$self = $this1;
			$tmp = $self->s * $self->s + $self->x * $self->x + $self->y * $self->y + $self->z * $self->z;
			$length = Math::sqrt($tmp);
			if($length > 0.0) {
				$k = 1.0 / $length;
				{
					$self->s *= $k;
					$self->x *= $k;
					$self->y *= $k;
					$self->z *= $k;
				}
				unset($k);
			}
			$this2 = $this->randomQuaternion(null);
			$self1 = $this2;
			$tmp1 = $self1->s * $self1->s + $self1->x * $self1->x + $self1->y * $self1->y + $self1->z * $self1->z;
			$length1 = Math::sqrt($tmp1);
			if($length1 > 0.0) {
				$k1 = 1.0 / $length1;
				{
					$self1->s *= $k1;
					$self1->x *= $k1;
					$self1->y *= $k1;
					$self1->z *= $k1;
				}
				unset($k1);
			}
			$lastAC = Math::$NEGATIVE_INFINITY;
			$lastCB = Math::$POSITIVE_INFINITY;
			{
				$_g1 = 1;
				while($_g1 < 12) {
					$step = $_g1++;
					$t = $step / 12;
					$cosHalfTheta = $self->s * $self1->s + $self->x * $self1->x + $self->y * $self1->y + $self->z * $self1->z;
					$qC = null;
					$tmp2 = Math::abs($cosHalfTheta);
					if($tmp2 >= 1.0) {
						$qC = $self;
					} else {
						$halfTheta = Math::acos($cosHalfTheta);
						$sinHalfTheta = Math::sqrt(1.0 - $cosHalfTheta * $cosHalfTheta);
						$tmp3 = Math::abs($sinHalfTheta);
						if($tmp3 < 1e-3) {
							$s = 1.0 - $t;
							$this3 = new hxmath_math_QuaternionDefault($self->s, $self->x, $self->y, $self->z);
							$self2 = $this3;
							$self2->s *= $s;
							$self2->x *= $s;
							$self2->y *= $s;
							$self2->z *= $s;
							$this4 = new hxmath_math_QuaternionDefault($self1->s, $self1->x, $self1->y, $self1->z);
							$self3 = $this4;
							$self3->s *= $t;
							$self3->x *= $t;
							$self3->y *= $t;
							$self3->z *= $t;
							$this5 = new hxmath_math_QuaternionDefault($self2->s, $self2->x, $self2->y, $self2->z);
							$self4 = $this5;
							$self4->s += $self3->s;
							$self4->x += $self3->x;
							$self4->y += $self3->y;
							$self4->z += $self3->z;
							$self5 = $self4;
							$tmp4 = $self5->s * $self5->s + $self5->x * $self5->x + $self5->y * $self5->y + $self5->z * $self5->z;
							$length2 = Math::sqrt($tmp4);
							if($length2 > 0.0) {
								$k2 = 1.0 / $length2;
								{
									$self5->s *= $k2;
									$self5->x *= $k2;
									$self5->y *= $k2;
									$self5->z *= $k2;
								}
								unset($k2);
							}
							$qC = $self5;
							unset($tmp4,$this5,$this4,$this3,$self5,$self4,$self3,$self2,$s,$length2);
						} else {
							$tmp5 = Math::sin((1 - $t) * $halfTheta);
							$ta = $tmp5 / $sinHalfTheta;
							$tmp6 = Math::sin($t * $halfTheta);
							$tb = $tmp6 / $sinHalfTheta;
							$this6 = new hxmath_math_QuaternionDefault(0, 0, 0, 0);
							$result = $this6;
							$tmp7 = $self->x * $ta;
							$tmp8 = $self1->x * $tb;
							$result->x = $tmp7 + $tmp8;
							$tmp9 = $self->y * $ta;
							$tmp10 = $self1->y * $tb;
							$result->y = $tmp9 + $tmp10;
							$tmp11 = $self->z * $ta;
							$tmp12 = $self1->z * $tb;
							$result->z = $tmp11 + $tmp12;
							$tmp13 = $self->s * $ta;
							$tmp14 = $self1->s * $tb;
							$result->s = $tmp13 + $tmp14;
							$qC = $result;
							unset($tmp9,$tmp8,$tmp7,$tmp6,$tmp5,$tmp14,$tmp13,$tmp12,$tmp11,$tmp10,$this6,$tb,$ta,$result);
						}
						unset($tmp3,$sinHalfTheta,$halfTheta);
					}
					$tmp15 = $self->s * $qC->s + $self->x * $qC->x + $self->y * $qC->y + $self->z * $qC->z;
					$tmp16 = $self->s * $self->s + $self->x * $self->x + $self->y * $self->y + $self->z * $self->z;
					$tmp17 = Math::sqrt($tmp16);
					$self6 = $qC;
					$tmp18 = $self6->s * $self6->s + $self6->x * $self6->x + $self6->y * $self6->y + $self6->z * $self6->z;
					$tmp19 = Math::sqrt($tmp18);
					$tmp20 = Math::acos($tmp15 / ($tmp17 * $tmp19));
					$angleAC = 2.0 * $tmp20 * 180.0 / Math::$PI;
					$self7 = $qC;
					$tmp21 = $self7->s * $self1->s + $self7->x * $self1->x + $self7->y * $self1->y + $self7->z * $self1->z;
					$tmp22 = $self7->s * $self7->s + $self7->x * $self7->x + $self7->y * $self7->y + $self7->z * $self7->z;
					$tmp23 = Math::sqrt($tmp22);
					$tmp24 = $self1->s * $self1->s + $self1->x * $self1->x + $self1->y * $self1->y + $self1->z * $self1->z;
					$tmp25 = Math::sqrt($tmp24);
					$tmp26 = Math::acos($tmp21 / ($tmp23 * $tmp25));
					$angleCB = 2.0 * $tmp26 * 180.0 / Math::$PI;
					$this->assertTrue($angleAC > $lastAC, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 230, "className" => "test.Test3D", "methodName" => "testSlerpMonotonicity")));
					$this->assertTrue($angleCB < $lastCB, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 231, "className" => "test.Test3D", "methodName" => "testSlerpMonotonicity")));
					$lastAC = $angleAC;
					$lastCB = $angleCB;
					unset($tmp26,$tmp25,$tmp24,$tmp23,$tmp22,$tmp21,$tmp20,$tmp2,$tmp19,$tmp18,$tmp17,$tmp16,$tmp15,$t,$step,$self7,$self6,$qC,$cosHalfTheta,$angleCB,$angleAC);
				}
				unset($_g1);
			}
			unset($tmp1,$tmp,$this2,$this1,$self1,$self,$length1,$length,$lastCB,$lastAC);
		}
	}
	public function testSlerpLargeAngleStability() {
		$this1 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$axis = $this1;
		$angleRadians = Math::$PI / 180 * 0;
		$cosHalfAngle = Math::cos($angleRadians / 2.0);
		$sinHalfAngle = Math::sin($angleRadians / 2.0);
		$this2 = new hxmath_math_QuaternionDefault($cosHalfAngle, $sinHalfAngle * $axis->x, $sinHalfAngle * $axis->y, $sinHalfAngle * $axis->z);
		$qA = $this2;
		$this3 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$axis1 = $this3;
		$angleRadians1 = Math::$PI / 180 * 180;
		$cosHalfAngle1 = Math::cos($angleRadians1 / 2.0);
		$sinHalfAngle1 = Math::sin($angleRadians1 / 2.0);
		$this4 = new hxmath_math_QuaternionDefault($cosHalfAngle1, $sinHalfAngle1 * $axis1->x, $sinHalfAngle1 * $axis1->y, $sinHalfAngle1 * $axis1->z);
		$qB = $this4;
		$cosHalfTheta = $qA->s * $qB->s + $qA->x * $qB->x + $qA->y * $qB->y + $qA->z * $qB->z;
		$qC = null;
		$tmp = Math::abs($cosHalfTheta);
		if($tmp >= 1.0) {
			$qC = $qA;
		} else {
			$halfTheta = Math::acos($cosHalfTheta);
			$sinHalfTheta = Math::sqrt(1.0 - $cosHalfTheta * $cosHalfTheta);
			$tmp1 = Math::abs($sinHalfTheta);
			if($tmp1 < 1e-3) {
				$this5 = new hxmath_math_QuaternionDefault($qA->s, $qA->x, $qA->y, $qA->z);
				$self = $this5;
				$self->s *= 0.5;
				$self->x *= 0.5;
				$self->y *= 0.5;
				$self->z *= 0.5;
				$this6 = new hxmath_math_QuaternionDefault($qB->s, $qB->x, $qB->y, $qB->z);
				$self1 = $this6;
				$self1->s *= 0.5;
				$self1->x *= 0.5;
				$self1->y *= 0.5;
				$self1->z *= 0.5;
				$this7 = new hxmath_math_QuaternionDefault($self->s, $self->x, $self->y, $self->z);
				$self2 = $this7;
				$self2->s += $self1->s;
				$self2->x += $self1->x;
				$self2->y += $self1->y;
				$self2->z += $self1->z;
				$self3 = $self2;
				$tmp2 = $self3->s * $self3->s + $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
				$length = Math::sqrt($tmp2);
				if($length > 0.0) {
					$k = 1.0 / $length;
					{
						$self3->s *= $k;
						$self3->x *= $k;
						$self3->y *= $k;
						$self3->z *= $k;
					}
				}
				$qC = $self3;
			} else {
				$tmp3 = Math::sin(0.5 * $halfTheta);
				$ta = $tmp3 / $sinHalfTheta;
				$tmp4 = Math::sin(0.5 * $halfTheta);
				$tb = $tmp4 / $sinHalfTheta;
				$this8 = new hxmath_math_QuaternionDefault(0, 0, 0, 0);
				$result = $this8;
				$tmp5 = $qA->x * $ta;
				$tmp6 = $qB->x * $tb;
				$result->x = $tmp5 + $tmp6;
				$tmp7 = $qA->y * $ta;
				$tmp8 = $qB->y * $tb;
				$result->y = $tmp7 + $tmp8;
				$tmp9 = $qA->z * $ta;
				$tmp10 = $qB->z * $tb;
				$result->z = $tmp9 + $tmp10;
				$tmp11 = $qA->s * $ta;
				$tmp12 = $qB->s * $tb;
				$result->s = $tmp11 + $tmp12;
				$qC = $result;
			}
		}
		$self4 = $qC;
		$tmp13 = $self4->s * $qA->s + $self4->x * $qA->x + $self4->y * $qA->y + $self4->z * $qA->z;
		$tmp14 = $self4->s * $self4->s + $self4->x * $self4->x + $self4->y * $self4->y + $self4->z * $self4->z;
		$tmp15 = Math::sqrt($tmp14);
		$tmp16 = $qA->s * $qA->s + $qA->x * $qA->x + $qA->y * $qA->y + $qA->z * $qA->z;
		$tmp17 = Math::sqrt($tmp16);
		$tmp18 = Math::acos($tmp13 / ($tmp15 * $tmp17));
		$tmp19 = 2.0 * $tmp18 * 180.0 / Math::$PI;
		$this->assertApproxEquals(90, $tmp19, null, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 244, "className" => "test.Test3D", "methodName" => "testSlerpLargeAngleStability")));
	}
	public function testSlerpSmallAngleStability() {
		$this1 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$axis = $this1;
		$angleRadians = Math::$PI / 180 * 0;
		$cosHalfAngle = Math::cos($angleRadians / 2.0);
		$sinHalfAngle = Math::sin($angleRadians / 2.0);
		$this2 = new hxmath_math_QuaternionDefault($cosHalfAngle, $sinHalfAngle * $axis->x, $sinHalfAngle * $axis->y, $sinHalfAngle * $axis->z);
		$qA = $this2;
		$this3 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$axis1 = $this3;
		$angleRadians1 = Math::$PI / 180 * 1e-2;
		$cosHalfAngle1 = Math::cos($angleRadians1 / 2.0);
		$sinHalfAngle1 = Math::sin($angleRadians1 / 2.0);
		$this4 = new hxmath_math_QuaternionDefault($cosHalfAngle1, $sinHalfAngle1 * $axis1->x, $sinHalfAngle1 * $axis1->y, $sinHalfAngle1 * $axis1->z);
		$qB = $this4;
		$cosHalfTheta = $qA->s * $qB->s + $qA->x * $qB->x + $qA->y * $qB->y + $qA->z * $qB->z;
		$qC = null;
		$tmp = Math::abs($cosHalfTheta);
		if($tmp >= 1.0) {
			$qC = $qA;
		} else {
			$halfTheta = Math::acos($cosHalfTheta);
			$sinHalfTheta = Math::sqrt(1.0 - $cosHalfTheta * $cosHalfTheta);
			$tmp1 = Math::abs($sinHalfTheta);
			if($tmp1 < 1e-3) {
				$this5 = new hxmath_math_QuaternionDefault($qA->s, $qA->x, $qA->y, $qA->z);
				$self = $this5;
				$self->s *= 0.5;
				$self->x *= 0.5;
				$self->y *= 0.5;
				$self->z *= 0.5;
				$this6 = new hxmath_math_QuaternionDefault($qB->s, $qB->x, $qB->y, $qB->z);
				$self1 = $this6;
				$self1->s *= 0.5;
				$self1->x *= 0.5;
				$self1->y *= 0.5;
				$self1->z *= 0.5;
				$this7 = new hxmath_math_QuaternionDefault($self->s, $self->x, $self->y, $self->z);
				$self2 = $this7;
				$self2->s += $self1->s;
				$self2->x += $self1->x;
				$self2->y += $self1->y;
				$self2->z += $self1->z;
				$self3 = $self2;
				$tmp2 = $self3->s * $self3->s + $self3->x * $self3->x + $self3->y * $self3->y + $self3->z * $self3->z;
				$length = Math::sqrt($tmp2);
				if($length > 0.0) {
					$k = 1.0 / $length;
					{
						$self3->s *= $k;
						$self3->x *= $k;
						$self3->y *= $k;
						$self3->z *= $k;
					}
				}
				$qC = $self3;
			} else {
				$tmp3 = Math::sin(0.5 * $halfTheta);
				$ta = $tmp3 / $sinHalfTheta;
				$tmp4 = Math::sin(0.5 * $halfTheta);
				$tb = $tmp4 / $sinHalfTheta;
				$this8 = new hxmath_math_QuaternionDefault(0, 0, 0, 0);
				$result = $this8;
				$tmp5 = $qA->x * $ta;
				$tmp6 = $qB->x * $tb;
				$result->x = $tmp5 + $tmp6;
				$tmp7 = $qA->y * $ta;
				$tmp8 = $qB->y * $tb;
				$result->y = $tmp7 + $tmp8;
				$tmp9 = $qA->z * $ta;
				$tmp10 = $qB->z * $tb;
				$result->z = $tmp9 + $tmp10;
				$tmp11 = $qA->s * $ta;
				$tmp12 = $qB->s * $tb;
				$result->s = $tmp11 + $tmp12;
				$qC = $result;
			}
		}
		$tmp13 = $qA->s * $qC->s + $qA->x * $qC->x + $qA->y * $qC->y + $qA->z * $qC->z;
		$tmp14 = $qA->s * $qA->s + $qA->x * $qA->x + $qA->y * $qA->y + $qA->z * $qA->z;
		$tmp15 = Math::sqrt($tmp14);
		$self4 = $qC;
		$tmp16 = $self4->s * $self4->s + $self4->x * $self4->x + $self4->y * $self4->y + $self4->z * $self4->z;
		$tmp17 = Math::sqrt($tmp16);
		$tmp18 = Math::acos($tmp13 / ($tmp15 * $tmp17));
		$this->assertTrue(2.0 * $tmp18 <= 1e-2, _hx_anonymous(array("fileName" => "Test3D.hx", "lineNumber" => 253, "className" => "test.Test3D", "methodName" => "testSlerpSmallAngleStability")));
	}
	function __toString() { return 'test.Test3D'; }
}
function test_Test3D_0($unitAngle, $axis) {
	{
		$this1 = new hxmath_math_Vector3Default(1.0, 0.0, 0.0);
		$tmp = $this1;
		$this2 = new hxmath_math_Vector3Default(0.0, 1.0, 0.0);
		$tmp1 = $this2;
		$this3 = new hxmath_math_Vector3Default(0.0, 0.0, 1.0);
		$axes = (new _hx_array(array($tmp, $tmp1, $this3)));
		$const = (new _hx_array(array((isset(hxmath_math__Matrix3x3_Matrix3x3_Impl_::$rotationX) ? hxmath_math__Matrix3x3_Matrix3x3_Impl_::$rotationX: array("hxmath_math__Matrix3x3_Matrix3x3_Impl_", "rotationX")), (isset(hxmath_math__Matrix3x3_Matrix3x3_Impl_::$rotationY) ? hxmath_math__Matrix3x3_Matrix3x3_Impl_::$rotationY: array("hxmath_math__Matrix3x3_Matrix3x3_Impl_", "rotationY")), (isset(hxmath_math__Matrix3x3_Matrix3x3_Impl_::$rotationZ) ? hxmath_math__Matrix3x3_Matrix3x3_Impl_::$rotationZ: array("hxmath_math__Matrix3x3_Matrix3x3_Impl_", "rotationZ")))));
		$angle = $unitAngle * 360.0;
		$axis1 = $axes[$axis];
		$angleRadians = Math::$PI / 180 * $angle;
		$cosHalfAngle = Math::cos($angleRadians / 2.0);
		$sinHalfAngle = Math::sin($angleRadians / 2.0);
		$this4 = new hxmath_math_QuaternionDefault($cosHalfAngle, $sinHalfAngle * $axis1->x, $sinHalfAngle * $axis1->y, $sinHalfAngle * $axis1->z);
		$q = $this4;
		$s = $q->s;
		$x = $q->x;
		$y = $q->y;
		$z = $q->z;
		$this5 = new hxmath_math_Matrix3x3Default(1 - 2 * ($y * $y + $z * $z), 2 * ($x * $y - $s * $z), 2 * ($s * $y + $x * $z), 2 * ($x * $y + $s * $z), 1 - 2 * ($x * $x + $z * $z), 2 * ($y * $z - $s * $x), 2 * ($x * $z - $s * $y), 2 * ($y * $z + $s * $x), 1 - 2 * ($x * $x + $y * $y));
		$m = $this5;
		$m1 = call_user_func_array($const[$axis], array($angle));
		return _hx_anonymous(array("m" => $m1, "n" => $m));
	}
}
