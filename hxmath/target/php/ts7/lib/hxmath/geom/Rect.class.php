<?php

// Generated by Haxe 3.3.0
class hxmath_geom_Rect {
	public function __construct($x, $y, $width, $height) {
		if(!php_Boot::$skip_constructor) {
		$this->x = $x;
		$this->y = $y;
		$this->width = $width;
		$this->height = $height;
	}}
	public $x;
	public $y;
	public $width;
	public $height;
	public function equals($r) {
		$tmp = null;
		$tmp1 = null;
		$tmp2 = null;
		if($r !== null) {
			$tmp2 = $this->x === $r->x;
		} else {
			$tmp2 = false;
		}
		if($tmp2) {
			$tmp1 = $this->y === $r->y;
		} else {
			$tmp1 = false;
		}
		if($tmp1) {
			$tmp = $this->width === $r->width;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return $this->height === $r->height;
		} else {
			return false;
		}
	}
	public function hclone() {
		return new hxmath_geom_Rect($this->x, $this->y, $this->width, $this->height);
	}
	public function copyTo($r) {
		$r->x = $this->x;
		$r->y = $this->y;
		$r->width = $this->width;
		$r->height = $this->height;
	}
	public function overlaps($r) {
		$aStart = $this->x;
		$aWidth = $this->width;
		$bStart = $r->x;
		$bWidth = $r->width;
		$tmp = null;
		if(!($aStart >= $bStart + $bWidth)) {
			$tmp = $bStart >= $aStart + $aWidth;
		} else {
			$tmp = true;
		}
		if(!$tmp) {
			$aStart1 = $this->y;
			$aWidth1 = $this->height;
			$bStart1 = $r->y;
			$bWidth1 = $r->height;
			$tmp1 = null;
			if(!($aStart1 >= $bStart1 + $bWidth1)) {
				$tmp1 = $bStart1 >= $aStart1 + $aWidth1;
			} else {
				$tmp1 = true;
			}
			return !$tmp1;
		} else {
			return false;
		}
	}
	public function intersect($r) {
		$_this = new hxmath_geom_Rect($this->x, $this->y, $this->width, $this->height);
		$tmp = $_this->x < $r->x;
		if($tmp) {
			$_this->width -= $r->x - $_this->x;
			$_this->x = $r->x;
		}
		$tmp1 = $_this->y < $r->y;
		if($tmp1) {
			$_this->height -= $r->y - $_this->y;
			$_this->y = $r->y;
		}
		$tmp2 = $_this->x + $_this->width > $r->x + $r->width;
		if($tmp2) {
			$tmp3 = $_this->x + $_this->width;
			$tmp4 = $r->x + $r->width;
			$_this->width -= $tmp3 - $tmp4;
		}
		$tmp5 = $_this->y + $_this->height > $r->y + $r->height;
		if($tmp5) {
			$tmp6 = $_this->y + $_this->height;
			$tmp7 = $r->y + $r->height;
			$_this->height -= $tmp6 - $tmp7;
		}
		return $_this;
	}
	public function intersectWith($r) {
		$tmp = $this->x < $r->x;
		if($tmp) {
			$this->width -= $r->x - $this->x;
			$this->x = $r->x;
		}
		$tmp1 = $this->y < $r->y;
		if($tmp1) {
			$this->height -= $r->y - $this->y;
			$this->y = $r->y;
		}
		$tmp2 = $this->x + $this->width > $r->x + $r->width;
		if($tmp2) {
			$tmp3 = $this->x + $this->width;
			$tmp4 = $r->x + $r->width;
			$this->width -= $tmp3 - $tmp4;
		}
		$tmp5 = $this->y + $this->height > $r->y + $r->height;
		if($tmp5) {
			$tmp6 = $this->y + $this->height;
			$tmp7 = $r->y + $r->height;
			$this->height -= $tmp6 - $tmp7;
		}
		return $this;
	}
	public function containsPoint($p) {
		$aStart = $this->x;
		$aWidth = $this->width;
		$x = $p->x;
		$tmp = null;
		if($x >= $aStart) {
			$tmp = $x <= $aStart + $aWidth;
		} else {
			$tmp = false;
		}
		if($tmp) {
			$aStart1 = $this->y;
			$aWidth1 = $this->height;
			$x1 = $p->y;
			if($x1 >= $aStart1) {
				return $x1 <= $aStart1 + $aWidth1;
			} else {
				return false;
			}
		} else {
			return false;
		}
	}
	public function distanceToPoint($p) {
		$tmp = $p->x;
		$tmp1 = $this->x + 0.5 * $this->width;
		$tmp2 = Math::abs($tmp - $tmp1);
		$tmp3 = $tmp2 - 0.5 * $this->width;
		$dx = Math::max($tmp3, 0);
		$tmp4 = $p->y;
		$tmp5 = $this->y + 0.5 * $this->height;
		$tmp6 = Math::abs($tmp4 - $tmp5);
		$tmp7 = $tmp6 - 0.5 * $this->height;
		$dy = Math::max($tmp7, 0);
		return Math::sqrt($dx * $dx + $dy * $dy);
	}
	public function distanceToRect($r) {
		$tmp = $r->x + 0.5 * $r->width;
		$tmp1 = $this->x + 0.5 * $this->width;
		$tmp2 = Math::abs($tmp - $tmp1);
		$tmp3 = 0.5 * ($this->width + $r->width);
		$dx = Math::max($tmp2 - $tmp3, 0);
		$tmp4 = $r->y + 0.5 * $r->height;
		$tmp5 = $this->y + 0.5 * $this->height;
		$tmp6 = Math::abs($tmp4 - $tmp5);
		$tmp7 = 0.5 * ($this->height + $r->height);
		$dy = Math::max($tmp6 - $tmp7, 0);
		return Math::sqrt($dx * $dx + $dy * $dy);
	}
	public function addWith($v) {
		$tmp = $v->x < 0.0;
		if($tmp) {
			$this->x += $v->x;
			$this->width -= $v->x;
		} else {
			$this->width += $v->x;
		}
		$tmp1 = $v->y < 0.0;
		if($tmp1) {
			$this->y += $v->y;
			$this->height -= $v->y;
		} else {
			$this->height += $v->y;
		}
		return $this;
	}
	public function getVertex($index) {
		$this1 = new hxmath_math_Vector2Default($this->x, $this->y);
		$v = $this1;
		switch($index) {
		case 0:{}break;
		case 1:{
			$v->x += $this->width;
		}break;
		case 2:{
			$v->x += $this->width;
			$v->y += $this->height;
		}break;
		case 3:{
			$v->y += $this->height;
		}break;
		default:{
			throw new HException("Invalid vertex index.");
		}break;
		}
		return $v;
	}
	public function get_center() {
		$this1 = new hxmath_math_Vector2Default($this->x + 0.5 * $this->width, $this->y + 0.5 * $this->height);
		return $this1;
	}
	public function get_matrix() {
		$this1 = new hxmath_math_Matrix3x2Default($this->width, 0.0, 0.0, $this->height, $this->x, $this->y);
		return $this1;
	}
	public function get_area() {
		return $this->width * $this->height;
	}
	public function get_isEmpty() {
		if(!($this->width <= 0.0)) {
			return $this->height <= 0.0;
		} else {
			return true;
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function fromTwoPoints($pointA, $pointB) {
		$tmp = Math::min($pointA->x, $pointB->x);
		$tmp1 = Math::min($pointA->y, $pointB->y);
		$tmp2 = $pointB->x - $pointA->x;
		$tmp3 = Math::abs($tmp2);
		$tmp4 = $pointB->y - $pointA->y;
		$tmp5 = Math::abs($tmp4);
		return new hxmath_geom_Rect($tmp, $tmp1, $tmp3, $tmp5);
	}
	static function fromRectShape($r) {
		return new hxmath_geom_Rect($r->x, $r->y, $r->width, $r->height);
	}
	static function fromMatrix($m) {
		return new hxmath_geom_Rect($m->tx, $m->ty, $m->a, $m->d);
	}
	static $__properties__ = array("get_isEmpty" => "get_isEmpty","get_area" => "get_area","get_matrix" => "get_matrix","get_center" => "get_center");
	function __toString() { return 'hxmath.geom.Rect'; }
}
