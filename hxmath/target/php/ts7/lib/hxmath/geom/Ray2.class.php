<?php

// Generated by Haxe 3.3.0
class hxmath_geom_Ray2 {
	public function __construct($origin, $normal) {
		if(!php_Boot::$skip_constructor) {
		$this->origin = $origin;
		$this->normal = $normal;
	}}
	public $origin;
	public $normal;
	public function heval($t) {
		$self = $this->normal;
		$this1 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this1;
		$self1->x *= $t;
		$self1->y *= $t;
		$b = $this->origin;
		$this2 = new hxmath_math_Vector2Default($self1->x, $self1->y);
		$self2 = $this2;
		$self2->x += $b->x;
		$self2->y += $b->y;
		return $self2;
	}
	public function intersectPoint($point, $tolerance = null) {
		if($tolerance === null) {
			$tolerance = 1e-6;
		}
		$self = $this->normal;
		$this1 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this1;
		$newX = -$self1->y;
		$self1->y = $self1->x;
		$self1->x = $newX;
		$b = $this->origin;
		$this2 = new hxmath_math_Vector2Default($point->x, $point->y);
		$self2 = $this2;
		$self2->x -= $b->x;
		$self2->y -= $b->y;
		$d = $self2->x * $self1->x + $self2->y * $self1->y;
		if($d < $tolerance) {
			$b1 = $this->origin;
			$this3 = new hxmath_math_Vector2Default($point->x, $point->y);
			$self3 = $this3;
			$self3->x -= $b1->x;
			$self3->y -= $b1->y;
			$b2 = $this->normal;
			$t = $self3->x * $b2->x + $self3->y * $b2->y;
			if($t >= 0.0) {
				return $t;
			}
		}
		return Math::$NEGATIVE_INFINITY;
	}
	public function getClosestPoint($points, $tolerance = null) {
		if($tolerance === null) {
			$tolerance = 1e-6;
		}
		$closestHit = Math::$NEGATIVE_INFINITY;
		$hitIndex = -1;
		$self = $this->normal;
		$this1 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this1;
		$newX = -$self1->y;
		$self1->y = $self1->x;
		$self1->x = $newX;
		{
			$_g1 = 0;
			$_g = $points->length;
			while($_g1 < $_g) {
				$i = $_g1++;
				$t = $this->intersectPoint($points[$i], $tolerance);
				$tmp = null;
				if($t > 0.0) {
					if($hitIndex !== -1) {
						if($t < $closestHit) {
							$tmp = $t >= 0.0;
						} else {
							$tmp = false;
						}
					} else {
						$tmp = true;
					}
				} else {
					$tmp = false;
				}
				if($tmp) {
					$hitIndex = $i;
					$closestHit = $t;
				}
				unset($tmp,$t,$i);
			}
		}
		return $hitIndex;
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'hxmath.geom.Ray2'; }
}
