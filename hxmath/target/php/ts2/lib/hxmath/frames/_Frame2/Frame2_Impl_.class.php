<?php

// Generated by Haxe 3.3.0
class hxmath_frames__Frame2_Frame2_Impl_ {
	public function __construct(){}
	static function _new($offset, $angleDegrees) {
		$this1 = new hxmath_frames_Frame2Default($offset, $angleDegrees, null);
		return $this1;
	}
	static function calculateMatrix($matrix, $offset, $angleDegrees) {
		{
			$angle = Math::$PI / 180 * $angleDegrees;
			$s = Math::sin($angle);
			$c = Math::cos($angle);
			$matrix->a = $c;
			$matrix->b = -$s;
			$matrix->c = $s;
			$matrix->d = $c;
		}
		{
			$x = $offset->x;
			$y = $offset->y;
			$matrix->tx = $x;
			$matrix->ty = $y;
		}
		return $matrix;
	}
	static function lerp($frameA, $frameB, $t) {
		$a = $frameA->get_offset();
		$b = $frameB->get_offset();
		$this1 = new hxmath_math_Vector2Default((1.0 - $t) * $a->x + $t * $b->x, (1.0 - $t) * $a->y + $t * $b->y);
		$tmp = $this1;
		$a1 = $frameA->get_angleDegrees();
		$b1 = $frameB->get_angleDegrees();
		$tmp1 = Math::abs($a1 - $b1);
		if($tmp1 > 180.) {
			$tmp2 = $a1 < $b1;
			if($tmp2) {
				$a1 += 360;
			} else {
				$b1 += 360;
			}
		}
		$x = (1.0 - $t) * $a1 + $t * $b1;
		$tmp3 = null;
		if($x < 0) {
			$tmp3 = 360 - _hx_mod(-$x, 360);
		} else {
			$tmp3 = _hx_mod($x, 360);
		}
		return hxmath_frames__Frame2_Frame2_Impl_::_new($tmp, $tmp3);
	}
	static function concat($this1, $other) {
		$self = $this1;
		$tmp = $self->get_offset();
		$tmp1 = $self->get_angleDegrees();
		$self1 = hxmath_frames__Frame2_Frame2_Impl_::_new($tmp, $tmp1);
		$this2 = $self1->get_matrix();
		$self2 = $this2;
		$this3 = new hxmath_math_Matrix2x2Default($self2->a, $self2->b, $self2->c, $self2->d);
		$m = $this3;
		$v = $other->get_offset();
		$this4 = new hxmath_math_Vector2Default($m->a * $v->x + $m->b * $v->y, $m->c * $v->x + $m->d * $v->y);
		$a = $self1->get_offset();
		$self3 = $this4;
		$self3->x += $a->x;
		$self3->y += $a->y;
		$tmp2 = $self1->get_angleDegrees();
		$tmp3 = $other->get_angleDegrees();
		$x = $tmp2 + $tmp3;
		$tmp4 = null;
		if($x < 0) {
			$tmp4 = 360 - _hx_mod(-$x, 360);
		} else {
			$tmp4 = _hx_mod($x, 360);
		}
		$self1->set_angleDegrees($tmp4);
		$self1->set_offset($self3);
		return $self1;
	}
	static function concatWith($this1, $other) {
		$self = $this1;
		$this2 = $self->get_matrix();
		$self1 = $this2;
		$this3 = new hxmath_math_Matrix2x2Default($self1->a, $self1->b, $self1->c, $self1->d);
		$m = $this3;
		$v = $other->get_offset();
		$this4 = new hxmath_math_Vector2Default($m->a * $v->x + $m->b * $v->y, $m->c * $v->x + $m->d * $v->y);
		$a = $self->get_offset();
		$self2 = $this4;
		$self2->x += $a->x;
		$self2->y += $a->y;
		$tmp = $self->get_angleDegrees();
		$tmp1 = $other->get_angleDegrees();
		$x = $tmp + $tmp1;
		$tmp2 = null;
		if($x < 0) {
			$tmp2 = 360 - _hx_mod(-$x, 360);
		} else {
			$tmp2 = _hx_mod($x, 360);
		}
		$self->set_angleDegrees($tmp2);
		$self->set_offset($self2);
		return $self;
	}
	static function transformFrom($this1, $p) {
		$self = $this1;
		$m = $self->get_matrix();
		$this2 = new hxmath_math_Matrix2x2Default($m->a, $m->b, $m->c, $m->d);
		$m1 = $this2;
		$this3 = new hxmath_math_Vector2Default($m1->a * $p->x + $m1->b * $p->y, $m1->c * $p->x + $m1->d * $p->y);
		$a = $this3;
		$this4 = new hxmath_math_Vector2Default($m->tx, $m->ty);
		$b = $this4;
		$this5 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self1 = $this5;
		$self1->x += $b->x;
		$self1->y += $b->y;
		return $self1;
	}
	static function transformTo($this1, $p) {
		$self = $this1;
		$this2 = $self->get_matrix();
		$self1 = $this2;
		$this3 = new hxmath_math_Matrix2x2Default($self1->a, $self1->b, $self1->c, $self1->d);
		$b = $self->get_offset();
		$this4 = new hxmath_math_Vector2Default($p->x, $p->y);
		$self2 = $this4;
		$self2->x -= $b->x;
		$self2->y -= $b->y;
		$self3 = $this3;
		$this5 = new hxmath_math_Vector2Default($self3->a * $self2->x + $self3->c * $self2->y, $self3->b * $self2->x + $self3->d * $self2->y);
		return $this5;
	}
	static function linearTransformFrom($this1, $v) {
		$self = $this1;
		$this2 = $self->get_matrix();
		$self1 = $this2;
		$this3 = new hxmath_math_Matrix2x2Default($self1->a, $self1->b, $self1->c, $self1->d);
		$m = $this3;
		$this4 = new hxmath_math_Vector2Default($m->a * $v->x + $m->b * $v->y, $m->c * $v->x + $m->d * $v->y);
		return $this4;
	}
	static function linearTransformTo($this1, $v) {
		$self = $this1;
		$this2 = $self->get_matrix();
		$self1 = $this2;
		$this3 = new hxmath_math_Matrix2x2Default($self1->a, $self1->b, $self1->c, $self1->d);
		$self2 = $this3;
		$this4 = new hxmath_math_Vector2Default($self2->a * $v->x + $self2->c * $v->y, $self2->b * $v->x + $self2->d * $v->y);
		return $this4;
	}
	static function inverse($this1) {
		$self = $this1;
		$this2 = $self->get_matrix();
		$self1 = $this2;
		$this3 = new hxmath_math_Matrix2x2Default($self1->a, $self1->b, $self1->c, $self1->d);
		$v = $self->get_offset();
		$self2 = $this3;
		$this4 = new hxmath_math_Vector2Default($self2->a * $v->x + $self2->c * $v->y, $self2->b * $v->x + $self2->d * $v->y);
		$self3 = $this4;
		$self3->x = -$self3->x;
		$self3->y = -$self3->y;
		return hxmath_frames__Frame2_Frame2_Impl_::_new($self3, -$self->get_angleDegrees());
	}
	static function hclone($this1) {
		$self = $this1;
		$tmp = $self->get_offset();
		$tmp1 = $self->get_angleDegrees();
		return hxmath_frames__Frame2_Frame2_Impl_::_new($tmp, $tmp1);
	}
	static function get_linearMatrix($this1) {
		$self = $this1;
		$this2 = $self->get_matrix();
		$self1 = $this2;
		$this3 = new hxmath_math_Matrix2x2Default($self1->a, $self1->b, $self1->c, $self1->d);
		return $this3;
	}
	static $__properties__ = array("get_linearMatrix" => "get_linearMatrix");
	function __toString() { return 'hxmath.frames._Frame2.Frame2_Impl_'; }
}
