<?php

// Generated by Haxe 3.3.0
class test_Test2D extends test_MathTestCase {
	public function __construct($posInfos = null) { if(!php_Boot::$skip_constructor) {
		parent::__construct($posInfos);
	}}
	public function testVector2BasicOps() {
		$this1 = new hxmath_math_Vector2Default(1.0, 0.0);
		$a = $this1;
		$this2 = new hxmath_math_Vector2Default(0.0, 1.0);
		$b = $this2;
		$tmp = $a->x * $b->x + $a->y * $b->y;
		$this->assertTrue($tmp === 0.0, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 14, "className" => "test.Test2D", "methodName" => "testVector2BasicOps")));
		$this3 = new hxmath_math_Vector2Default(1.0, 0.0);
		$_g1 = $this3;
		$this4 = new hxmath_math_Vector2Default($_g1->x, $_g1->y);
		$self = $this4;
		$self->x *= 0.0;
		$self->y *= 0.0;
		$this5 = new hxmath_math_Vector2Default(0.0, 0.0);
		$b1 = $this5;
		$tmp1 = null;
		$tmp2 = null;
		if($self === null) {
			$tmp2 = $b1 === null;
		} else {
			$tmp2 = false;
		}
		if(!$tmp2) {
			$tmp3 = null;
			$tmp4 = null;
			if($self !== null) {
				$tmp4 = $b1 !== null;
			} else {
				$tmp4 = false;
			}
			if($tmp4) {
				$tmp3 = $self->x === $b1->x;
			} else {
				$tmp3 = false;
			}
			if($tmp3) {
				$tmp1 = $self->y === $b1->y;
			} else {
				$tmp1 = false;
			}
		} else {
			$tmp1 = true;
		}
		$this->assertTrue($tmp1, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 15, "className" => "test.Test2D", "methodName" => "testVector2BasicOps")));
		$a1 = hxmath_math__IntVector2_IntVector2_Impl_::_new(1, 0);
		$b2 = hxmath_math__IntVector2_IntVector2_Impl_::_new(0, 1);
		$tmp5 = $a1->x * $b2->x + $a1->y * $b2->y;
		$this->assertTrue($tmp5 === 0, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 17, "className" => "test.Test2D", "methodName" => "testVector2BasicOps")));
		$_g3 = hxmath_math__IntVector2_IntVector2_Impl_::_new(1, 0);
		$self1 = hxmath_math__IntVector2_IntVector2_Impl_::_new($_g3->x, $_g3->y);
		$self1->x *= 0;
		$self1->y *= 0;
		$b3 = hxmath_math__IntVector2_IntVector2_Impl_::_new(0, 0);
		$tmp6 = null;
		$tmp7 = null;
		if($self1 === null) {
			$tmp7 = $b3 === null;
		} else {
			$tmp7 = false;
		}
		if(!$tmp7) {
			$tmp8 = null;
			$tmp9 = null;
			if($self1 !== null) {
				$tmp9 = $b3 !== null;
			} else {
				$tmp9 = false;
			}
			if($tmp9) {
				$tmp8 = $self1->x === $b3->x;
			} else {
				$tmp8 = false;
			}
			if($tmp8) {
				$tmp6 = $self1->y === $b3->y;
			} else {
				$tmp6 = false;
			}
		} else {
			$tmp6 = true;
		}
		$this->assertTrue($tmp6, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 18, "className" => "test.Test2D", "methodName" => "testVector2BasicOps")));
	}
	public function testDeterminant() {
		$this1 = new hxmath_math_Matrix2x2Default(1.0, 0.0, 0.0, 1.0);
		$self = $this1;
		$tmp = $self->a * $self->d - $self->b * $self->c;
		$this->assertTrue($tmp === 1.0, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 23, "className" => "test.Test2D", "methodName" => "testDeterminant")));
	}
	public function testHomogenousTranslation() {
		$this1 = new hxmath_math_Matrix3x2Default(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
		$m = $this1;
		{
			$this2 = new hxmath_math_Vector2Default(3, -1);
			$t = $this2;
			$m->tx = $t->x;
			$m->ty = $t->y;
		}
		$this3 = new hxmath_math_Vector2Default(0.0, 0.0);
		$v = $this3;
		$this4 = new hxmath_math_Matrix2x2Default($m->a, $m->b, $m->c, $m->d);
		$m1 = $this4;
		$this5 = new hxmath_math_Vector2Default($m1->a * $v->x + $m1->b * $v->y, $m1->c * $v->x + $m1->d * $v->y);
		$a = $this5;
		$this6 = new hxmath_math_Vector2Default($m->tx, $m->ty);
		$b = $this6;
		$this7 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self = $this7;
		$self->x += $b->x;
		$self->y += $b->y;
		$this8 = new hxmath_math_Vector2Default($m->tx, $m->ty);
		$b1 = $this8;
		$tmp = null;
		$tmp1 = null;
		if($self === null) {
			$tmp1 = $b1 === null;
		} else {
			$tmp1 = false;
		}
		if(!$tmp1) {
			$tmp2 = null;
			$tmp3 = null;
			if($self !== null) {
				$tmp3 = $b1 !== null;
			} else {
				$tmp3 = false;
			}
			if($tmp3) {
				$tmp2 = $self->x === $b1->x;
			} else {
				$tmp2 = false;
			}
			if($tmp2) {
				$tmp = $self->y === $b1->y;
			} else {
				$tmp = false;
			}
		} else {
			$tmp = true;
		}
		$this->assertTrue($tmp, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 30, "className" => "test.Test2D", "methodName" => "testHomogenousTranslation")));
	}
	public function testTranspose() {
		$a = Math::random();
		$b = Math::random();
		$c = Math::random();
		$d = Math::random();
		$this1 = new hxmath_math_Matrix2x2Default($a, $b, $c, $d);
		$m = $this1;
		$this2 = new hxmath_math_Matrix2x2Default($m->a, $m->c, $m->b, $m->d);
		$self = $this2;
		$this3 = new hxmath_math_Matrix2x2Default($self->a, $self->c, $self->b, $self->d);
		$n = $this3;
		$this4 = new hxmath_math_Matrix2x2Default($m->a, $m->b, $m->c, $m->d);
		$self1 = $this4;
		$self1->a -= $n->a;
		$self1->b -= $n->b;
		$self1->c -= $n->c;
		$self1->d -= $n->d;
		$normSq = $self1->a * $self1->a + $self1->b * $self1->b + $self1->c * $self1->c + $self1->d * $self1->d;
		$this->assertTrue($normSq < 1e-6, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 44, "className" => "test.Test2D", "methodName" => "testTranspose")));
	}
	public function testRotation() {
		$angle = Math::$PI / 2.0;
		$this1 = new hxmath_math_Matrix2x2Default(0.0, 0.0, 0.0, 0.0);
		$self = $this1;
		$s = Math::sin($angle);
		$c = Math::cos($angle);
		$self->a = $c;
		$self->b = -$s;
		$self->c = $s;
		$self->d = $c;
		$this2 = new hxmath_math_Vector2Default(1.0, 0.0);
		$v = $this2;
		$this3 = new hxmath_math_Vector2Default($self->a * $v->x + $self->b * $v->y, $self->c * $v->x + $self->d * $v->y);
		$a = $this3;
		$this4 = new hxmath_math_Vector2Default(0.0, 1.0);
		$b = $this4;
		$this5 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self1 = $this5;
		$self1->x -= $b->x;
		$self1->y -= $b->y;
		$self2 = $self1;
		$tmp = $self2->x * $self2->x + $self2->y * $self2->y;
		$tmp1 = Math::sqrt($tmp);
		$this->assertApproxEquals(0.0, $tmp1, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 52, "className" => "test.Test2D", "methodName" => "testRotation")));
		$angle1 = Math::$PI / 2.0;
		$this6 = new hxmath_math_Matrix2x2Default(0.0, 0.0, 0.0, 0.0);
		$self3 = $this6;
		$s1 = Math::sin($angle1);
		$c1 = Math::cos($angle1);
		$self3->a = $c1;
		$self3->b = -$s1;
		$self3->c = $s1;
		$self3->d = $c1;
		$this7 = new hxmath_math_Vector2Default(0.0, 1.0);
		$v1 = $this7;
		$this8 = new hxmath_math_Vector2Default($self3->a * $v1->x + $self3->b * $v1->y, $self3->c * $v1->x + $self3->d * $v1->y);
		$a1 = $this8;
		$this9 = new hxmath_math_Vector2Default(1.0, 0.0);
		$b1 = $this9;
		$this10 = new hxmath_math_Vector2Default($a1->x, $a1->y);
		$self4 = $this10;
		$self4->x += $b1->x;
		$self4->y += $b1->y;
		$self5 = $self4;
		$tmp2 = $self5->x * $self5->x + $self5->y * $self5->y;
		$tmp3 = Math::sqrt($tmp2);
		$this->assertApproxEquals(0.0, $tmp3, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 53, "className" => "test.Test2D", "methodName" => "testRotation")));
	}
	public function testVectorRotate() {
		$this1 = new hxmath_math_Vector2Default(1.0, 0.0);
		$angle = Math::$PI / 2.0;
		$this2 = new hxmath_math_Vector2Default(0.0, 0.0);
		$pivot = $this2;
		$self = $this1;
		Math::cos($angle);
		Math::sin($angle);
		$dx = $self->x - $pivot->x;
		$dy = $self->y - $pivot->y;
		$tmp = Math::cos($angle);
		$tmp1 = $dx * $tmp;
		$tmp2 = Math::sin($angle);
		$self->x = $tmp1 - $dy * $tmp2;
		$tmp3 = Math::sin($angle);
		$tmp4 = $dx * $tmp3;
		$tmp5 = Math::cos($angle);
		$self->y = $tmp4 + $dy * $tmp5;
		$this3 = new hxmath_math_Vector2Default(0.0, 1.0);
		$b = $this3;
		$this4 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this4;
		$self1->x -= $b->x;
		$self1->y -= $b->y;
		$self2 = $self1;
		$tmp6 = $self2->x * $self2->x + $self2->y * $self2->y;
		$tmp7 = Math::sqrt($tmp6);
		$this->assertApproxEquals(0.0, $tmp7, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 61, "className" => "test.Test2D", "methodName" => "testVectorRotate")));
		$this5 = new hxmath_math_Vector2Default(0.0, 1.0);
		$angle1 = Math::$PI / 2.0;
		$this6 = new hxmath_math_Vector2Default(0.0, 0.0);
		$pivot1 = $this6;
		$self3 = $this5;
		Math::cos($angle1);
		Math::sin($angle1);
		$dx1 = $self3->x - $pivot1->x;
		$dy1 = $self3->y - $pivot1->y;
		$tmp8 = Math::cos($angle1);
		$tmp9 = $dx1 * $tmp8;
		$tmp10 = Math::sin($angle1);
		$self3->x = $tmp9 - $dy1 * $tmp10;
		$tmp11 = Math::sin($angle1);
		$tmp12 = $dx1 * $tmp11;
		$tmp13 = Math::cos($angle1);
		$self3->y = $tmp12 + $dy1 * $tmp13;
		$this7 = new hxmath_math_Vector2Default(1.0, 0.0);
		$b1 = $this7;
		$this8 = new hxmath_math_Vector2Default($self3->x, $self3->y);
		$self4 = $this8;
		$self4->x += $b1->x;
		$self4->y += $b1->y;
		$self5 = $self4;
		$tmp14 = $self5->x * $self5->x + $self5->y * $self5->y;
		$tmp15 = Math::sqrt($tmp14);
		$this->assertApproxEquals(0.0, $tmp15, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 62, "className" => "test.Test2D", "methodName" => "testVectorRotate")));
	}
	public function testPolarConversion() {
		$angle = Math::$PI;
		$x = Math::cos($angle);
		$y = Math::sin($angle);
		$this1 = new hxmath_math_Vector2Default($x, $y);
		$a = $this1;
		$this2 = new hxmath_math_Vector2Default(1.0, 0.0);
		$b = $this2;
		$this3 = new hxmath_math_Vector2Default($a->x, $a->y);
		$self = $this3;
		$self->x += $b->x;
		$self->y += $b->y;
		$self1 = $self;
		$tmp = $self1->x * $self1->x + $self1->y * $self1->y;
		$tmp1 = Math::sqrt($tmp);
		$this->assertApproxEquals(0.0, $tmp1, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 67, "className" => "test.Test2D", "methodName" => "testPolarConversion")));
		$tmp2 = Math::$PI;
		$this4 = new hxmath_math_Vector2Default(1.0, 0.0);
		$a1 = $this4;
		$this5 = new hxmath_math_Vector2Default(-$a1->x, -$a1->y);
		$self2 = $this5;
		$tmp3 = Math::atan2($self2->y, $self2->x);
		$tmp4 = Math::abs($tmp3);
		$this->assertApproxEquals($tmp2, $tmp4, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 70, "className" => "test.Test2D", "methodName" => "testPolarConversion")));
	}
	public function testNorms() {
		$this1 = new hxmath_math_Vector2Default(0.0, 1.0);
		$self = $this1;
		$this2 = new hxmath_math_Vector2Default($self->x, $self->y);
		$self1 = $this2;
		$tmp = $self1->x * $self1->x + $self1->y * $self1->y;
		$length = Math::sqrt($tmp);
		if($length > 0.0) {
			$self1->x /= $length;
			$self1->y /= $length;
		}
		$self2 = $self1;
		$this3 = new hxmath_math_Vector2Default($self2->x, $self2->y);
		$self3 = $this3;
		$newX = -$self3->y;
		$self3->y = $self3->x;
		$self3->x = $newX;
		$this4 = new hxmath_math_Vector2Default(-1, 0);
		$b = $this4;
		$tmp1 = $self3->x * $b->x + $self3->y * $b->y;
		$this->assertTrue($tmp1 > 0.0, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 75, "className" => "test.Test2D", "methodName" => "testNorms")));
		$this5 = new hxmath_math_Vector2Default(0.0, 1.0);
		$self4 = $this5;
		$this6 = new hxmath_math_Vector2Default($self4->x, $self4->y);
		$self5 = $this6;
		$tmp2 = $self5->x * $self5->x + $self5->y * $self5->y;
		$length1 = Math::sqrt($tmp2);
		if($length1 > 0.0) {
			$self5->x /= $length1;
			$self5->y /= $length1;
		}
		$self6 = $self5;
		$this7 = new hxmath_math_Vector2Default($self6->x, $self6->y);
		$self7 = $this7;
		$newX1 = $self7->y;
		$self7->y = -$self7->x;
		$self7->x = $newX1;
		$this8 = new hxmath_math_Vector2Default(-1, 0);
		$b1 = $this8;
		$tmp3 = $self7->x * $b1->x + $self7->y * $b1->y;
		$this->assertTrue($tmp3 < 0.0, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 76, "className" => "test.Test2D", "methodName" => "testNorms")));
	}
	public function testAngles() {
		$this1 = new hxmath_math_Vector2Default(0.0, 1.0);
		$this2 = new hxmath_math_Vector2Default(-1, 1);
		$b = $this2;
		$self = $this1;
		$x = $self->x * $b->y - $b->x * $self->y;
		$tmp = null;
		$tmp1 = Math::abs($x);
		if($tmp1 < 0) {
			$tmp = 0;
		} else {
			if($x <= 0) {
				$tmp = -1;
			} else {
				$tmp = 1;
			}
		}
		$tmp2 = $self->x * $b->x + $self->y * $b->y;
		$tmp3 = $self->x * $self->x + $self->y * $self->y;
		$tmp4 = Math::sqrt($tmp3);
		$tmp5 = $b->x * $b->x + $b->y * $b->y;
		$tmp6 = Math::sqrt($tmp5);
		$tmp7 = Math::acos($tmp2 / ($tmp4 * $tmp6));
		$tmp8 = $tmp * $tmp7;
		$tmp9 = Math::$PI / 4.0;
		$this->assertApproxEquals($tmp8, $tmp9, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 81, "className" => "test.Test2D", "methodName" => "testAngles")));
		$this3 = new hxmath_math_Vector2Default(0.0, 1.0);
		$this4 = new hxmath_math_Vector2Default(1, 1);
		$b1 = $this4;
		$self1 = $this3;
		$x1 = $self1->x * $b1->y - $b1->x * $self1->y;
		$tmp10 = null;
		$tmp11 = Math::abs($x1);
		if($tmp11 < 0) {
			$tmp10 = 0;
		} else {
			if($x1 <= 0) {
				$tmp10 = -1;
			} else {
				$tmp10 = 1;
			}
		}
		$tmp12 = $self1->x * $b1->x + $self1->y * $b1->y;
		$tmp13 = $self1->x * $self1->x + $self1->y * $self1->y;
		$tmp14 = Math::sqrt($tmp13);
		$tmp15 = $b1->x * $b1->x + $b1->y * $b1->y;
		$tmp16 = Math::sqrt($tmp15);
		$tmp17 = Math::acos($tmp12 / ($tmp14 * $tmp16));
		$tmp18 = $tmp10 * $tmp17;
		$tmp19 = -Math::$PI / 4.0;
		$this->assertApproxEquals($tmp18, $tmp19, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 82, "className" => "test.Test2D", "methodName" => "testAngles")));
		$this5 = new hxmath_math_Vector2Default(0.0, 1.0);
		$this6 = new hxmath_math_Vector2Default(-1, -1);
		$b2 = $this6;
		$self2 = $this5;
		$x2 = $self2->x * $b2->y - $b2->x * $self2->y;
		$tmp20 = null;
		$tmp21 = Math::abs($x2);
		if($tmp21 < 0) {
			$tmp20 = 0;
		} else {
			if($x2 <= 0) {
				$tmp20 = -1;
			} else {
				$tmp20 = 1;
			}
		}
		$tmp22 = $self2->x * $b2->x + $self2->y * $b2->y;
		$tmp23 = $self2->x * $self2->x + $self2->y * $self2->y;
		$tmp24 = Math::sqrt($tmp23);
		$tmp25 = $b2->x * $b2->x + $b2->y * $b2->y;
		$tmp26 = Math::sqrt($tmp25);
		$tmp27 = Math::acos($tmp22 / ($tmp24 * $tmp26));
		$tmp28 = $tmp20 * $tmp27;
		$tmp29 = 3.0 * Math::$PI / 4.0;
		$this->assertApproxEquals($tmp28, $tmp29, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 83, "className" => "test.Test2D", "methodName" => "testAngles")));
		$this7 = new hxmath_math_Vector2Default(0.0, 1.0);
		$this8 = new hxmath_math_Vector2Default(1, -1);
		$b3 = $this8;
		$self3 = $this7;
		$x3 = $self3->x * $b3->y - $b3->x * $self3->y;
		$tmp30 = null;
		$tmp31 = Math::abs($x3);
		if($tmp31 < 0) {
			$tmp30 = 0;
		} else {
			if($x3 <= 0) {
				$tmp30 = -1;
			} else {
				$tmp30 = 1;
			}
		}
		$tmp32 = $self3->x * $b3->x + $self3->y * $b3->y;
		$tmp33 = $self3->x * $self3->x + $self3->y * $self3->y;
		$tmp34 = Math::sqrt($tmp33);
		$tmp35 = $b3->x * $b3->x + $b3->y * $b3->y;
		$tmp36 = Math::sqrt($tmp35);
		$tmp37 = Math::acos($tmp32 / ($tmp34 * $tmp36));
		$tmp38 = $tmp30 * $tmp37;
		$tmp39 = -3. * Math::$PI / 4.0;
		$this->assertApproxEquals($tmp38, $tmp39, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 84, "className" => "test.Test2D", "methodName" => "testAngles")));
		$this9 = new hxmath_math_Vector2Default(0.0, 1.0);
		$this10 = new hxmath_math_Vector2Default(1.0, 0.0);
		$b4 = $this10;
		$self4 = $this9;
		$x4 = $self4->x * $b4->y - $b4->x * $self4->y;
		$tmp40 = null;
		$tmp41 = Math::abs($x4);
		if($tmp41 < 0) {
			$tmp40 = 0;
		} else {
			if($x4 <= 0) {
				$tmp40 = -1;
			} else {
				$tmp40 = 1;
			}
		}
		$tmp42 = $self4->x * $b4->x + $self4->y * $b4->y;
		$tmp43 = $self4->x * $self4->x + $self4->y * $self4->y;
		$tmp44 = Math::sqrt($tmp43);
		$tmp45 = $b4->x * $b4->x + $b4->y * $b4->y;
		$tmp46 = Math::sqrt($tmp45);
		$tmp47 = Math::acos($tmp42 / ($tmp44 * $tmp46));
		$tmp48 = $tmp40 * $tmp47;
		$tmp49 = -Math::$PI / 2.0;
		$this->assertApproxEquals($tmp48, $tmp49, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 86, "className" => "test.Test2D", "methodName" => "testAngles")));
		$this11 = new hxmath_math_Vector2Default(1.0, 0.0);
		$this12 = new hxmath_math_Vector2Default(0.0, 1.0);
		$b5 = $this12;
		$self5 = $this11;
		$x5 = $self5->x * $b5->y - $b5->x * $self5->y;
		$tmp50 = null;
		$tmp51 = Math::abs($x5);
		if($tmp51 < 0) {
			$tmp50 = 0;
		} else {
			if($x5 <= 0) {
				$tmp50 = -1;
			} else {
				$tmp50 = 1;
			}
		}
		$tmp52 = $self5->x * $b5->x + $self5->y * $b5->y;
		$tmp53 = $self5->x * $self5->x + $self5->y * $self5->y;
		$tmp54 = Math::sqrt($tmp53);
		$tmp55 = $b5->x * $b5->x + $b5->y * $b5->y;
		$tmp56 = Math::sqrt($tmp55);
		$tmp57 = Math::acos($tmp52 / ($tmp54 * $tmp56));
		$tmp58 = $tmp50 * $tmp57;
		$tmp59 = Math::$PI / 2.0;
		$this->assertApproxEquals($tmp58, $tmp59, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 87, "className" => "test.Test2D", "methodName" => "testAngles")));
		$this13 = new hxmath_math_Vector2Default(0.0, 1.0);
		$this14 = new hxmath_math_Vector2Default(1.0, 0.0);
		$b6 = $this14;
		$self6 = $this13;
		$tmp60 = $self6->x * $b6->x + $self6->y * $b6->y;
		$tmp61 = $self6->x * $self6->x + $self6->y * $self6->y;
		$tmp62 = Math::sqrt($tmp61);
		$tmp63 = $b6->x * $b6->x + $b6->y * $b6->y;
		$tmp64 = Math::sqrt($tmp63);
		$tmp65 = Math::acos($tmp60 / ($tmp62 * $tmp64));
		$tmp66 = Math::$PI / 2.0;
		$this->assertApproxEquals($tmp65, $tmp66, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 89, "className" => "test.Test2D", "methodName" => "testAngles")));
		$this15 = new hxmath_math_Vector2Default(1.0, 0.0);
		$this16 = new hxmath_math_Vector2Default(0.0, 1.0);
		$b7 = $this16;
		$self7 = $this15;
		$tmp67 = $self7->x * $b7->x + $self7->y * $b7->y;
		$tmp68 = $self7->x * $self7->x + $self7->y * $self7->y;
		$tmp69 = Math::sqrt($tmp68);
		$tmp70 = $b7->x * $b7->x + $b7->y * $b7->y;
		$tmp71 = Math::sqrt($tmp70);
		$tmp72 = Math::acos($tmp67 / ($tmp69 * $tmp71));
		$tmp73 = Math::$PI / 2.0;
		$this->assertApproxEquals($tmp72, $tmp73, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 90, "className" => "test.Test2D", "methodName" => "testAngles")));
	}
	public function testOrbit() {
		$_g = 0;
		while($_g < 5) {
			++$_g;
			$a = $this->randomVector2(null);
			$this1 = new hxmath_math_Vector2Default(1, 1);
			$b = $this1;
			$this2 = new hxmath_math_Vector2Default($a->x, $a->y);
			$self = $this2;
			$self->x += $b->x;
			$self->y += $b->y;
			$angle = Math::$PI / 2;
			$this3 = new hxmath_math_Matrix3x2Default(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
			$m = $this3;
			{
				$this4 = new hxmath_math_Matrix2x2Default(0.0, 0.0, 0.0, 0.0);
				$self1 = $this4;
				$s = Math::sin($angle);
				$c = Math::cos($angle);
				$self1->a = $c;
				$self1->b = -$s;
				$self1->c = $s;
				$self1->d = $c;
				$m->a = $self1->a;
				$m->b = $self1->b;
				$m->c = $self1->c;
				$m->d = $self1->d;
				unset($this4,$self1,$s,$c);
			}
			{
				$this5 = new hxmath_math_Matrix2x2Default($m->a, $m->b, $m->c, $m->d);
				$m1 = $this5;
				$this6 = new hxmath_math_Vector2Default($m1->a * $self->x + $m1->b * $self->y, $m1->c * $self->x + $m1->d * $self->y);
				$b1 = $this6;
				$this7 = new hxmath_math_Vector2Default($self->x, $self->y);
				$self2 = $this7;
				$self2->x -= $b1->x;
				$self2->y -= $b1->y;
				$m->tx = $self2->x;
				$m->ty = $self2->y;
				unset($this7,$this6,$this5,$self2,$m1,$b1);
			}
			{
				$_g1 = 0;
				while($_g1 < 5) {
					++$_g1;
					$point = $this->randomVector2(null);
					$this8 = new hxmath_math_Matrix2x2Default($m->a, $m->b, $m->c, $m->d);
					$m2 = $this8;
					$this9 = new hxmath_math_Vector2Default($m2->a * $point->x + $m2->b * $point->y, $m2->c * $point->x + $m2->d * $point->y);
					$a1 = $this9;
					$this10 = new hxmath_math_Vector2Default($m->tx, $m->ty);
					$b2 = $this10;
					$this11 = new hxmath_math_Vector2Default($a1->x, $a1->y);
					$self3 = $this11;
					$self3->x += $b2->x;
					$self3->y += $b2->y;
					$this12 = new hxmath_math_Vector2Default($point->x, $point->y);
					$self4 = $this12;
					$self4->x -= $self->x;
					$self4->y -= $self->y;
					$this13 = new hxmath_math_Vector2Default($self3->x, $self3->y);
					$self5 = $this13;
					$self5->x -= $self->x;
					$self5->y -= $self->y;
					$tmp = $self4->x * $self5->x + $self4->y * $self5->y;
					$this->assertApproxEquals(0.0, $tmp, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 104, "className" => "test.Test2D", "methodName" => "testOrbit")));
					unset($tmp,$this9,$this8,$this13,$this12,$this11,$this10,$self5,$self4,$self3,$point,$m2,$b2,$a1);
				}
				unset($_g1);
			}
			unset($this3,$this2,$this1,$self,$m,$b,$angle,$a);
		}
	}
	public function testLinearSubMatrix() {
		$this1 = new hxmath_math_Matrix3x2Default(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);
		$m = $this1;
		{
			$this2 = new hxmath_math_Matrix2x2Default(1.0, 2.0, 3.0, 4.0);
			$value = $this2;
			$m->a = $value->a;
			$m->b = $value->b;
			$m->c = $value->c;
			$m->d = $value->d;
		}
		$this3 = new hxmath_math_Matrix2x2Default($m->a, $m->b, $m->c, $m->d);
		$m1 = $this3;
		$this4 = new hxmath_math_Matrix2x2Default(1.0, 2.0, 3.0, 4.0);
		$n = $this4;
		$tmp = null;
		$tmp1 = null;
		if($m1 === null) {
			$tmp1 = $n === null;
		} else {
			$tmp1 = false;
		}
		if(!$tmp1) {
			$tmp2 = null;
			$tmp3 = null;
			$tmp4 = null;
			$tmp5 = null;
			if($m1 !== null) {
				$tmp5 = $n !== null;
			} else {
				$tmp5 = false;
			}
			if($tmp5) {
				$tmp4 = $m1->a === $n->a;
			} else {
				$tmp4 = false;
			}
			if($tmp4) {
				$tmp3 = $m1->b === $n->b;
			} else {
				$tmp3 = false;
			}
			if($tmp3) {
				$tmp2 = $m1->c === $n->c;
			} else {
				$tmp2 = false;
			}
			if($tmp2) {
				$tmp = $m1->d === $n->d;
			} else {
				$tmp = false;
			}
		} else {
			$tmp = true;
		}
		$this->assertTrue($tmp, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 113, "className" => "test.Test2D", "methodName" => "testLinearSubMatrix")));
	}
	public function testMatrixFrameInverse() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$frame = $this->randomFrame2(null);
			$this1 = $frame->get_matrix();
			$self = $this1;
			$this2 = new hxmath_math_Matrix2x2Default($self->a, $self->b, $self->c, $self->d);
			$v = $frame->get_offset();
			$self1 = $this2;
			$this3 = new hxmath_math_Vector2Default($self1->a * $v->x + $self1->c * $v->y, $self1->b * $v->x + $self1->d * $v->y);
			$self2 = $this3;
			$self2->x = -$self2->x;
			$self2->y = -$self2->y;
			$invFrame = hxmath_frames__Frame2_Frame2_Impl_::_new($self2, -$frame->get_angleDegrees());
			$frame->get_matrix();
			$invFrameMatrix = $invFrame->get_matrix();
			$this4 = $frame->get_matrix();
			$self3 = $this4;
			{
				$temp = $self3->c;
				$self3->c = $self3->b;
				$self3->b = $temp;
				unset($temp);
			}
			$tx = -($self3->a * $self3->tx + $self3->b * $self3->ty);
			$ty = -($self3->c * $self3->tx + $self3->d * $self3->ty);
			$self3->tx = $tx;
			$self3->ty = $ty;
			$this5 = new hxmath_math_Vector2Default(0.0, 0.0);
			$homogenous0 = $this5;
			$this6 = new hxmath_math_Vector2Default(1.0, 0.0);
			$homogenousX = $this6;
			$this7 = new hxmath_math_Vector2Default(0.0, 1.0);
			$homogenousY = $this7;
			$this8 = new hxmath_math_Matrix2x2Default($invFrameMatrix->a, $invFrameMatrix->b, $invFrameMatrix->c, $invFrameMatrix->d);
			$m = $this8;
			$this9 = new hxmath_math_Vector2Default($m->a * $homogenous0->x + $m->b * $homogenous0->y, $m->c * $homogenous0->x + $m->d * $homogenous0->y);
			$a = $this9;
			$this10 = new hxmath_math_Vector2Default($invFrameMatrix->tx, $invFrameMatrix->ty);
			$b = $this10;
			$this11 = new hxmath_math_Vector2Default($a->x, $a->y);
			$self4 = $this11;
			$self4->x += $b->x;
			$self4->y += $b->y;
			$this12 = new hxmath_math_Matrix2x2Default($self3->a, $self3->b, $self3->c, $self3->d);
			$m1 = $this12;
			$this13 = new hxmath_math_Vector2Default($m1->a * $homogenous0->x + $m1->b * $homogenous0->y, $m1->c * $homogenous0->x + $m1->d * $homogenous0->y);
			$a1 = $this13;
			$this14 = new hxmath_math_Vector2Default($self3->tx, $self3->ty);
			$b1 = $this14;
			$this15 = new hxmath_math_Vector2Default($a1->x, $a1->y);
			$self5 = $this15;
			$self5->x += $b1->x;
			$self5->y += $b1->y;
			$this16 = new hxmath_math_Vector2Default($self4->x, $self4->y);
			$self6 = $this16;
			$self6->x -= $self5->x;
			$self6->y -= $self5->y;
			$self7 = $self6;
			$tmp = $self7->x * $self7->x + $self7->y * $self7->y;
			$this->assertApproxEquals(0.0, $tmp, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 138, "className" => "test.Test2D", "methodName" => "testMatrixFrameInverse")));
			$this17 = new hxmath_math_Matrix2x2Default($invFrameMatrix->a, $invFrameMatrix->b, $invFrameMatrix->c, $invFrameMatrix->d);
			$m2 = $this17;
			$this18 = new hxmath_math_Vector2Default($m2->a * $homogenousX->x + $m2->b * $homogenousX->y, $m2->c * $homogenousX->x + $m2->d * $homogenousX->y);
			$a2 = $this18;
			$this19 = new hxmath_math_Vector2Default($invFrameMatrix->tx, $invFrameMatrix->ty);
			$b2 = $this19;
			$this20 = new hxmath_math_Vector2Default($a2->x, $a2->y);
			$self8 = $this20;
			$self8->x += $b2->x;
			$self8->y += $b2->y;
			$this21 = new hxmath_math_Matrix2x2Default($self3->a, $self3->b, $self3->c, $self3->d);
			$m3 = $this21;
			$this22 = new hxmath_math_Vector2Default($m3->a * $homogenousX->x + $m3->b * $homogenousX->y, $m3->c * $homogenousX->x + $m3->d * $homogenousX->y);
			$a3 = $this22;
			$this23 = new hxmath_math_Vector2Default($self3->tx, $self3->ty);
			$b3 = $this23;
			$this24 = new hxmath_math_Vector2Default($a3->x, $a3->y);
			$self9 = $this24;
			$self9->x += $b3->x;
			$self9->y += $b3->y;
			$this25 = new hxmath_math_Vector2Default($self8->x, $self8->y);
			$self10 = $this25;
			$self10->x -= $self9->x;
			$self10->y -= $self9->y;
			$self11 = $self10;
			$tmp1 = $self11->x * $self11->x + $self11->y * $self11->y;
			$this->assertApproxEquals(0.0, $tmp1, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 139, "className" => "test.Test2D", "methodName" => "testMatrixFrameInverse")));
			$this26 = new hxmath_math_Matrix2x2Default($invFrameMatrix->a, $invFrameMatrix->b, $invFrameMatrix->c, $invFrameMatrix->d);
			$m4 = $this26;
			$this27 = new hxmath_math_Vector2Default($m4->a * $homogenousY->x + $m4->b * $homogenousY->y, $m4->c * $homogenousY->x + $m4->d * $homogenousY->y);
			$a4 = $this27;
			$this28 = new hxmath_math_Vector2Default($invFrameMatrix->tx, $invFrameMatrix->ty);
			$b4 = $this28;
			$this29 = new hxmath_math_Vector2Default($a4->x, $a4->y);
			$self12 = $this29;
			$self12->x += $b4->x;
			$self12->y += $b4->y;
			$this30 = new hxmath_math_Matrix2x2Default($self3->a, $self3->b, $self3->c, $self3->d);
			$m5 = $this30;
			$this31 = new hxmath_math_Vector2Default($m5->a * $homogenousY->x + $m5->b * $homogenousY->y, $m5->c * $homogenousY->x + $m5->d * $homogenousY->y);
			$a5 = $this31;
			$this32 = new hxmath_math_Vector2Default($self3->tx, $self3->ty);
			$b5 = $this32;
			$this33 = new hxmath_math_Vector2Default($a5->x, $a5->y);
			$self13 = $this33;
			$self13->x += $b5->x;
			$self13->y += $b5->y;
			$this34 = new hxmath_math_Vector2Default($self12->x, $self12->y);
			$self14 = $this34;
			$self14->x -= $self13->x;
			$self14->y -= $self13->y;
			$self15 = $self14;
			$tmp2 = $self15->x * $self15->x + $self15->y * $self15->y;
			$this->assertApproxEquals(0.0, $tmp2, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 140, "className" => "test.Test2D", "methodName" => "testMatrixFrameInverse")));
			unset($v,$ty,$tx,$tmp2,$tmp1,$tmp,$this9,$this8,$this7,$this6,$this5,$this4,$this34,$this33,$this32,$this31,$this30,$this3,$this29,$this28,$this27,$this26,$this25,$this24,$this23,$this22,$this21,$this20,$this2,$this19,$this18,$this17,$this16,$this15,$this14,$this13,$this12,$this11,$this10,$this1,$self9,$self8,$self7,$self6,$self5,$self4,$self3,$self2,$self15,$self14,$self13,$self12,$self11,$self10,$self1,$self,$m5,$m4,$m3,$m2,$m1,$m,$invFrameMatrix,$invFrame,$homogenousY,$homogenousX,$homogenous0,$frame,$b5,$b4,$b3,$b2,$b1,$b,$a5,$a4,$a3,$a2,$a1,$a);
		}
	}
	public function testOrthoNormalize() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$u = $this->randomVector2(null);
			$v = $this->randomVector2(null);
			{
				{
					$tmp = $u->x * $u->x + $u->y * $u->y;
					$length = Math::sqrt($tmp);
					if($length > 0.0) {
						$u->x /= $length;
						$u->y /= $length;
					}
					unset($tmp,$length);
				}
				{
					$this1 = new hxmath_math_Vector2Default($v->x, $v->y);
					$self = $this1;
					$s = ($self->x * $u->x + $self->y * $u->y) / ($u->x * $u->x + $u->y * $u->y);
					{
						$_g1 = 0;
						while($_g1 < 2) {
							$i = $_g1++;
							{
								$tmp1 = null;
								switch($i) {
								case 0:{
									$tmp1 = $u->x;
								}break;
								case 1:{
									$tmp1 = $u->y;
								}break;
								default:{
									throw new HException("Invalid element");
								}break;
								}
								$value = $tmp1;
								switch($i) {
								case 0:{
									$self->x = $value;
								}break;
								case 1:{
									$self->y = $value;
								}break;
								default:{
									throw new HException("Invalid element");
								}break;
								}
								unset($value,$tmp1);
							}
							unset($i);
						}
						unset($_g1);
					}
					{
						$self->x *= $s;
						$self->y *= $s;
					}
					$v->x -= $self->x;
					$v->y -= $self->y;
					unset($this1,$self,$s);
				}
				{
					$tmp2 = $v->x * $v->x + $v->y * $v->y;
					$length1 = Math::sqrt($tmp2);
					if($length1 > 0.0) {
						$v->x /= $length1;
						$v->y /= $length1;
					}
					unset($tmp2,$length1);
				}
			}
			$tmp3 = $u->x * $u->x + $u->y * $u->y;
			$tmp4 = Math::sqrt($tmp3);
			$this->assertApproxEquals(1.0, $tmp4, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 153, "className" => "test.Test2D", "methodName" => "testOrthoNormalize")));
			$tmp5 = $v->x * $v->x + $v->y * $v->y;
			$tmp6 = Math::sqrt($tmp5);
			$this->assertApproxEquals(1.0, $tmp6, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 154, "className" => "test.Test2D", "methodName" => "testOrthoNormalize")));
			$tmp7 = $u->x * $v->x + $u->y * $v->y;
			$this->assertApproxEquals(0.0, $tmp7, null, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 155, "className" => "test.Test2D", "methodName" => "testOrthoNormalize")));
			unset($v,$u,$tmp7,$tmp6,$tmp5,$tmp4,$tmp3);
		}
	}
	public function testReflect() {
		$_g = 0;
		while($_g < 10) {
			++$_g;
			$u = $this->randomVector2(null);
			$this1 = new hxmath_math_Vector2Default(0.0, 1.0);
			$normal = $this1;
			$this2 = new hxmath_math_Vector2Default($u->x, $u->y);
			$self = $this2;
			$this3 = new hxmath_math_Vector2Default($self->x, $self->y);
			$self1 = $this3;
			$s = ($self1->x * $normal->x + $self1->y * $normal->y) / ($normal->x * $normal->x + $normal->y * $normal->y);
			{
				$_g1 = 0;
				while($_g1 < 2) {
					$i = $_g1++;
					{
						$tmp = null;
						switch($i) {
						case 0:{
							$tmp = $normal->x;
						}break;
						case 1:{
							$tmp = $normal->y;
						}break;
						default:{
							throw new HException("Invalid element");
						}break;
						}
						$value = $tmp;
						switch($i) {
						case 0:{
							$self1->x = $value;
						}break;
						case 1:{
							$self1->y = $value;
						}break;
						default:{
							throw new HException("Invalid element");
						}break;
						}
						unset($value,$tmp);
					}
					unset($i);
				}
				unset($_g1);
			}
			{
				$self1->x *= $s;
				$self1->y *= $s;
			}
			{
				$self1->x *= 2.0;
				$self1->y *= 2.0;
			}
			{
				$self->x -= $self1->x;
				$self->y -= $self1->y;
			}
			$this->assertEquals($u->x, $self->x, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 166, "className" => "test.Test2D", "methodName" => "testReflect")));
			$this->assertEquals(-$u->y, $self->y, _hx_anonymous(array("fileName" => "Test2D.hx", "lineNumber" => 167, "className" => "test.Test2D", "methodName" => "testReflect")));
			unset($u,$this3,$this2,$this1,$self1,$self,$s,$normal);
		}
	}
	function __toString() { return 'test.Test2D'; }
}
