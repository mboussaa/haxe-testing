<?php

// Generated by Haxe 3.3.0
class thx_format_TimeFormat {
	public function __construct(){}
	static function customFormat($t, $pattern, $culture = null) {
		$_0 = $culture;
		$t1 = null;
		if(null === $_0) {
			$t1 = null;
		} else {
			$t1 = $_0;
		}
		if($t1 !== null) {
			$culture = $t1;
		} else {
			$culture = thx_format_Format::get_defaultCulture();
		}
		$ereg = new EReg("(d|H){1,8}|(f|F){1,7}|(h|m|s){1,2}|[:.]|'[^']*'|\"[^\"]*\"", "");
		$escape = false;
		$buf = (new _hx_array(array()));
		while(strlen($pattern) > 0) {
			if($escape) {
				$escape = false;
				$tmp = _hx_substring($pattern, 0, 1);
				$buf->push($tmp);
				$pattern = _hx_substring($pattern, 1, null);
				unset($tmp);
			} else {
				$tmp1 = $ereg->match($pattern);
				if($tmp1) {
					$left = $ereg->matchedLeft();
					$tmp2 = _hx_substring($left, -1, null);
					if($tmp2 === "\\") {
						$escape = true;
						$pattern = _hx_substring($pattern, strlen($left), null);
						$tmp3 = strlen($left) - 1;
						$tmp4 = _hx_substring($left, 0, $tmp3);
						$buf->push($tmp4);
						continue;
						unset($tmp4,$tmp3);
					}
					$buf->push($left);
					$term = $ereg->matched(0);
					$right = $ereg->matchedRight();
					$pattern = $right;
					$tmp5 = null;
					if($term === ".") {
						$tmp6 = strtolower(_hx_substring($right, 0, 1));
						$tmp5 = $tmp6 === "f";
						unset($tmp6);
					} else {
						$tmp5 = false;
					}
					if($tmp5) {
						$b = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
						$x = haxe__Int64_Int64_Impl_::divMod($t, $b)->modulus;
						if($x->high !== $x->low >> 31) {
							throw new HException("Overflow");
						}
						$x1 = $x->low;
						$x2 = new haxe__Int64____Int64($x1 >> 31, $x1);
						$a = $x2;
						$b1 = thx_Int64s::$zero;
						$tmp7 = null;
						if($a->high === $b1->high) {
							$tmp7 = $a->low === $b1->low;
						} else {
							$tmp7 = false;
						}
						if($tmp7) {
							$ereg->match($right);
							$pattern = $ereg->matchedRight();
							continue;
						}
						unset($x2,$x1,$x,$tmp7,$b1,$b,$a);
					}
					$tmp8 = thx_format_TimeFormat::formatTerm($t, $term, $culture);
					$buf->push($tmp8);
					unset($tmp8,$tmp5,$tmp2,$term,$right,$left);
				} else {
					$buf->push($pattern);
					$pattern = "";
				}
				unset($tmp1);
			}
		}
		if($escape) {
			$buf->push("\\");
		}
		return $buf->join("");
	}
	static function format($t, $pattern, $culture = null) {
		switch($pattern) {
		case "G":case "T":{
			return thx_format_TimeFormat::timeLong($t, $culture);
		}break;
		case "c":{
			return thx_format_TimeFormat::invariantTimeLong($t);
		}break;
		case "g":case "t":{
			return thx_format_TimeFormat::timeShort($t, $culture);
		}break;
		default:{
			return thx_format_TimeFormat::customFormat($t, $pattern, $culture);
		}break;
		}
	}
	static function formatTerm($t, $pattern, $culture = null) {
		switch($pattern) {
		case ".":{
			return $culture->number->separatorDecimalNumber;
		}break;
		case ":":{
			return thx_format_DateFormat::dateTime($culture)->separatorTime;
		}break;
		case "F":{
			$b = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x = haxe__Int64_Int64_Impl_::divMod($t, $b)->modulus;
			if($x->high !== $x->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp = $x->low;
			return thx_format_DateFormat::getDecimalsUpTo($tmp, 1);
		}break;
		case "FF":{
			$b1 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x1 = haxe__Int64_Int64_Impl_::divMod($t, $b1)->modulus;
			if($x1->high !== $x1->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp1 = $x1->low;
			return thx_format_DateFormat::getDecimalsUpTo($tmp1, 2);
		}break;
		case "FFF":{
			$b2 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x2 = haxe__Int64_Int64_Impl_::divMod($t, $b2)->modulus;
			if($x2->high !== $x2->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp2 = $x2->low;
			return thx_format_DateFormat::getDecimalsUpTo($tmp2, 3);
		}break;
		case "FFFF":{
			$b3 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x3 = haxe__Int64_Int64_Impl_::divMod($t, $b3)->modulus;
			if($x3->high !== $x3->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp3 = $x3->low;
			return thx_format_DateFormat::getDecimalsUpTo($tmp3, 4);
		}break;
		case "FFFFF":{
			$b4 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x4 = haxe__Int64_Int64_Impl_::divMod($t, $b4)->modulus;
			if($x4->high !== $x4->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp4 = $x4->low;
			return thx_format_DateFormat::getDecimalsUpTo($tmp4, 5);
		}break;
		case "FFFFFF":{
			$b5 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x5 = haxe__Int64_Int64_Impl_::divMod($t, $b5)->modulus;
			if($x5->high !== $x5->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp5 = $x5->low;
			return thx_format_DateFormat::getDecimalsUpTo($tmp5, 6);
		}break;
		case "FFFFFFF":{
			$b6 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x6 = haxe__Int64_Int64_Impl_::divMod($t, $b6)->modulus;
			if($x6->high !== $x6->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp6 = $x6->low;
			return thx_format_DateFormat::getDecimalsString($tmp6);
		}break;
		case "H":{
			$b7 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$tmp7 = haxe__Int64_Int64_Impl_::divMod($t, $b7)->quotient;
			$tmp8 = haxe__Int64_Int64_Impl_::toString($tmp7);
			return "" . _hx_string_or_null($tmp8);
		}break;
		case "HH":{
			$b8 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$tmp9 = haxe__Int64_Int64_Impl_::divMod($t, $b8)->quotient;
			$tmp10 = haxe__Int64_Int64_Impl_::toString($tmp9);
			return thx_Strings::lpad("" . _hx_string_or_null($tmp10), "0", 2);
		}break;
		case "HHH":{
			$b9 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$tmp11 = haxe__Int64_Int64_Impl_::divMod($t, $b9)->quotient;
			$tmp12 = haxe__Int64_Int64_Impl_::toString($tmp11);
			return thx_Strings::lpad("" . _hx_string_or_null($tmp12), "0", 3);
		}break;
		case "HHHH":{
			$b10 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$tmp13 = haxe__Int64_Int64_Impl_::divMod($t, $b10)->quotient;
			$tmp14 = haxe__Int64_Int64_Impl_::toString($tmp13);
			return thx_Strings::lpad("" . _hx_string_or_null($tmp14), "0", 4);
		}break;
		case "HHHHH":{
			$b11 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$tmp15 = haxe__Int64_Int64_Impl_::divMod($t, $b11)->quotient;
			$tmp16 = haxe__Int64_Int64_Impl_::toString($tmp15);
			return thx_Strings::lpad("" . _hx_string_or_null($tmp16), "0", 5);
		}break;
		case "HHHHHH":{
			$b12 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$tmp17 = haxe__Int64_Int64_Impl_::divMod($t, $b12)->quotient;
			$tmp18 = haxe__Int64_Int64_Impl_::toString($tmp17);
			return thx_Strings::lpad("" . _hx_string_or_null($tmp18), "0", 6);
		}break;
		case "HHHHHHH":{
			$b13 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$tmp19 = haxe__Int64_Int64_Impl_::divMod($t, $b13)->quotient;
			$tmp20 = haxe__Int64_Int64_Impl_::toString($tmp19);
			return thx_Strings::lpad("" . _hx_string_or_null($tmp20), "0", 7);
		}break;
		case "HHHHHHHH":{
			$b14 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$tmp21 = haxe__Int64_Int64_Impl_::divMod($t, $b14)->quotient;
			$tmp22 = haxe__Int64_Int64_Impl_::toString($tmp21);
			return thx_Strings::lpad("" . _hx_string_or_null($tmp22), "0", 8);
		}break;
		case "d":{
			$b15 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
			$x7 = haxe__Int64_Int64_Impl_::divMod($t, $b15)->quotient;
			if($x7->high !== $x7->low >> 31) {
				throw new HException("Overflow");
			}
			return "" . _hx_string_rec($x7->low, "");
		}break;
		case "dd":{
			$b16 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
			$x8 = haxe__Int64_Int64_Impl_::divMod($t, $b16)->quotient;
			if($x8->high !== $x8->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp23 = "" . _hx_string_rec($x8->low, "");
			return thx_Strings::lpad($tmp23, "0", 2);
		}break;
		case "ddd":{
			$b17 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
			$x9 = haxe__Int64_Int64_Impl_::divMod($t, $b17)->quotient;
			if($x9->high !== $x9->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp24 = "" . _hx_string_rec($x9->low, "");
			return thx_Strings::lpad($tmp24, "0", 3);
		}break;
		case "dddd":{
			$b18 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
			$x10 = haxe__Int64_Int64_Impl_::divMod($t, $b18)->quotient;
			if($x10->high !== $x10->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp25 = "" . _hx_string_rec($x10->low, "");
			return thx_Strings::lpad($tmp25, "0", 4);
		}break;
		case "ddddd":{
			$b19 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
			$x11 = haxe__Int64_Int64_Impl_::divMod($t, $b19)->quotient;
			if($x11->high !== $x11->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp26 = "" . _hx_string_rec($x11->low, "");
			return thx_Strings::lpad($tmp26, "0", 5);
		}break;
		case "dddddd":{
			$b20 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
			$x12 = haxe__Int64_Int64_Impl_::divMod($t, $b20)->quotient;
			if($x12->high !== $x12->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp27 = "" . _hx_string_rec($x12->low, "");
			return thx_Strings::lpad($tmp27, "0", 6);
		}break;
		case "ddddddd":{
			$b21 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
			$x13 = haxe__Int64_Int64_Impl_::divMod($t, $b21)->quotient;
			if($x13->high !== $x13->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp28 = "" . _hx_string_rec($x13->low, "");
			return thx_Strings::lpad($tmp28, "0", 7);
		}break;
		case "dddddddd":{
			$b22 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
			$x14 = haxe__Int64_Int64_Impl_::divMod($t, $b22)->quotient;
			if($x14->high !== $x14->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp29 = "" . _hx_string_rec($x14->low, "");
			return thx_Strings::lpad($tmp29, "0", 8);
		}break;
		case "f":{
			$b23 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x15 = haxe__Int64_Int64_Impl_::divMod($t, $b23)->modulus;
			if($x15->high !== $x15->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp30 = $x15->low;
			return thx_format_DateFormat::getDecimalsPaddedUpTo($tmp30, 1);
		}break;
		case "ff":{
			$b24 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x16 = haxe__Int64_Int64_Impl_::divMod($t, $b24)->modulus;
			if($x16->high !== $x16->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp31 = $x16->low;
			return thx_format_DateFormat::getDecimalsPaddedUpTo($tmp31, 2);
		}break;
		case "fff":{
			$b25 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x17 = haxe__Int64_Int64_Impl_::divMod($t, $b25)->modulus;
			if($x17->high !== $x17->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp32 = $x17->low;
			return thx_format_DateFormat::getDecimalsPaddedUpTo($tmp32, 3);
		}break;
		case "ffff":{
			$b26 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x18 = haxe__Int64_Int64_Impl_::divMod($t, $b26)->modulus;
			if($x18->high !== $x18->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp33 = $x18->low;
			return thx_format_DateFormat::getDecimalsPaddedUpTo($tmp33, 4);
		}break;
		case "fffff":{
			$b27 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x19 = haxe__Int64_Int64_Impl_::divMod($t, $b27)->modulus;
			if($x19->high !== $x19->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp34 = $x19->low;
			return thx_format_DateFormat::getDecimalsPaddedUpTo($tmp34, 5);
		}break;
		case "ffffff":{
			$b28 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x20 = haxe__Int64_Int64_Impl_::divMod($t, $b28)->modulus;
			if($x20->high !== $x20->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp35 = $x20->low;
			return thx_format_DateFormat::getDecimalsPaddedUpTo($tmp35, 6);
		}break;
		case "fffffff":{
			$b29 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$x21 = haxe__Int64_Int64_Impl_::divMod($t, $b29)->modulus;
			if($x21->high !== $x21->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp36 = $x21->low;
			return thx_format_DateFormat::getDecimalsPadded($tmp36);
		}break;
		case "h":{
			$b30 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$a = haxe__Int64_Int64_Impl_::divMod($t, $b30)->quotient;
			$x22 = new haxe__Int64____Int64(0, 24);
			$x23 = haxe__Int64_Int64_Impl_::divMod($a, $x22)->modulus;
			if($x23->high !== $x23->low >> 31) {
				throw new HException("Overflow");
			}
			return "" . _hx_string_rec($x23->low, "");
		}break;
		case "hh":{
			$b31 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
			$a1 = haxe__Int64_Int64_Impl_::divMod($t, $b31)->quotient;
			$x24 = new haxe__Int64____Int64(0, 24);
			$x25 = haxe__Int64_Int64_Impl_::divMod($a1, $x24)->modulus;
			if($x25->high !== $x25->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp37 = $x25->low;
			return thx_Ints::lpad($tmp37, "0", 2);
		}break;
		case "m":{
			$b32 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerMinuteI64;
			$a2 = haxe__Int64_Int64_Impl_::divMod($t, $b32)->quotient;
			$x26 = new haxe__Int64____Int64(0, 60);
			$x27 = haxe__Int64_Int64_Impl_::divMod($a2, $x26)->modulus;
			if($x27->high !== $x27->low >> 31) {
				throw new HException("Overflow");
			}
			return "" . _hx_string_rec($x27->low, "");
		}break;
		case "mm":{
			$b33 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerMinuteI64;
			$a3 = haxe__Int64_Int64_Impl_::divMod($t, $b33)->quotient;
			$x28 = new haxe__Int64____Int64(0, 60);
			$x29 = haxe__Int64_Int64_Impl_::divMod($a3, $x28)->modulus;
			if($x29->high !== $x29->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp38 = "" . _hx_string_rec($x29->low, "");
			return thx_Strings::lpad($tmp38, "0", 2);
		}break;
		case "s":{
			$b34 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$a4 = haxe__Int64_Int64_Impl_::divMod($t, $b34)->quotient;
			$x30 = new haxe__Int64____Int64(0, 60);
			$x31 = haxe__Int64_Int64_Impl_::divMod($a4, $x30)->modulus;
			if($x31->high !== $x31->low >> 31) {
				throw new HException("Overflow");
			}
			return "" . _hx_string_rec($x31->low, "");
		}break;
		case "ss":{
			$b35 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
			$a5 = haxe__Int64_Int64_Impl_::divMod($t, $b35)->quotient;
			$x32 = new haxe__Int64____Int64(0, 60);
			$x33 = haxe__Int64_Int64_Impl_::divMod($a5, $x32)->modulus;
			if($x33->high !== $x33->low >> 31) {
				throw new HException("Overflow");
			}
			$tmp39 = "" . _hx_string_rec($x33->low, "");
			return thx_Strings::lpad($tmp39, "0", 2);
		}break;
		default:{
			$tmp40 = null;
			$tmp41 = null;
			$tmp42 = null;
			if($pattern !== null) {
				$tmp42 = strlen($pattern) > 1;
			} else {
				$tmp42 = false;
			}
			if($tmp42) {
				$tmp43 = _hx_substring($pattern, 0, 1);
				if($tmp43 === "'") {
					$tmp44 = strlen($pattern) - 1;
					$tmp45 = _hx_substring($pattern, $tmp44, null);
					$tmp41 = $tmp45 === "'";
				} else {
					$tmp41 = false;
				}
			} else {
				$tmp41 = false;
			}
			if(!$tmp41) {
				$tmp46 = _hx_substring($pattern, 0, 1);
				if($tmp46 === "\"") {
					$tmp47 = strlen($pattern) - 1;
					$tmp48 = _hx_substring($pattern, $tmp47, null);
					$tmp40 = $tmp48 === "\"";
				} else {
					$tmp40 = false;
				}
			} else {
				$tmp40 = true;
			}
			if($tmp40) {
				$tmp49 = strlen($pattern) - 1;
				return _hx_substring($pattern, 1, $tmp49);
			} else {
				return $pattern;
			}
		}break;
		}
	}
	static function timeLong($time, $culture = null) {
		$abs = thx__Time_Time_Impl_::abs($time);
		$dt = thx_format_DateFormat::dateTime($culture);
		$tmp = null;
		if(null === $culture) {
			$tmp = thx_format_Format::get_defaultCulture();
		} else {
			$tmp = $culture;
		}
		$n = $tmp->number;
		$b = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
		$x = haxe__Int64_Int64_Impl_::divMod($abs, $b)->quotient;
		if($x->high !== $x->low >> 31) {
			throw new HException("Overflow");
		}
		$days = $x->low;
		$b1 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
		$a = haxe__Int64_Int64_Impl_::divMod($abs, $b1)->quotient;
		$x1 = new haxe__Int64____Int64(0, 24);
		$x2 = haxe__Int64_Int64_Impl_::divMod($a, $x1)->modulus;
		if($x2->high !== $x2->low >> 31) {
			throw new HException("Overflow");
		}
		$hours = $x2->low;
		$b2 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerMinuteI64;
		$a1 = haxe__Int64_Int64_Impl_::divMod($abs, $b2)->quotient;
		$x3 = new haxe__Int64____Int64(0, 60);
		$x4 = haxe__Int64_Int64_Impl_::divMod($a1, $x3)->modulus;
		if($x4->high !== $x4->low >> 31) {
			throw new HException("Overflow");
		}
		$minutes = $x4->low;
		$b3 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
		$a2 = haxe__Int64_Int64_Impl_::divMod($abs, $b3)->quotient;
		$x5 = new haxe__Int64____Int64(0, 60);
		$x6 = haxe__Int64_Int64_Impl_::divMod($a2, $x5)->modulus;
		if($x6->high !== $x6->low >> 31) {
			throw new HException("Overflow");
		}
		$seconds = $x6->low;
		$buf = "";
		$a3 = $time;
		$x7 = new haxe__Int64____Int64(0, 0);
		$b4 = $x7;
		$v = $a3->high - $b4->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$tmp1 = $v !== 0;
		if($tmp1) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a3->low, $b4->low);
		}
		$tmp2 = null;
		if($a3->high < 0) {
			if($b4->high < 0) {
				$tmp2 = $v;
			} else {
				$tmp2 = -1;
			}
		} else {
			if($b4->high >= 0) {
				$tmp2 = $v;
			} else {
				$tmp2 = 1;
			}
		}
		if($tmp2 < 0) {
			$buf = "" . _hx_string_or_null($n->signNegative);
		}
		if($days !== 0) {
			$buf .= _hx_string_rec($days, "") . _hx_string_or_null($n->separatorDecimalNumber);
		}
		$tmp3 = thx_Ints::lpad($hours, "0", 2);
		$buf .= _hx_string_or_null($tmp3);
		$buf .= _hx_string_or_null($dt->separatorTime);
		$tmp4 = thx_Ints::lpad($minutes, "0", 2);
		$buf .= _hx_string_or_null($tmp4);
		$buf .= _hx_string_or_null($dt->separatorTime);
		$tmp5 = thx_Ints::lpad($seconds, "0", 2);
		$buf .= _hx_string_or_null($tmp5);
		$b5 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
		$x8 = haxe__Int64_Int64_Impl_::divMod($abs, $b5)->modulus;
		if($x8->high !== $x8->low >> 31) {
			throw new HException("Overflow");
		}
		$t = $x8->low;
		if($t !== 0) {
			$tmp6 = thx_format_DateFormat::getDecimalsPadded($t);
			$buf .= _hx_string_or_null($n->separatorDecimalNumber) . _hx_string_or_null($tmp6);
		}
		return $buf;
	}
	static function timeShort($time, $culture = null) {
		$abs = thx__Time_Time_Impl_::abs($time);
		$dt = thx_format_DateFormat::dateTime($culture);
		$tmp = null;
		if(null === $culture) {
			$tmp = thx_format_Format::get_defaultCulture();
		} else {
			$tmp = $culture;
		}
		$n = $tmp->number;
		$b = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerDayI64;
		$x = haxe__Int64_Int64_Impl_::divMod($abs, $b)->quotient;
		if($x->high !== $x->low >> 31) {
			throw new HException("Overflow");
		}
		$days = $x->low;
		$b1 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
		$a = haxe__Int64_Int64_Impl_::divMod($abs, $b1)->quotient;
		$x1 = new haxe__Int64____Int64(0, 24);
		$x2 = haxe__Int64_Int64_Impl_::divMod($a, $x1)->modulus;
		if($x2->high !== $x2->low >> 31) {
			throw new HException("Overflow");
		}
		$hours = $x2->low;
		$b2 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerMinuteI64;
		$a1 = haxe__Int64_Int64_Impl_::divMod($abs, $b2)->quotient;
		$x3 = new haxe__Int64____Int64(0, 60);
		$x4 = haxe__Int64_Int64_Impl_::divMod($a1, $x3)->modulus;
		if($x4->high !== $x4->low >> 31) {
			throw new HException("Overflow");
		}
		$minutes = $x4->low;
		$b3 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
		$a2 = haxe__Int64_Int64_Impl_::divMod($abs, $b3)->quotient;
		$x5 = new haxe__Int64____Int64(0, 60);
		$x6 = haxe__Int64_Int64_Impl_::divMod($a2, $x5)->modulus;
		if($x6->high !== $x6->low >> 31) {
			throw new HException("Overflow");
		}
		$seconds = $x6->low;
		$buf = "";
		$a3 = $time;
		$x7 = new haxe__Int64____Int64(0, 0);
		$b4 = $x7;
		$v = $a3->high - $b4->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$tmp1 = $v !== 0;
		if($tmp1) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a3->low, $b4->low);
		}
		$tmp2 = null;
		if($a3->high < 0) {
			if($b4->high < 0) {
				$tmp2 = $v;
			} else {
				$tmp2 = -1;
			}
		} else {
			if($b4->high >= 0) {
				$tmp2 = $v;
			} else {
				$tmp2 = 1;
			}
		}
		if($tmp2 < 0) {
			$buf = "" . _hx_string_or_null($n->signNegative);
		}
		if($days !== 0) {
			$buf .= _hx_string_rec($days, "") . _hx_string_or_null($dt->separatorTime);
		}
		$tmp3 = thx_Ints::lpad($hours, "0", 2);
		$buf .= _hx_string_or_null($tmp3);
		$buf .= _hx_string_or_null($dt->separatorTime);
		$tmp4 = thx_Ints::lpad($minutes, "0", 2);
		$buf .= _hx_string_or_null($tmp4);
		$buf .= _hx_string_or_null($dt->separatorTime);
		$tmp5 = thx_Ints::lpad($seconds, "0", 2);
		$buf .= _hx_string_or_null($tmp5);
		$b5 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerSecondI64;
		$x8 = haxe__Int64_Int64_Impl_::divMod($abs, $b5)->modulus;
		if($x8->high !== $x8->low >> 31) {
			throw new HException("Overflow");
		}
		$t = $x8->low;
		if($t !== 0) {
			$tmp6 = thx_format_DateFormat::getDecimalsString($t);
			$buf .= _hx_string_or_null($n->separatorDecimalNumber) . _hx_string_or_null($tmp6);
		}
		return $buf;
	}
	static function invariantTimeLong($time) {
		return thx_format_TimeFormat::timeLong($time, thx_culture_Culture::$invariant);
	}
	static function offsetHoursShort($offset, $culture = null) {
		$tmp = null;
		if(null === $culture) {
			$tmp = thx_format_Format::get_defaultCulture();
		} else {
			$tmp = $culture;
		}
		$n = $tmp->number;
		$abs = thx__Time_Time_Impl_::abs($offset);
		$tmp1 = null;
		$a = $offset;
		$x = new haxe__Int64____Int64(0, 0);
		$b = $x;
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$tmp2 = $v !== 0;
		if($tmp2) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		$tmp3 = null;
		if($a->high < 0) {
			if($b->high < 0) {
				$tmp3 = $v;
			} else {
				$tmp3 = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp3 = $v;
			} else {
				$tmp3 = 1;
			}
		}
		if($tmp3 < 0) {
			$tmp1 = $n->signNegative;
		} else {
			$tmp1 = $n->signPositive;
		}
		$b1 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
		$tmp4 = haxe__Int64_Int64_Impl_::divMod($abs, $b1)->quotient;
		$tmp5 = haxe__Int64_Int64_Impl_::toString($tmp4);
		return _hx_string_or_null($tmp1) . _hx_string_or_null($tmp5);
	}
	static function offsetHoursLong($offset, $culture = null) {
		$tmp = null;
		if(null === $culture) {
			$tmp = thx_format_Format::get_defaultCulture();
		} else {
			$tmp = $culture;
		}
		$n = $tmp->number;
		$abs = thx__Time_Time_Impl_::abs($offset);
		$tmp1 = null;
		$a = $offset;
		$x = new haxe__Int64____Int64(0, 0);
		$b = $x;
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$tmp2 = $v !== 0;
		if($tmp2) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		$tmp3 = null;
		if($a->high < 0) {
			if($b->high < 0) {
				$tmp3 = $v;
			} else {
				$tmp3 = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp3 = $v;
			} else {
				$tmp3 = 1;
			}
		}
		if($tmp3 < 0) {
			$tmp1 = $n->signNegative;
		} else {
			$tmp1 = $n->signPositive;
		}
		$b1 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
		$x1 = haxe__Int64_Int64_Impl_::divMod($abs, $b1)->quotient;
		$tmp4 = haxe__Int64_Int64_Impl_::toString($x1);
		$tmp5 = thx_Strings::lpad($tmp4, "0", 2);
		return _hx_string_or_null($tmp1) . _hx_string_or_null($tmp5);
	}
	static function offsetLong($offset, $culture = null) {
		$dt = thx_format_DateFormat::dateTime($culture);
		$tmp = null;
		if(null === $culture) {
			$tmp = thx_format_Format::get_defaultCulture();
		} else {
			$tmp = $culture;
		}
		$n = $tmp->number;
		$abs = thx__Time_Time_Impl_::abs($offset);
		$tmp1 = null;
		$a = $offset;
		$x = new haxe__Int64____Int64(0, 0);
		$b = $x;
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$tmp2 = $v !== 0;
		if($tmp2) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		$tmp3 = null;
		if($a->high < 0) {
			if($b->high < 0) {
				$tmp3 = $v;
			} else {
				$tmp3 = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp3 = $v;
			} else {
				$tmp3 = 1;
			}
		}
		if($tmp3 < 0) {
			$tmp1 = $n->signNegative;
		} else {
			$tmp1 = $n->signPositive;
		}
		$b1 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
		$x1 = haxe__Int64_Int64_Impl_::divMod($abs, $b1)->quotient;
		$tmp4 = haxe__Int64_Int64_Impl_::toString($x1);
		$tmp5 = thx_Strings::lpad($tmp4, "0", 2);
		$tmp6 = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp5) . _hx_string_or_null($dt->separatorTime);
		$b2 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerMinuteI64;
		$a1 = haxe__Int64_Int64_Impl_::divMod($abs, $b2)->quotient;
		$x2 = new haxe__Int64____Int64(0, 60);
		$x3 = haxe__Int64_Int64_Impl_::divMod($a1, $x2)->modulus;
		if($x3->high !== $x3->low >> 31) {
			throw new HException("Overflow");
		}
		$tmp7 = $x3->low;
		$tmp8 = thx_Ints::lpad($tmp7, "0", 2);
		return _hx_string_or_null($tmp6) . _hx_string_or_null($tmp8);
	}
	static function iso8601OffsetShort($offset) {
		$abs = thx__Time_Time_Impl_::abs($offset);
		$tmp = null;
		$a = $offset;
		$x = new haxe__Int64____Int64(0, 0);
		$b = $x;
		$v = $a->high - $b->high << haxe__Int32_Int32_Impl_::$extraBits >> haxe__Int32_Int32_Impl_::$extraBits;
		$tmp1 = $v !== 0;
		if($tmp1) {
			$v = $v;
		} else {
			$v = haxe__Int32_Int32_Impl_::ucompare($a->low, $b->low);
		}
		$tmp2 = null;
		if($a->high < 0) {
			if($b->high < 0) {
				$tmp2 = $v;
			} else {
				$tmp2 = -1;
			}
		} else {
			if($b->high >= 0) {
				$tmp2 = $v;
			} else {
				$tmp2 = 1;
			}
		}
		if($tmp2 < 0) {
			$tmp = "-";
		} else {
			$tmp = "+";
		}
		$b1 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerHourI64;
		$x1 = haxe__Int64_Int64_Impl_::divMod($abs, $b1)->quotient;
		$tmp3 = haxe__Int64_Int64_Impl_::toString($x1);
		$tmp4 = thx_Strings::lpad($tmp3, "0", 2);
		$tmp5 = _hx_string_or_null($tmp) . _hx_string_or_null($tmp4);
		$b2 = thx__DateTimeUtc_DateTimeUtc_Impl_::$ticksPerMinuteI64;
		$a1 = haxe__Int64_Int64_Impl_::divMod($abs, $b2)->quotient;
		$x2 = new haxe__Int64____Int64(0, 60);
		$x3 = haxe__Int64_Int64_Impl_::divMod($a1, $x2)->modulus;
		if($x3->high !== $x3->low >> 31) {
			throw new HException("Overflow");
		}
		$tmp6 = $x3->low;
		$tmp7 = thx_Ints::lpad($tmp6, "0", 2);
		return _hx_string_or_null($tmp5) . _hx_string_or_null($tmp7);
	}
	static function getPattern() {
		return new EReg("(d|H){1,8}|(f|F){1,7}|(h|m|s){1,2}|[:.]|'[^']*'|\"[^\"]*\"", "");
	}
	function __toString() { return 'thx.format.TimeFormat'; }
}
