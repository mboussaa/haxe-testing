<?php

// Generated by Haxe 3.3.0
class thx_format_DecimalFormat {
	public function __construct(){}
	static function currency($decimal, $precision = null, $symbol = null, $culture = null) {
		$decimal = $decimal->trim(null);
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		$pattern = null;
		$tmp = $decimal->isNegative();
		if($tmp) {
			$pattern = thx_culture_Pattern::$currencyNegatives[$nf->patternNegativeCurrency];
		} else {
			$pattern = thx_culture_Pattern::$currencyPositives[$nf->patternPositiveCurrency];
		}
		$_0 = $precision;
		$t = null;
		if(null === $_0) {
			$t = null;
		} else {
			$t = $_0;
		}
		$tmp1 = null;
		if($t !== null) {
			$tmp1 = $t;
		} else {
			$tmp1 = $nf->decimalDigitsCurrency;
		}
		$formatted = thx_format_DecimalFormat::value($decimal, $tmp1, $nf->groupSizesCurrency, $nf->separatorGroupCurrency, $nf->separatorDecimalCurrency);
		$s = str_replace("n", $formatted, $pattern);
		$_01 = $symbol;
		$t1 = null;
		if(null === $_01) {
			$t1 = null;
		} else {
			$t1 = $_01;
		}
		$by = null;
		if($t1 !== null) {
			$by = $t1;
		} else {
			$by = $nf->symbolCurrency;
		}
		return str_replace("\$", $by, $s);
	}
	static function customFormat($decimal, $pattern, $culture = null) {
		$decimal = $decimal->trim(null);
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		$isCurrency = thx_format_DecimalFormat::hasSymbols($pattern, "\$");
		$isPercent = null;
		if(!$isCurrency) {
			$isPercent = thx_format_DecimalFormat::hasSymbols($pattern, "%‰");
		} else {
			$isPercent = false;
		}
		$groups = thx_format_DecimalFormat::splitPattern($pattern, ";");
		if($groups->length > 3) {
			throw new HException("invalid number of sections in \"" . _hx_string_or_null($pattern) . "\"");
		}
		$tmp = $decimal->isNegative();
		if($tmp) {
			if(null !== $groups[1]) {
				$tmp1 = $decimal->negate();
				return thx_format_DecimalFormat::customFormatDecimal($tmp1, $groups[1], $nf, $isCurrency, $isPercent);
			} else {
				$tmp2 = $decimal->negate();
				return thx_format_DecimalFormat::customFormatDecimal($tmp2, "-" . _hx_string_or_null($groups[0]), $nf, $isCurrency, $isPercent);
			}
		} else {
			$tmp3 = $decimal->isZero();
			if($tmp3) {
				$t = null;
				if(null === $groups) {
					$t = null;
				} else {
					$_1 = $groups[2];
					if(null === $_1) {
						$t = null;
					} else {
						$t = $_1;
					}
				}
				$tmp4 = null;
				if($t !== null) {
					$tmp4 = $t;
				} else {
					$tmp4 = $groups[0];
				}
				return thx_format_DecimalFormat::customFormatDecimal(thx__Decimal_Decimal_Impl_::fromInt(0), $tmp4, $nf, $isCurrency, $isPercent);
			} else {
				return thx_format_DecimalFormat::customFormatDecimal($decimal, $groups[0], $nf, $isCurrency, $isPercent);
			}
		}
	}
	static function decimal($dec, $significantDigits = null, $culture = null) {
		if($significantDigits === null) {
			$significantDigits = 1;
		}
		$dec = $dec->trim(null);
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		$formatted = thx_format_DecimalFormat::value($dec, 0, (new _hx_array(array(0))), "", "");
		$tmp = null;
		$tmp1 = $dec->isNegative();
		if($tmp1) {
			$tmp = $nf->signNegative;
		} else {
			$tmp = "";
		}
		$tmp2 = null;
		$tmp3 = null;
		if(strlen("0") !== 0) {
			$tmp3 = strlen($formatted) >= $significantDigits;
		} else {
			$tmp3 = true;
		}
		if($tmp3) {
			$tmp2 = $formatted;
		} else {
			$tmp2 = str_pad($formatted, Math::ceil(($significantDigits - strlen($formatted)) / strlen("0")) * strlen("0") + strlen($formatted), "0", STR_PAD_LEFT);
		}
		return _hx_string_or_null($tmp) . _hx_string_or_null($tmp2);
	}
	static function exponential($decimal, $precision = null, $digits = null, $symbol = null, $culture = null) {
		if($symbol === null) {
			$symbol = "e";
		}
		if($digits === null) {
			$digits = 3;
		}
		if($precision === null) {
			$precision = 6;
		}
		$decimal = $decimal->trim(null);
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		$info = thx_format_DecimalFormat::exponentialInfo($decimal);
		$tmp = thx_format_DecimalFormat::number($info->f, $precision, $culture);
		$tmp1 = _hx_string_or_null($tmp) . _hx_string_or_null($symbol);
		$tmp2 = null;
		if($info->e < 0) {
			$tmp2 = $nf->signNegative;
		} else {
			$tmp2 = $nf->signPositive;
		}
		$tmp3 = _hx_string_or_null($tmp1) . _hx_string_or_null($tmp2);
		$v = $info->e;
		$tmp4 = null;
		if($v < 0) {
			$tmp4 = -$v;
		} else {
			$tmp4 = $v;
		}
		$s = "" . _hx_string_rec($tmp4, "");
		$tmp5 = null;
		$tmp6 = null;
		if(strlen("0") !== 0) {
			$tmp6 = strlen($s) >= $digits;
		} else {
			$tmp6 = true;
		}
		if($tmp6) {
			$tmp5 = $s;
		} else {
			$tmp5 = str_pad($s, Math::ceil(($digits - strlen($s)) / strlen("0")) * strlen("0") + strlen($s), "0", STR_PAD_LEFT);
		}
		return _hx_string_or_null($tmp3) . _hx_string_or_null($tmp5);
	}
	static function fixed($decimal, $precision = null, $culture = null) {
		$decimal = $decimal->trim(null);
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		$pattern = null;
		$tmp = $decimal->isNegative();
		if($tmp) {
			$pattern = thx_culture_Pattern::$numberNegatives[$nf->patternNegativeNumber];
		} else {
			$pattern = "n";
		}
		$_0 = $precision;
		$t = null;
		if(null === $_0) {
			$t = null;
		} else {
			$t = $_0;
		}
		$tmp1 = null;
		if($t !== null) {
			$tmp1 = $t;
		} else {
			$tmp1 = $nf->decimalDigitsNumber;
		}
		$formatted = thx_format_DecimalFormat::value($decimal, $tmp1, (new _hx_array(array(0))), "", $nf->separatorDecimalNumber);
		return str_replace("n", $formatted, $pattern);
	}
	static function format($decimal, $pattern, $culture = null) {
		$specifier = _hx_substring($pattern, 0, 1);
		$tmp = _hx_substring($pattern, 1, null);
		$param = thx_format_DecimalFormat::paramOrNull($tmp);
		switch($specifier) {
		case "%":{
			return thx_format_DecimalFormat::printf($decimal, $pattern, $culture);
		}break;
		case "C":case "c":{
			return thx_format_DecimalFormat::currency($decimal, $param, null, $culture);
		}break;
		case "E":{
			return thx_format_DecimalFormat::exponential($decimal, $param, null, null, $culture);
		}break;
		case "G":{
			return thx_format_DecimalFormat::general($decimal, $param, $culture);
		}break;
		case "P":case "p":{
			return thx_format_DecimalFormat::percent($decimal, $param, $culture);
		}break;
		case "X":{
			$tmp1 = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
			return strtoupper(thx_format_BigIntFormat::hex($tmp1, $param, $culture));
		}break;
		case "D":case "d":{
			return thx_format_DecimalFormat::decimal($decimal, $param, $culture);
		}break;
		case "e":{
			return strtolower(thx_format_DecimalFormat::exponential($decimal, $param, null, null, $culture));
		}break;
		case "F":case "f":{
			return thx_format_DecimalFormat::fixed($decimal, $param, $culture);
		}break;
		case "g":{
			return strtolower(thx_format_DecimalFormat::general($decimal, $param, $culture));
		}break;
		case "N":case "n":{
			return thx_format_DecimalFormat::number($decimal, $param, $culture);
		}break;
		case "R":case "r":{
			return $decimal->toString();
		}break;
		case "x":{
			$tmp2 = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
			return thx_format_BigIntFormat::hex($tmp2, $param, $culture);
		}break;
		default:{
			return thx_format_DecimalFormat::customFormat($decimal, $pattern, $culture);
		}break;
		}
	}
	static function general($decimal, $significantDigits = null, $culture = null) {
		$decimal = $decimal->trim(null);
		$e = thx_format_DecimalFormat::exponential($decimal, $significantDigits, null, null, $culture);
		$f = thx_format_DecimalFormat::fixed($decimal, $significantDigits, $culture);
		if(strlen($e) < strlen($f)) {
			return $e;
		} else {
			return $f;
		}
	}
	static function integer($decimal, $culture = null) {
		$tmp = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
		return thx_format_BigIntFormat::integer($tmp, $culture);
	}
	static function number($decimal, $precision = null, $culture = null) {
		$decimal = $decimal->trim(null);
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		$pattern = null;
		$tmp = $decimal->isNegative();
		if($tmp) {
			$pattern = thx_culture_Pattern::$numberNegatives[$nf->patternNegativeNumber];
		} else {
			$pattern = "n";
		}
		$_0 = $precision;
		$t = null;
		if(null === $_0) {
			$t = null;
		} else {
			$t = $_0;
		}
		$tmp1 = null;
		if($t !== null) {
			$tmp1 = $t;
		} else {
			$tmp1 = $nf->decimalDigitsNumber;
		}
		$formatted = thx_format_DecimalFormat::value($decimal, $tmp1, $nf->groupSizesNumber, $nf->separatorGroupNumber, $nf->separatorDecimalNumber);
		return str_replace("n", $formatted, $pattern);
	}
	static function octal($decimal, $significantDigits = null, $culture = null) {
		if($significantDigits === null) {
			$significantDigits = 1;
		}
		$tmp = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
		return thx_format_BigIntFormat::octal($tmp, null, $culture);
	}
	static function percent($decimal, $decimals = null, $culture = null) {
		$decimal = $decimal->trim(null);
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		$that = thx__Decimal_Decimal_Impl_::fromInt(100);
		$this1 = $decimal->multiply($that);
		$tmp = $this1->trim(null);
		$t = null;
		if(null === $decimals) {
			$t = null;
		} else {
			$t = $decimals;
		}
		$tmp1 = null;
		if($t !== null) {
			$tmp1 = $t;
		} else {
			$tmp1 = $nf->decimalDigitsPercent;
		}
		return thx_format_DecimalFormat::unit($tmp, $tmp1, $nf->symbolPercent, $culture);
	}
	static function permille($decimal, $decimals = null, $culture = null) {
		$decimal = $decimal->trim(null);
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		$that = thx__Decimal_Decimal_Impl_::fromInt(1000);
		$this1 = $decimal->multiply($that);
		$tmp = $this1->trim(null);
		$t = null;
		if(null === $decimals) {
			$t = null;
		} else {
			$t = $decimals;
		}
		$tmp1 = null;
		if($t !== null) {
			$tmp1 = $t;
		} else {
			$tmp1 = $nf->decimalDigitsPercent;
		}
		return thx_format_DecimalFormat::unit($tmp, $tmp1, $nf->symbolPermille, $culture);
	}
	static function printf($decimal, $pattern, $culture = null) {
		$tmp = !StringTools::startsWith($pattern, "%");
		if($tmp) {
			throw new HException("invalid printf term \"" . _hx_string_or_null($pattern) . "\"");
		}
		$decimal = $decimal->trim(null);
		$tmp1 = strlen($pattern) - 1;
		$specifier = _hx_substring($pattern, $tmp1, null);
		$tmp2 = strlen($pattern) - 1;
		$p = _hx_explode(".", _hx_substring($pattern, 1, $tmp2));
		$precision = null;
		$tmp3 = null;
		if(null !== $p[1]) {
			$tmp3 = "" === $p[1];
		} else {
			$tmp3 = true;
		}
		if($tmp3) {
			$precision = null;
		} else {
			$precision = Std::parseInt($p[1]);
		}
		$justifyRight = true;
		$negativeSignOnly = true;
		$emptySpaceForSign = false;
		$prefix = false;
		$padding = " ";
		$width = 0;
		$flags = $p[0];
		while(strlen($flags) > 0) {
			{
				$_g = _hx_substring($flags, 0, 1);
				switch($_g) {
				case " ":{
					$emptySpaceForSign = true;
				}break;
				case "#":{
					$prefix = true;
				}break;
				case "+":{
					$negativeSignOnly = false;
				}break;
				case "-":{
					$justifyRight = false;
				}break;
				case "0":{
					$padding = "0";
				}break;
				default:{
					$tmp4 = thx_Ints::canParse($_g);
					if($tmp4) {
						$width = thx_Ints::parse($flags, null);
						$flags = "";
						continue 2;
					} else {
						throw new HException("invalid flags " . _hx_string_or_null($flags));
					}
				}break;
				}
				unset($_g);
			}
			$flags = _hx_substring($flags, 1, null);
		}
		$decorate = array(new _hx_lambda(array(&$emptySpaceForSign, &$justifyRight, &$negativeSignOnly, &$padding, &$prefix, &$width), "thx_format_DecimalFormat_0"), 'execute');
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		switch($specifier) {
		case "%":{
			return call_user_func_array($decorate, array("%", thx__Decimal_Decimal_Impl_::fromInt(1), "", "", ""));
		}break;
		case "B":{
			$this1 = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
			$tmp8 = $this1->toStringWithBase(2);
			return call_user_func_array($decorate, array($tmp8, thx__Decimal_Decimal_Impl_::fromInt(1), "B", "", ""));
		}break;
		case "E":{
			$tmp9 = thx_format_DecimalFormat::exponential($decimal->abs(), $precision, 0, "E", $culture);
			return call_user_func_array($decorate, array($tmp9, $decimal, "", $nf->signNegative, $nf->signPositive));
		}break;
		case "G":{
			$e = thx_format_DecimalFormat::printf($decimal, "E", $culture);
			$f = thx_format_DecimalFormat::printf($decimal, "f", $culture);
			if(strlen($e) < strlen($f)) {
				return $e;
			} else {
				return $f;
			}
		}break;
		case "X":{
			$this2 = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
			$tmp10 = $this2->abs();
			$tmp11 = thx_format_BigIntFormat::hex($tmp10, $precision, $culture);
			return call_user_func_array($decorate, array($tmp11, $decimal, "0X", $nf->signNegative, $nf->signPositive));
		}break;
		case "b":{
			$this3 = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
			$tmp12 = $this3->toStringWithBase(2);
			return call_user_func_array($decorate, array($tmp12, thx__Decimal_Decimal_Impl_::fromInt(1), "b", "", ""));
		}break;
		case "c":{
			$tmp13 = $decimal->toInt();
			return call_user_func_array($decorate, array(chr($tmp13), thx__Decimal_Decimal_Impl_::fromInt(1), "", "", ""));
		}break;
		case "d":case "i":{
			$this4 = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
			$s1 = $this4->toString();
			$_0 = $precision;
			$t = null;
			if(null === $_0) {
				$t = null;
			} else {
				$t = $_0;
			}
			$l = null;
			if($t !== null) {
				$l = $t;
			} else {
				$l = 0;
			}
			$tmp14 = null;
			$tmp15 = null;
			if(strlen("0") !== 0) {
				$tmp15 = strlen($s1) >= $l;
			} else {
				$tmp15 = true;
			}
			if($tmp15) {
				$tmp14 = $s1;
			} else {
				$tmp14 = str_pad($s1, Math::ceil(($l - strlen($s1)) / strlen("0")) * strlen("0") + strlen($s1), "0", STR_PAD_LEFT);
			}
			return call_user_func_array($decorate, array($tmp14, $decimal, "", $nf->signNegative, $nf->signPositive));
		}break;
		case "e":{
			$tmp16 = thx_format_DecimalFormat::exponential($decimal->abs(), $precision, 0, "e", $culture);
			return call_user_func_array($decorate, array($tmp16, $decimal, "", $nf->signNegative, $nf->signPositive));
		}break;
		case "f":{
			$tmp17 = thx_format_DecimalFormat::fixed($decimal->abs(), $precision, $culture);
			return call_user_func_array($decorate, array($tmp17, $decimal, "", $nf->signNegative, $nf->signPositive));
		}break;
		case "g":{
			$e1 = thx_format_DecimalFormat::printf($decimal, "e", $culture);
			$f1 = thx_format_DecimalFormat::printf($decimal, "f", $culture);
			if(strlen($e1) < strlen($f1)) {
				return $e1;
			} else {
				return $f1;
			}
		}break;
		case "o":{
			$this5 = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
			$tmp18 = $this5->abs();
			$tmp19 = thx_format_BigIntFormat::octal($tmp18, $precision, $culture);
			return call_user_func_array($decorate, array($tmp19, $decimal, "0", $nf->signNegative, $nf->signPositive));
		}break;
		case "u":{
			return thx_format_DecimalFormat::printf($decimal->abs(), "d", $culture);
		}break;
		case "x":{
			$this6 = thx__Decimal_Decimal_Impl_::toBigInt($decimal);
			$tmp20 = $this6->abs();
			$tmp21 = thx_format_BigIntFormat::hex($tmp20, $precision, $culture);
			return call_user_func_array($decorate, array($tmp21, $decimal, "0x", $nf->signNegative, $nf->signPositive));
		}break;
		default:{
			throw new HException("invalid pattern \"" . _hx_string_or_null($pattern) . "\"");
		}break;
		}
	}
	static function toBase($value, $base, $culture = null) {
		$tmp = thx__Decimal_Decimal_Impl_::toBigInt($value);
		return thx_format_BigIntFormat::toBase($tmp, $base, $culture);
	}
	static function unit($decimal, $decimals, $unitSymbol, $culture = null) {
		$decimal = $decimal->trim(null);
		$nf = thx_format_DecimalFormat::numberFormat($culture);
		$pattern = null;
		$tmp = $decimal->isNegative();
		if($tmp) {
			$pattern = thx_culture_Pattern::$percentNegatives[$nf->patternNegativePercent];
		} else {
			$pattern = thx_culture_Pattern::$percentPositives[$nf->patternPositivePercent];
		}
		$formatted = thx_format_DecimalFormat::value($decimal, $decimals, $nf->groupSizesPercent, $nf->separatorGroupPercent, $nf->separatorDecimalPercent);
		$s = str_replace("n", $formatted, $pattern);
		return str_replace("%", $unitSymbol, $s);
	}
	static function exponentialInfo($decimal) {
		$this1 = $decimal->abs();
		$s = $this1->toString();
		$p = _hx_explode(".", $s)->concat((new _hx_array(array(""))));
		$e = 0;
		$tmp = strlen($p[0]) > 1;
		if($tmp) {
			$e = strlen($p[0]) - 1;
			$tmp1 = _hx_substring($p[0], 1, null);
			$p[1] = _hx_string_or_null($tmp1) . _hx_string_or_null($p[1]);
			$tmp2 = _hx_substring($p[0], 0, 1);
			$p[0] = $tmp2;
		} else {
			if($p[0] === "0") {
				$tmp3 = 1 + strlen($p[1]);
				$e = -($tmp3 - strlen(thx_Strings::trimCharsLeft($p[1], "0")));
				$tmp4 = _hx_substring($p[1], -$e - 1, null);
				$p[1] = $tmp4;
				$tmp5 = _hx_substring($p[1], 0, 1);
				$p[0] = $tmp5;
				$tmp6 = _hx_substring($p[1], 1, null);
				$p[1] = $tmp6;
			}
		}
		$value = $p->slice(0, 2)->join(".");
		$this2 = thx_bigint_Decimals::parse($value);
		$tmp7 = null;
		$tmp8 = $decimal->isNegative();
		if($tmp8) {
			$tmp7 = -1;
		} else {
			$tmp7 = 1;
		}
		$that = thx__Decimal_Decimal_Impl_::fromInt($tmp7);
		$this3 = $this2->multiply($that);
		$tmp9 = $this3->trim(null);
		return _hx_anonymous(array("e" => $e, "f" => $tmp9));
	}
	static function customFormatDecimalFraction($d, $pattern, $nf) {
		$buf = "";
		$i = 0;
		$quote = 0;
		$p = thx_Strings::toArray($d);
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					$tmp = $quote;
					switch($tmp) {
					case 0:{
						$quote = 2;
					}break;
					case 1:{
						$buf .= _hx_string_or_null($_g);
					}break;
					case 2:{
						$quote = 0;
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "#":{
					switch($quote) {
					case 0:{
						$tmp1 = null;
						$tmp2 = $p->length === 0;
						if($tmp2) {
							$tmp1 = "";
						} else {
							$tmp1 = $p->shift();
						}
						$buf .= _hx_string_or_null($tmp1);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "\$":{
					switch($quote) {
					case 0:{
						$buf .= _hx_string_or_null($nf->symbolCurrency);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "%":{
					switch($quote) {
					case 0:{
						$buf .= _hx_string_or_null($nf->symbolPercent);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "'":{
					$tmp3 = $quote;
					switch($tmp3) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
					}break;
					case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "0":{
					switch($quote) {
					case 0:{
						$tmp4 = null;
						$tmp5 = $p->length === 0;
						if($tmp5) {
							$tmp4 = "0";
						} else {
							$tmp4 = $p->shift();
						}
						$buf .= _hx_string_or_null($tmp4);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				case "\\":{
					++$i;
					$tmp6 = _hx_substring($pattern, $i, $i + 1);
					$buf .= _hx_string_or_null($tmp6);
				}break;
				case "‰":{
					switch($quote) {
					case 0:{
						$buf .= _hx_string_or_null($nf->symbolPermille);
					}break;
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				default:{
					switch($quote) {
					case 1:case 2:{
						$buf .= _hx_string_or_null($_g);
					}break;
					default:{
						$buf .= _hx_string_or_null($_g);
					}break;
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		return $buf;
	}
	static function customFormatDecimal($decimal, $pattern, $nf, $isCurrency, $isPercent) {
		if($isPercent) {
			$tmp = null;
			$tmp1 = thx_format_DecimalFormat::hasSymbols($pattern, "‰");
			if($tmp1) {
				$tmp = 1000;
			} else {
				$tmp = 100;
			}
			$that = thx__Decimal_Decimal_Impl_::fromInt($tmp);
			$this1 = $decimal->multiply($that);
			$decimal = $this1->trim(null);
		}
		$exp = thx_format_DecimalFormat::splitPattern($pattern, "eE");
		$tmp2 = $exp->length > 1;
		if($tmp2) {
			$info = thx_format_DecimalFormat::exponentialInfo($decimal);
			$tmp3 = strlen($exp[0]);
			$tmp4 = strlen($exp[0]) + 1;
			$symbol = _hx_substring($pattern, $tmp3, $tmp4);
			$forceSign = StringTools::startsWith($exp[1], "+");
			$tmp5 = null;
			if(!$forceSign) {
				$tmp5 = StringTools::startsWith($exp[1], "-");
			} else {
				$tmp5 = true;
			}
			if($tmp5) {
				$tmp6 = _hx_substring($exp[1], 1, null);
				$exp[1] = $tmp6;
			}
			$tmp7 = thx_format_DecimalFormat::customIntegerAndFraction($info->f, $exp[0], $nf, $isCurrency, $isPercent);
			$tmp8 = _hx_string_or_null($tmp7) . _hx_string_or_null($symbol);
			$tmp9 = null;
			if($info->e < 0) {
				$tmp9 = $nf->signNegative;
			} else {
				if($forceSign) {
					$tmp9 = $nf->signPositive;
				} else {
					$tmp9 = "";
				}
			}
			$tmp10 = _hx_string_or_null($tmp8) . _hx_string_or_null($tmp9);
			$tmp11 = Math::abs($info->e);
			$tmp12 = thx_format_DecimalFormat::customFormatInteger("" . _hx_string_rec($tmp11, ""), $exp[1], $nf, $isCurrency, $isPercent);
			return _hx_string_or_null($tmp10) . _hx_string_or_null($tmp12);
		} else {
			return thx_format_DecimalFormat::customIntegerAndFraction($decimal, $pattern, $nf, $isCurrency, $isPercent);
		}
	}
	static function customFormatInteger($v, $pattern, $nf, $isCurrency, $isPercent) {
		$buf = (new _hx_array(array()));
		$i = 0;
		$quote = 0;
		$p = thx_Strings::toArray($v);
		$lbuf = "";
		$first = true;
		$useGroups = false;
		$zeroes = 0;
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					switch($quote) {
					case 0:{
						$quote = 2;
					}break;
					case 1:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					case 2:{
						$quote = 0;
						$tmp = thx_format__DecimalFormat_CustomFormat::Literal($lbuf);
						$buf->push($tmp);
						$lbuf = "";
					}break;
					default:{
						$tmp1 = thx_format__DecimalFormat_CustomFormat::Literal($_g);
						$buf->push($tmp1);
					}break;
					}
				}break;
				case "#":{
					switch($quote) {
					case 0:{
						$tmp2 = thx_format__DecimalFormat_CustomFormat::Hash($first);
						$buf->push($tmp2);
						$first = false;
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp3 = thx_format__DecimalFormat_CustomFormat::Literal($_g);
						$buf->push($tmp3);
					}break;
					}
				}break;
				case "\$":{
					switch($quote) {
					case 0:{
						$tmp4 = thx_format__DecimalFormat_CustomFormat::Literal($nf->symbolCurrency);
						$buf->push($tmp4);
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp5 = thx_format__DecimalFormat_CustomFormat::Literal($_g);
						$buf->push($tmp5);
					}break;
					}
				}break;
				case "%":{
					switch($quote) {
					case 0:{
						$tmp6 = thx_format__DecimalFormat_CustomFormat::Literal($nf->symbolPercent);
						$buf->push($tmp6);
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp7 = thx_format__DecimalFormat_CustomFormat::Literal($_g);
						$buf->push($tmp7);
					}break;
					}
				}break;
				case "'":{
					switch($quote) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
						$tmp8 = thx_format__DecimalFormat_CustomFormat::Literal($lbuf);
						$buf->push($tmp8);
						$lbuf = "";
					}break;
					case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp9 = thx_format__DecimalFormat_CustomFormat::Literal($_g);
						$buf->push($tmp9);
					}break;
					}
				}break;
				case ",":{
					switch($quote) {
					case 0:{
						$useGroups = true;
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp10 = thx_format__DecimalFormat_CustomFormat::Literal($_g);
						$buf->push($tmp10);
					}break;
					}
				}break;
				case "0":{
					switch($quote) {
					case 0:{
						$tmp11 = thx_format__DecimalFormat_CustomFormat::Zero($first);
						$buf->push($tmp11);
						$first = false;
						++$zeroes;
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp12 = thx_format__DecimalFormat_CustomFormat::Literal($_g);
						$buf->push($tmp12);
					}break;
					}
				}break;
				case "\\":{
					++$i;
					$tmp13 = _hx_substring($pattern, $i, $i + 1);
					$tmp14 = thx_format__DecimalFormat_CustomFormat::Literal($tmp13);
					$buf->push($tmp14);
				}break;
				case "‰":{
					switch($quote) {
					case 0:{
						$tmp15 = thx_format__DecimalFormat_CustomFormat::Literal($nf->symbolPermille);
						$buf->push($tmp15);
					}break;
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp16 = thx_format__DecimalFormat_CustomFormat::Literal($_g);
						$buf->push($tmp16);
					}break;
					}
				}break;
				default:{
					switch($quote) {
					case 1:case 2:{
						$lbuf .= _hx_string_or_null($_g);
					}break;
					default:{
						$tmp17 = thx_format__DecimalFormat_CustomFormat::Literal($_g);
						$buf->push($tmp17);
					}break;
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		$tmp18 = strlen($lbuf) > 0;
		if($tmp18) {
			$tmp19 = thx_format__DecimalFormat_CustomFormat::Literal($lbuf);
			$buf->push($tmp19);
		}
		{
			$_g1 = $p->length;
			$_g2 = $zeroes;
			while($_g1 < $_g2) {
				++$_g1;
				$p->unshift("0");
			}
		}
		if($useGroups) {
			$i = $p->length - 1;
			$groups = null;
			if($isCurrency) {
				$groups = $nf->groupSizesCurrency->copy();
			} else {
				if($isPercent) {
					$groups = $nf->groupSizesPercent->copy();
				} else {
					$groups = $nf->groupSizesNumber->copy();
				}
			}
			$group = $groups->shift();
			$pos = 0;
			while($i >= 0) {
				if($group === 0) {
					break;
				}
				if($pos === $group) {
					$tmp20 = $p[$i];
					$tmp21 = null;
					if($isCurrency) {
						$tmp21 = $nf->separatorGroupCurrency;
					} else {
						if($isPercent) {
							$tmp21 = $nf->separatorGroupPercent;
						} else {
							$tmp21 = $nf->separatorGroupNumber;
						}
					}
					$p[$i] = _hx_string_or_null($tmp20) . _hx_string_or_null($tmp21);
					$pos = 0;
					$tmp22 = $groups->length > 0;
					if($tmp22) {
						$group = $groups->shift();
					}
					unset($tmp22,$tmp21,$tmp20);
				} else {
					++$pos;
					--$i;
				}
			}
		}
		$buf->reverse();
		$r = $buf->map(array(new _hx_lambda(array(&$p), "thx_format_DecimalFormat_1"), 'execute'));
		$r->reverse();
		return $r->join("");
	}
	static function customIntegerAndFraction($decimal, $pattern, $nf, $isCurrency, $isPercent) {
		$p = thx_format_DecimalFormat::splitPattern($pattern, ".");
		$tmp = strlen($p[0]);
		$power = $tmp - strlen(($p[0] = thx_Strings::trimCharsRight($p[0], ",")));
		$value = Math::pow(1000, $power);
		$that = thx_bigint_Decimals::fromFloat($value);
		$this1 = $decimal->divide($that);
		$decimal = $this1->trim(null);
		$tmp1 = $p->length === 1;
		if($tmp1) {
			$this2 = thx__Decimal_Decimal_Impl_::toBigInt($decimal->roundTo(0));
			$tmp2 = $this2->toString();
			return thx_format_DecimalFormat::customFormatInteger($tmp2, $p[0], $nf, $isCurrency, $isPercent);
		} else {
			$decimals = thx_format_DecimalFormat::countSymbols($p[1], "#0");
			$this3 = $decimal->roundTo($decimals);
			$decimal = $this3->trim(null);
			$np = thx_format_DecimalFormat::splitOnDecimalSeparator($decimal);
			$tmp3 = thx_format_DecimalFormat::customFormatInteger($np[0], $p[0], $nf, $isCurrency, $isPercent);
			$tmp4 = null;
			if($isCurrency) {
				$tmp4 = $nf->separatorDecimalCurrency;
			} else {
				if($isPercent) {
					$tmp4 = $nf->separatorDecimalPercent;
				} else {
					$tmp4 = $nf->separatorDecimalNumber;
				}
			}
			$tmp5 = _hx_string_or_null($tmp3) . _hx_string_or_null($tmp4);
			$t = null;
			if(null === $np) {
				$t = null;
			} else {
				$_1 = $np[1];
				if(null === $_1) {
					$t = null;
				} else {
					$t = $_1;
				}
			}
			$tmp6 = null;
			if($t !== null) {
				$tmp6 = $t;
			} else {
				$tmp6 = "0";
			}
			$tmp7 = thx_format_DecimalFormat::customFormatDecimalFraction($tmp6, $p[1], $nf);
			return _hx_string_or_null($tmp5) . _hx_string_or_null($tmp7);
		}
	}
	static function hasSymbols($pattern, $symbols) {
		$i = 0;
		$quote = 0;
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					$tmp = $quote;
					switch($tmp) {
					case 0:{
						$quote = 2;
					}break;
					case 2:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "'":{
					$tmp1 = $quote;
					switch($tmp1) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "\\":{
					++$i;
				}break;
				default:{
					if($quote === 0) {
						$tmp2 = null;
						if($_g !== "") {
							$tmp3 = _hx_index_of($symbols, $_g, null);
							$tmp2 = $tmp3 >= 0;
						} else {
							$tmp2 = true;
						}
						if($tmp2) {
							return true;
						}
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		return false;
	}
	static function intPart($s, $groupSizes, $groupSeparator) {
		$buf = (new _hx_array(array()));
		$sizes = $groupSizes->copy();
		$size = $sizes->shift();
		while(strlen($s) > 0) {
			if($size === 0) {
				$buf->unshift($s);
				$s = "";
			} else {
				$tmp = strlen($s) > $size;
				if($tmp) {
					$tmp1 = strlen($s) - $size;
					$tmp2 = _hx_substring($s, $tmp1, null);
					$buf->unshift($tmp2);
					$tmp3 = strlen($s) - $size;
					$s = _hx_substring($s, 0, $tmp3);
					$tmp4 = $sizes->length > 0;
					if($tmp4) {
						$size = $sizes->shift();
					}
					unset($tmp4,$tmp3,$tmp2,$tmp1);
				} else {
					$buf->unshift($s);
					$s = "";
				}
				unset($tmp);
			}
		}
		return $buf->join($groupSeparator);
	}
	static function numberFormat($culture) {
		$tmp = null;
		if(null !== $culture) {
			$tmp = null !== $culture->number;
		} else {
			$tmp = false;
		}
		if($tmp) {
			return $culture->number;
		} else {
			return thx_format_Format::get_defaultCulture()->number;
		}
	}
	static function pad($s, $len, $round) {
		$_0 = $s;
		$t = null;
		if(null === $_0) {
			$t = null;
		} else {
			$t = $_0;
		}
		if($t !== null) {
			$s = $t;
		} else {
			$s = "";
		}
		$tmp = null;
		if($len > 0) {
			$tmp = strlen($s) > $len;
		} else {
			$tmp = false;
		}
		if($tmp) {
			if($round) {
				$tmp1 = _hx_substring($s, 0, $len - 1);
				$tmp2 = _hx_substring($s, $len - 1, $len);
				$tmp3 = Std::parseInt($tmp2);
				$tmp4 = null;
				$tmp5 = _hx_substring($s, $len, $len + 1);
				$tmp6 = Std::parseInt($tmp5);
				if($tmp6 >= 5) {
					$tmp4 = 1;
				} else {
					$tmp4 = 0;
				}
				return _hx_string_or_null($tmp1) . _hx_string_rec(($tmp3 + $tmp4), "");
			} else {
				return _hx_substring($s, 0, $len);
			}
		} else {
			$tmp7 = null;
			if(strlen("0") !== 0) {
				$tmp7 = strlen($s) >= $len;
			} else {
				$tmp7 = true;
			}
			if($tmp7) {
				return $s;
			} else {
				return str_pad($s, Math::ceil(($len - strlen($s)) / strlen("0")) * strlen("0") + strlen($s), "0", STR_PAD_RIGHT);
			}
		}
	}
	static function paramOrNull($param) {
		$tmp = strlen($param) === 0;
		if($tmp) {
			return null;
		} else {
			return Std::parseInt($param);
		}
	}
	static function splitOnDecimalSeparator($decimal) {
		return _hx_explode(".", $decimal->toString());
	}
	static function splitPattern($pattern, $separator) {
		$pos = (new _hx_array(array()));
		$i = 0;
		$quote = 0;
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					$tmp = $quote;
					switch($tmp) {
					case 0:{
						$quote = 2;
					}break;
					case 2:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "'":{
					$tmp1 = $quote;
					switch($tmp1) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "\\":{
					++$i;
				}break;
				default:{
					if($quote === 0) {
						$tmp2 = null;
						if($_g !== "") {
							$tmp3 = _hx_index_of($separator, $_g, null);
							$tmp2 = $tmp3 >= 0;
						} else {
							$tmp2 = true;
						}
						if($tmp2) {
							$pos->push($i);
						}
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		$buf = (new _hx_array(array()));
		$prev = 0;
		{
			$_g1 = 0;
			while($_g1 < $pos->length) {
				$p = $pos[$_g1];
				++$_g1;
				$tmp4 = _hx_substring($pattern, $prev, $p);
				$buf->push($tmp4);
				$prev = $p + 1;
				unset($tmp4,$p);
			}
		}
		$tmp5 = _hx_substring($pattern, $prev, null);
		$buf->push($tmp5);
		return $buf;
	}
	static function value($decimal, $precision, $groupSizes, $groupSeparator, $decimalSeparator) {
		$decimal = $decimal->abs();
		$p = thx_format_DecimalFormat::splitOnDecimalSeparator($decimal);
		$tmp = null;
		if($precision <= 0) {
			$tmp = null !== $p[1];
		} else {
			$tmp = false;
		}
		if($tmp) {
			$tmp1 = Std::parseFloat("0." . _hx_string_or_null($p[1]));
			if($tmp1 >= 0.5) {
				$tmp2 = strlen($p[0]) - 1;
				$tmp3 = _hx_substring($p[0], 0, $tmp2);
				$tmp4 = strlen($p[0]) - 1;
				$tmp5 = _hx_substring($p[0], $tmp4, null);
				$tmp6 = Std::parseFloat($tmp5);
				$p[0] = _hx_string_or_null($tmp3) . _hx_string_rec(($tmp6 + 1), "");
			}
		}
		$buf = (new _hx_array(array()));
		$tmp7 = thx_format_DecimalFormat::intPart($p[0], $groupSizes, $groupSeparator);
		$buf->push($tmp7);
		if($precision > 0) {
			$tmp8 = thx_format_DecimalFormat::pad($p[1], $precision, true);
			$buf->push($tmp8);
		}
		return $buf->join($decimalSeparator);
	}
	static function countSymbols($pattern, $symbols) {
		$i = 0;
		$quote = 0;
		$count = 0;
		while($i < strlen($pattern)) {
			{
				$_g = _hx_substring($pattern, $i, $i + 1);
				switch($_g) {
				case "\"":{
					$tmp = $quote;
					switch($tmp) {
					case 0:{
						$quote = 2;
					}break;
					case 2:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "'":{
					$tmp1 = $quote;
					switch($tmp1) {
					case 0:{
						$quote = 1;
					}break;
					case 1:{
						$quote = 0;
					}break;
					default:{}break;
					}
				}break;
				case "\\":{
					++$i;
				}break;
				default:{
					if($quote === 0) {
						$tmp2 = null;
						if($_g !== "") {
							$tmp3 = _hx_index_of($symbols, $_g, null);
							$tmp2 = $tmp3 >= 0;
						} else {
							$tmp2 = true;
						}
						if($tmp2) {
							++$count;
						}
					}
				}break;
				}
				unset($_g);
			}
			++$i;
		}
		return $count;
	}
	function __toString() { return 'thx.format.DecimalFormat'; }
}
function thx_format_DecimalFormat_0(&$emptySpaceForSign, &$justifyRight, &$negativeSignOnly, &$padding, &$prefix, &$width, $s, $decimal1, $p1, $ns, $ps) {
	{
		if($prefix) {
			$s = _hx_string_or_null($p1) . _hx_string_or_null($s);
		}
		$tmp5 = $decimal1->isNegative();
		if($tmp5) {
			$s = _hx_string_or_null($ns) . _hx_string_or_null($s);
		} else {
			if(!$negativeSignOnly) {
				$s = _hx_string_or_null($ps) . _hx_string_or_null($s);
			} else {
				if($emptySpaceForSign) {
					$s = " " . _hx_string_or_null($s);
				}
			}
		}
		if($justifyRight) {
			$tmp6 = null;
			if(strlen($padding) !== 0) {
				$tmp6 = strlen($s) >= $width;
			} else {
				$tmp6 = true;
			}
			if($tmp6) {
				return $s;
			} else {
				return str_pad($s, Math::ceil(($width - strlen($s)) / strlen($padding)) * strlen($padding) + strlen($s), $padding, STR_PAD_LEFT);
			}
		} else {
			$tmp7 = null;
			if(strlen($padding) !== 0) {
				$tmp7 = strlen($s) >= $width;
			} else {
				$tmp7 = true;
			}
			if($tmp7) {
				return $s;
			} else {
				return str_pad($s, Math::ceil(($width - strlen($s)) / strlen($padding)) * strlen($padding) + strlen($s), $padding, STR_PAD_RIGHT);
			}
		}
	}
}
function thx_format_DecimalFormat_1(&$p, $_) {
	{
		$tmp23 = $_->index;
		switch($tmp23) {
		case 0:{
			return _hx_deref($_)->params[0];
		}break;
		case 1:{
			$first1 = _hx_deref($_)->params[0];
			$tmp24 = $p->length === 0;
			if($tmp24) {
				return "";
			} else {
				if($first1) {
					return $p->join("");
				} else {
					return $p->pop();
				}
			}
		}break;
		case 2:{
			if(_hx_deref($_)->params[0]) {
				return $p->join("");
			} else {
				return $p->pop();
			}
		}break;
		}
	}
}
