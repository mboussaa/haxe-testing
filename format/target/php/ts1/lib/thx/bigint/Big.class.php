<?php

// Generated by Haxe 3.3.0
class thx_bigint_Big implements thx_bigint_BigIntImpl{
	public function __construct($value, $sign) {
		if(!php_Boot::$skip_constructor) {
		$this->sign = $sign;
		$this->value = $value;
		$this->isSmall = false;
	}}
	public $value;
	public $sign;
	public $isSmall;
	public function add($that) {
		$tmp = $that->isZero();
		if($tmp) {
			return $this;
		}
		$tmp1 = $this->isZero();
		if($tmp1) {
			return $that;
		}
		$tmp2 = (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $that->sign : !_hx_equal($_t, $that->sign));
		if($tmp2) {
			$tmp3 = $that->negate();
			return $this->subtract($tmp3);
		}
		$tmp4 = $that->isSmall;
		if($tmp4) {
			return $this->addSmall($that);
		} else {
			return $this->addBig($that);
		}
	}
	public function addSmall($small) {
		$v = $small->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::addSmall($this->value, $tmp);
		return new thx_bigint_Big($tmp1, $this->sign);
	}
	public function addBig($big) {
		$tmp = thx_bigint_Bigs::addAny($this->value, $big->value);
		return new thx_bigint_Big($tmp, $this->sign);
	}
	public function subtract($that) {
		$tmp = $that->isZero();
		if($tmp) {
			return $this;
		}
		$tmp1 = $this->isZero();
		if($tmp1) {
			return $that->negate();
		}
		$tmp2 = (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $that->sign : !_hx_equal($_t, $that->sign));
		if($tmp2) {
			$tmp3 = $that->negate();
			return $this->add($tmp3);
		}
		$tmp4 = $that->isSmall;
		if($tmp4) {
			return $this->subtractSmall($that);
		} else {
			return $this->subtractBig($that);
		}
	}
	public function subtractSmall($small) {
		$v = $small->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		return thx_bigint_Bigs::subtractSmall($this->value, $tmp, $this->sign);
	}
	public function subtractBig($big) {
		return thx_bigint_Bigs::subtractAny($this->value, $big->value, $this->sign);
	}
	public function divide($that) {
		return $this->divMod($that)->quotient;
	}
	public function divMod($that) {
		$tmp = $that->isZero();
		if($tmp) {
			throw new HException(new thx_Error("division by zero", null, _hx_anonymous(array("fileName" => "Big.hx", "lineNumber" => 55, "className" => "thx.bigint.Big", "methodName" => "divMod"))));
		}
		$tmp1 = $that->isSmall;
		if($tmp1) {
			return $this->divModSmall($that);
		} else {
			return $this->divModBig($that);
		}
	}
	public function divModSmall($small) {
		$v = $small->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$values = thx_bigint_Bigs::divModSmall($this->value, $tmp);
		$quotient = thx_bigint_Bigs::arrayToSmall($values->q);
		$remainder = $values->r;
		if($this->sign) {
			$remainder = -$remainder;
		}
		$tmp1 = null !== $quotient;
		if($tmp1) {
			if((is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $small->sign : !_hx_equal($_t, $small->sign))) {
				$quotient = -$quotient;
			}
			$tmp2 = new thx_bigint_Small($quotient);
			return _hx_anonymous(array("quotient" => $tmp2, "remainder" => new thx_bigint_Small($remainder)));
		}
		$tmp3 = new thx_bigint_Big($values->q, (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $small->sign : !_hx_equal($_t, $small->sign)));
		return _hx_anonymous(array("quotient" => $tmp3, "remainder" => new thx_bigint_Small($remainder)));
	}
	public function divModBig($big) {
		$comparison = thx_bigint_Bigs::compareToAbs($this->value, $big->value);
		if($comparison === -1) {
			return _hx_anonymous(array("quotient" => thx_bigint_Small::$zero, "remainder" => $this));
		}
		if($comparison === 0) {
			$tmp = null;
			if((is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t == $big->sign : _hx_equal($_t, $big->sign))) {
				$tmp = thx_bigint_Small::$one;
			} else {
				$tmp = thx_bigint_Small::$negativeOne;
			}
			return _hx_anonymous(array("quotient" => $tmp, "remainder" => thx_bigint_Small::$zero));
		}
		$values = null;
		$tmp1 = $this->value->length + $big->value->length <= 200;
		if($tmp1) {
			$values = thx_bigint_Bigs::divMod1($this->value, $big->value);
		} else {
			$values = thx_bigint_Bigs::divMod2($this->value, $big->value);
		}
		$q = _hx_array_get($values, 0)->small;
		$quotient = null;
		$remainder = null;
		$qSign = (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $big->sign : !_hx_equal($_t, $big->sign));
		$r = _hx_array_get($values, 1)->small;
		$mSign = $this->sign;
		$tmp2 = null !== $q;
		if($tmp2) {
			if($qSign) {
				$q = -$q;
			}
			$quotient = new thx_bigint_Small($q);
		} else {
			$quotient = new thx_bigint_Big(_hx_array_get($values, 0)->big, $qSign);
		}
		$tmp3 = null !== $r;
		if($tmp3) {
			if($mSign) {
				$r = -$r;
			}
			$remainder = new thx_bigint_Small($r);
		} else {
			$remainder = new thx_bigint_Big(_hx_array_get($values, 1)->big, $mSign);
		}
		return _hx_anonymous(array("quotient" => $quotient, "remainder" => $remainder));
	}
	public function multiply($that) {
		$tmp = $that->isZero();
		if($tmp) {
			return thx_bigint_Small::$zero;
		}
		$tmp1 = $that->isSmall;
		if($tmp1) {
			return $this->multiplySmall($that);
		} else {
			return $this->multiplyBig($that);
		}
	}
	public function multiplySmall($small) {
		$v = $small->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::smallToArray($tmp);
		$tmp2 = thx_bigint_Bigs::multiplyLong($this->value, $tmp1);
		return new thx_bigint_Big($tmp2, (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $small->sign : !_hx_equal($_t, $small->sign)));
	}
	public function multiplyBig($big) {
		$tmp = $this->value->length + $big->value->length > 4000;
		if($tmp) {
			$tmp1 = thx_bigint_Bigs::multiplyKaratsuba($this->value, $big->value);
			return new thx_bigint_Big($tmp1, (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $big->sign : !_hx_equal($_t, $big->sign)));
		}
		$tmp2 = thx_bigint_Bigs::multiplyLong($this->value, $big->value);
		return new thx_bigint_Big($tmp2, (is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $big->sign : !_hx_equal($_t, $big->sign)));
	}
	public function modulo($that) {
		return $this->divMod($that)->remainder;
	}
	public function random() {
		$length = $this->value->length - 1;
		$result = (new _hx_array(array()));
		$restricted = true;
		$i = $length;
		$top = null;
		$digit = null;
		while($i >= 0) {
			if($restricted) {
				$top = $this->value[$i];
			} else {
				$top = 10000000;
			}
			$tmp = Math::random();
			$value = $tmp * $top;
			if($value < 0.0) {
				$digit = Math::ceil($value);
			} else {
				$digit = Math::floor($value);
			}
			$result->unshift($digit);
			if($digit < $top) {
				$restricted = false;
			}
			--$i;
			unset($value,$tmp);
		}
		$v = thx_bigint_Bigs::arrayToSmall($result);
		if(null !== $v) {
			return new thx_bigint_Small($v);
		} else {
			return new thx_bigint_Big($result, false);
		}
	}
	public function abs() {
		return new thx_bigint_Big($this->value, false);
	}
	public function negate() {
		return new thx_bigint_Big($this->value, !$this->sign);
	}
	public function next() {
		return $this->add(thx_bigint_Small::$one);
	}
	public function prev() {
		return $this->subtract(thx_bigint_Small::$one);
	}
	public function pow($exp) {
		$tmp = $this->isZero();
		if($tmp) {
			$tmp1 = $exp->isZero();
			if($tmp1) {
				return thx_bigint_Small::$one;
			} else {
				return $this;
			}
		}
		$tmp2 = $this->isUnit();
		if($tmp2) {
			$tmp3 = $this->sign;
			if($tmp3) {
				$tmp4 = $exp->isEven();
				if($tmp4) {
					return thx_bigint_Small::$one;
				} else {
					return thx_bigint_Small::$negativeOne;
				}
			} else {
				return thx_bigint_Small::$one;
			}
		}
		if($exp->sign) {
			return thx_bigint_Small::$zero;
		}
		$tmp5 = !$exp->isSmall;
		if($tmp5) {
			$tmp6 = Std::string($exp);
			throw new HException(new thx_Error("The exponent " . _hx_string_or_null($tmp6) . " is too large.", null, _hx_anonymous(array("fileName" => "Big.hx", "lineNumber" => 174, "className" => "thx.bigint.Big", "methodName" => "pow"))));
		}
		$b = $exp->value;
		$x = $this;
		$y = thx_bigint_Small::$one;
		while(true) {
			if(($b & 1) === 1) {
				$y = $y->multiply($x);
				--$b;
			}
			if($b === 0) {
				break;
			}
			$b = Std::int($b / 2);
			$x = $x->square();
		}
		return $y;
	}
	public function shiftLeft($n) {
		if($n < 0) {
			return $this->shiftRight(-$n);
		}
		$result = $this;
		while($n >= thx_bigint_Bigs::$powers2Length) {
			$result = $result->multiply(thx_bigint_Bigs::$bigHighestPower2);
			$n -= thx_bigint_Bigs::$powers2Length - 1;
		}
		return $result->multiply(thx_bigint_Bigs::$bigPowersOfTwo[$n]);
	}
	public function shiftRight($n) {
		if($n < 0) {
			return $this->shiftLeft(-$n);
		}
		$result = $this;
		$remQuo = null;
		while($n >= thx_bigint_Bigs::$powers2Length) {
			$tmp = $result->isZero();
			if($tmp) {
				return $result;
			}
			$remQuo = $result->divMod(thx_bigint_Bigs::$bigHighestPower2);
			$tmp1 = $remQuo->remainder->sign;
			if($tmp1) {
				$result = $remQuo->quotient->prev();
			} else {
				$result = $remQuo->quotient;
			}
			$n -= thx_bigint_Bigs::$powers2Length - 1;
			unset($tmp1,$tmp);
		}
		$remQuo = $result->divMod(thx_bigint_Bigs::$bigPowersOfTwo[$n]);
		$tmp2 = $remQuo->remainder->sign;
		if($tmp2) {
			return $remQuo->quotient->prev();
		} else {
			return $remQuo->quotient;
		}
	}
	public function square() {
		$tmp = thx_bigint_Bigs::square($this->value);
		return new thx_bigint_Big($tmp, false);
	}
	public function isEven() {
		return ($this->value->a[0] & 1) === 0;
	}
	public function isOdd() {
		return ($this->value->a[0] & 1) === 1;
	}
	public function isZero() {
		return $this->value->length === 0;
	}
	public function isUnit() {
		return false;
	}
	public function compareTo($that) {
		if((is_object($_t = $this->sign) && ($_t instanceof Enum) ? $_t != $that->sign : !_hx_equal($_t, $that->sign))) {
			if($this->sign) {
				return -1;
			} else {
				return 1;
			}
		}
		$tmp = $that->isSmall;
		if($tmp) {
			return $this->compareToSmall($that);
		} else {
			return $this->compareToBig($that);
		}
	}
	public function compareToSmall($small) {
		$v = $small->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::smallToArray($tmp);
		$tmp2 = thx_bigint_Bigs::compareToAbs($this->value, $tmp1);
		$tmp3 = null;
		if($this->sign) {
			$tmp3 = -1;
		} else {
			$tmp3 = 1;
		}
		return $tmp2 * $tmp3;
	}
	public function compareToBig($big) {
		$tmp = thx_bigint_Bigs::compareToAbs($this->value, $big->value);
		$tmp1 = null;
		if($this->sign) {
			$tmp1 = -1;
		} else {
			$tmp1 = 1;
		}
		return $tmp * $tmp1;
	}
	public function compareToAbs($that) {
		$tmp = $that->isSmall;
		if($tmp) {
			return $this->compareToAbsSmall($that);
		} else {
			return $this->compareToAbsBig($that);
		}
	}
	public function compareToAbsSmall($small) {
		$v = $small->value;
		$tmp = null;
		if($v < 0) {
			$tmp = -$v;
		} else {
			$tmp = $v;
		}
		$tmp1 = thx_bigint_Bigs::smallToArray($tmp);
		return thx_bigint_Bigs::compareToAbs($this->value, $tmp1);
	}
	public function compareToAbsBig($big) {
		return thx_bigint_Bigs::compareToAbs($this->value, $big->value);
	}
	public function not() {
		return $this->negate()->prev();
	}
	public function hand($that) {
		return thx_bigint_Bigs::bitwise($this, $that, array(new _hx_lambda(array(), "thx_bigint_Big_0"), 'execute'));
	}
	public function hor($that) {
		return thx_bigint_Bigs::bitwise($this, $that, array(new _hx_lambda(array(), "thx_bigint_Big_1"), 'execute'));
	}
	public function hxor($that) {
		return thx_bigint_Bigs::bitwise($this, $that, array(new _hx_lambda(array(), "thx_bigint_Big_2"), 'execute'));
	}
	public function toFloat() {
		$tmp = $this->toString();
		return Std::parseFloat($tmp);
	}
	public function toInt() {
		$v = thx_bigint_Bigs::arrayToSmall($this->value);
		if(null === $v) {
			throw new HException(new thx_Error("overflow", null, _hx_anonymous(array("fileName" => "Big.hx", "lineNumber" => 274, "className" => "thx.bigint.Big", "methodName" => "toInt"))));
		}
		$tmp = null;
		if($this->sign) {
			$tmp = -1;
		} else {
			$tmp = 1;
		}
		return $tmp * $v;
	}
	public function toString() {
		return $this->toStringWithBase(10);
	}
	public function toStringWithBase($base) {
		$tmp = $this->isZero();
		if($tmp) {
			return "0";
		}
		if($base === 10) {
			$l = $this->value->length;
			$tmp1 = --$l;
			$out = "" . _hx_string_rec($this->value[$tmp1], "");
			$digit = null;
			while(true) {
				$tmp2 = --$l;
				if(!($tmp2 >= 0)) {
					break;
				}
				$digit = "" . _hx_string_rec($this->value[$l], "");
				$tmp3 = _hx_substring("0000000", strlen($digit), null);
				$out .= _hx_string_or_null($tmp3) . _hx_string_or_null($digit);
				unset($tmp3,$tmp2);
			}
			$tmp4 = null;
			if($this->sign) {
				$tmp4 = "-";
			} else {
				$tmp4 = "";
			}
			return _hx_string_or_null($tmp4) . _hx_string_or_null($out);
		}
		$out1 = (new _hx_array(array()));
		$baseBig = new thx_bigint_Small($base);
		$left = $this;
		$divmod = null;
		while(true) {
			$tmp5 = null;
			$tmp6 = !$left->sign;
			if($tmp6) {
				$tmp7 = $left->compareToAbs($baseBig);
				$tmp5 = $tmp7 >= 0;
				unset($tmp7);
			} else {
				$tmp5 = true;
			}
			if(!$tmp5) {
				break;
			}
			$divmod = $left->divMod($baseBig);
			$left = $divmod->quotient;
			$digit1 = $divmod->remainder;
			$tmp8 = $digit1->sign;
			if($tmp8) {
				$digit1 = $baseBig->subtract($digit1)->abs();
				$left = $left->next();
			}
			$tmp9 = $digit1->toStringWithBase($base);
			$out1->push($tmp9);
			unset($tmp9,$tmp8,$tmp6,$tmp5,$digit1);
		}
		$tmp10 = $left->toStringWithBase($base);
		$out1->push($tmp10);
		$out1->reverse();
		$tmp11 = null;
		if($this->sign) {
			$tmp11 = "-";
		} else {
			$tmp11 = "";
		}
		$tmp12 = $out1->join("");
		return _hx_string_or_null($tmp11) . _hx_string_or_null($tmp12);
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return $this->toString(); }
}
function thx_bigint_Big_0($a, $b) {
	{
		return $a & $b;
	}
}
function thx_bigint_Big_1($a, $b) {
	{
		return $a | $b;
	}
}
function thx_bigint_Big_2($a, $b) {
	{
		return $a ^ $b;
	}
}
