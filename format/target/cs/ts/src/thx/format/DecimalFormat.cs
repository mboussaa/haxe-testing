// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx.format {
	public class DecimalFormat : global::haxe.lang.HxObject {
		
		public DecimalFormat(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public DecimalFormat() {
			global::thx.format.DecimalFormat.__hx_ctor_thx_format_DecimalFormat(this);
		}
		
		
		public static void __hx_ctor_thx_format_DecimalFormat(global::thx.format.DecimalFormat __temp_me180) {
		}
		
		
		public static string currency(global::thx.bigint.DecimalImpl @decimal, global::haxe.lang.Null<int> precision, string symbol, global::thx.culture.Culture culture) {
			@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
			global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
			string pattern = ( (((global::thx.bigint.DecimalImpl) (@decimal) ).isNegative()) ? (global::haxe.lang.Runtime.toString(global::thx.culture.Pattern.currencyNegatives[nf.patternNegativeCurrency])) : (global::haxe.lang.Runtime.toString(global::thx.culture.Pattern.currencyPositives[nf.patternPositiveCurrency])) );
			global::haxe.lang.Null<int> t = ( ( ! (precision.hasValue) ) ? (default(global::haxe.lang.Null<int>)) : (precision) );
			string tmp = global::StringTools.replace(pattern, "n", global::thx.format.DecimalFormat.@value(@decimal, ( (t.hasValue) ? ((t).@value) : (nf.decimalDigitsCurrency) ), nf.groupSizesCurrency, nf.separatorGroupCurrency, nf.separatorDecimalCurrency));
			string t1 = ( (string.Equals(null, symbol)) ? (null) : (symbol) );
			return global::StringTools.replace(tmp, "$", ( ( ! (string.Equals(t1, null)) ) ? (t1) : (nf.symbolCurrency) ));
		}
		
		
		public static string customFormat(global::thx.bigint.DecimalImpl @decimal, string pattern, global::thx.culture.Culture culture) {
			unchecked {
				@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
				global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
				bool isCurrency = global::thx.format.DecimalFormat.hasSymbols(pattern, "$");
				bool isPercent = (  ! (isCurrency)  && global::thx.format.DecimalFormat.hasSymbols(pattern, "%\u2030") );
				global::Array<object> groups = global::thx.format.DecimalFormat.splitPattern(pattern, ";");
				if (( groups.length > 3 )) {
					throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("invalid number of sections in \"", pattern), "\""));
				}
				
				if (((global::thx.bigint.DecimalImpl) (@decimal) ).isNegative()) {
					if ( ! (string.Equals(null, global::haxe.lang.Runtime.toString(groups[1]))) ) {
						return global::thx.format.DecimalFormat.customFormatDecimal(((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).negate()) ), global::haxe.lang.Runtime.toString(groups[1]), nf, isCurrency, isPercent);
					}
					else {
						return global::thx.format.DecimalFormat.customFormatDecimal(((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).negate()) ), global::haxe.lang.Runtime.concat("-", global::haxe.lang.Runtime.toString(groups[0])), nf, isCurrency, isPercent);
					}
					
				}
				else if (((global::thx.bigint.DecimalImpl) (@decimal) ).isZero()) {
					string tmp = null;
					if (( null == groups )) {
						tmp = null;
					}
					else {
						string _1 = global::haxe.lang.Runtime.toString(groups[2]);
						if (string.Equals(null, _1)) {
							tmp = null;
						}
						else {
							tmp = _1;
						}
						
					}
					
					string t = ((string) (tmp) );
					return global::thx.format.DecimalFormat.customFormatDecimal(global::thx._Decimal.Decimal_Impl_.fromInt(0), ( ( ! (string.Equals(t, null)) ) ? (t) : (global::haxe.lang.Runtime.toString(groups[0])) ), nf, isCurrency, isPercent);
				}
				else {
					return global::thx.format.DecimalFormat.customFormatDecimal(@decimal, global::haxe.lang.Runtime.toString(groups[0]), nf, isCurrency, isPercent);
				}
				
			}
		}
		
		
		public static string @decimal(global::thx.bigint.DecimalImpl dec, global::haxe.lang.Null<int> significantDigits, global::thx.culture.Culture culture) {
			unchecked {
				global::haxe.lang.Null<int> __temp_significantDigits176 = ( ( ! (significantDigits.hasValue) ) ? (new global::haxe.lang.Null<int>(1, true)) : (significantDigits) );
				dec = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (dec) ).trim(default(global::haxe.lang.Null<int>))) );
				global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
				string formatted = global::thx.format.DecimalFormat.@value(dec, 0, new global::Array<int>(new int[]{0}), "", "");
				return global::haxe.lang.Runtime.concat((( (((global::thx.bigint.DecimalImpl) (dec) ).isNegative()) ? (nf.signNegative) : ("") )), global::StringTools.lpad(formatted, "0", (__temp_significantDigits176).@value));
			}
		}
		
		
		public static string exponential(global::thx.bigint.DecimalImpl @decimal, global::haxe.lang.Null<int> precision, global::haxe.lang.Null<int> digits, string symbol, global::thx.culture.Culture culture) {
			unchecked {
				if (string.Equals(symbol, null)) {
					symbol = "e";
				}
				
				global::haxe.lang.Null<int> __temp_digits178 = ( ( ! (digits.hasValue) ) ? (new global::haxe.lang.Null<int>(3, true)) : (digits) );
				global::haxe.lang.Null<int> __temp_precision177 = ( ( ! (precision.hasValue) ) ? (new global::haxe.lang.Null<int>(6, true)) : (precision) );
				@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
				global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
				object info = global::thx.format.DecimalFormat.exponentialInfo(@decimal);
				string tmp = global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::thx.format.DecimalFormat.number(((global::thx.bigint.DecimalImpl) (global::haxe.lang.Runtime.getField(info, "f", 102, true)) ), __temp_precision177, culture), symbol), (( (( global::haxe.lang.Runtime.compare(((int) (global::haxe.lang.Runtime.getField_f(info, "e", 101, true)) ), 0) < 0 )) ? (nf.signNegative) : (nf.signPositive) )));
				int v = ((int) (global::haxe.lang.Runtime.getField_f(info, "e", 101, true)) );
				return global::haxe.lang.Runtime.concat(tmp, global::StringTools.lpad(global::haxe.lang.Runtime.concat("", global::haxe.lang.Runtime.toString((( (( v < 0 )) ? ( - (v) ) : (v) )))), "0", (__temp_digits178).@value));
			}
		}
		
		
		public static string @fixed(global::thx.bigint.DecimalImpl @decimal, global::haxe.lang.Null<int> precision, global::thx.culture.Culture culture) {
			@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
			global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
			string pattern = ( (((global::thx.bigint.DecimalImpl) (@decimal) ).isNegative()) ? (global::haxe.lang.Runtime.toString(global::thx.culture.Pattern.numberNegatives[nf.patternNegativeNumber])) : ("n") );
			global::haxe.lang.Null<int> t = ( ( ! (precision.hasValue) ) ? (default(global::haxe.lang.Null<int>)) : (precision) );
			return global::StringTools.replace(pattern, "n", global::thx.format.DecimalFormat.@value(@decimal, ( (t.hasValue) ? ((t).@value) : (nf.decimalDigitsNumber) ), new global::Array<int>(new int[]{0}), "", nf.separatorDecimalNumber));
		}
		
		
		public static string format(global::thx.bigint.DecimalImpl @decimal, string pattern, global::thx.culture.Culture culture) {
			unchecked {
				string specifier = global::haxe.lang.StringExt.substring(pattern, 0, new global::haxe.lang.Null<int>(1, true));
				global::haxe.lang.Null<int> param = global::thx.format.DecimalFormat.paramOrNull(global::haxe.lang.StringExt.substring(pattern, 1, default(global::haxe.lang.Null<int>)));
				switch (specifier) {
					case "%":
					{
						return global::thx.format.DecimalFormat.printf(@decimal, pattern, culture);
					}
					
					
					case "C":
					case "c":
					{
						return global::thx.format.DecimalFormat.currency(@decimal, param, null, culture);
					}
					
					
					case "E":
					{
						return global::thx.format.DecimalFormat.exponential(@decimal, param, default(global::haxe.lang.Null<int>), null, culture);
					}
					
					
					case "G":
					{
						return global::thx.format.DecimalFormat.general(@decimal, param, culture);
					}
					
					
					case "P":
					case "p":
					{
						return global::thx.format.DecimalFormat.percent(@decimal, param, culture);
					}
					
					
					case "X":
					{
						return global::thx.format.BigIntFormat.hex(global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal), param, culture).ToUpperInvariant();
					}
					
					
					case "D":
					case "d":
					{
						return global::thx.format.DecimalFormat.@decimal(@decimal, param, culture);
					}
					
					
					case "e":
					{
						return global::thx.format.DecimalFormat.exponential(@decimal, param, default(global::haxe.lang.Null<int>), null, culture).ToLowerInvariant();
					}
					
					
					case "F":
					case "f":
					{
						return global::thx.format.DecimalFormat.@fixed(@decimal, param, culture);
					}
					
					
					case "g":
					{
						return global::thx.format.DecimalFormat.general(@decimal, param, culture).ToLowerInvariant();
					}
					
					
					case "N":
					case "n":
					{
						return global::thx.format.DecimalFormat.number(@decimal, param, culture);
					}
					
					
					case "R":
					case "r":
					{
						return ((global::thx.bigint.DecimalImpl) (@decimal) ).toString();
					}
					
					
					case "x":
					{
						return global::thx.format.BigIntFormat.hex(global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal), param, culture);
					}
					
					
					default:
					{
						return global::thx.format.DecimalFormat.customFormat(@decimal, pattern, culture);
					}
					
				}
				
			}
		}
		
		
		public static string general(global::thx.bigint.DecimalImpl @decimal, global::haxe.lang.Null<int> significantDigits, global::thx.culture.Culture culture) {
			@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
			string e = global::thx.format.DecimalFormat.exponential(@decimal, significantDigits, default(global::haxe.lang.Null<int>), null, culture);
			string f = global::thx.format.DecimalFormat.@fixed(@decimal, significantDigits, culture);
			if (( e.Length < f.Length )) {
				return e;
			}
			else {
				return f;
			}
			
		}
		
		
		public static string integer(global::thx.bigint.DecimalImpl @decimal, global::thx.culture.Culture culture) {
			return global::thx.format.BigIntFormat.integer(global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal), culture);
		}
		
		
		public static string number(global::thx.bigint.DecimalImpl @decimal, global::haxe.lang.Null<int> precision, global::thx.culture.Culture culture) {
			@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
			global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
			string pattern = ( (((global::thx.bigint.DecimalImpl) (@decimal) ).isNegative()) ? (global::haxe.lang.Runtime.toString(global::thx.culture.Pattern.numberNegatives[nf.patternNegativeNumber])) : ("n") );
			global::haxe.lang.Null<int> t = ( ( ! (precision.hasValue) ) ? (default(global::haxe.lang.Null<int>)) : (precision) );
			return global::StringTools.replace(pattern, "n", global::thx.format.DecimalFormat.@value(@decimal, ( (t.hasValue) ? ((t).@value) : (nf.decimalDigitsNumber) ), nf.groupSizesNumber, nf.separatorGroupNumber, nf.separatorDecimalNumber));
		}
		
		
		public static string octal(global::thx.bigint.DecimalImpl @decimal, global::haxe.lang.Null<int> significantDigits, global::thx.culture.Culture culture) {
			unchecked {
				global::haxe.lang.Null<int> __temp_significantDigits179 = ( ( ! (significantDigits.hasValue) ) ? (new global::haxe.lang.Null<int>(1, true)) : (significantDigits) );
				return global::thx.format.BigIntFormat.octal(global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal), default(global::haxe.lang.Null<int>), culture);
			}
		}
		
		
		public static string percent(global::thx.bigint.DecimalImpl @decimal, global::haxe.lang.Null<int> decimals, global::thx.culture.Culture culture) {
			unchecked {
				@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
				global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
				global::thx.bigint.DecimalImpl tmp = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).multiply(global::thx._Decimal.Decimal_Impl_.fromInt(100))) ).trim(default(global::haxe.lang.Null<int>));
				global::haxe.lang.Null<int> t = ( ( ! (decimals.hasValue) ) ? (default(global::haxe.lang.Null<int>)) : (decimals) );
				return global::thx.format.DecimalFormat.unit(tmp, ( (t.hasValue) ? ((t).@value) : (nf.decimalDigitsPercent) ), nf.symbolPercent, culture);
			}
		}
		
		
		public static string permille(global::thx.bigint.DecimalImpl @decimal, global::haxe.lang.Null<int> decimals, global::thx.culture.Culture culture) {
			unchecked {
				@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
				global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
				global::thx.bigint.DecimalImpl tmp = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).multiply(global::thx._Decimal.Decimal_Impl_.fromInt(1000))) ).trim(default(global::haxe.lang.Null<int>));
				global::haxe.lang.Null<int> t = ( ( ! (decimals.hasValue) ) ? (default(global::haxe.lang.Null<int>)) : (decimals) );
				return global::thx.format.DecimalFormat.unit(tmp, ( (t.hasValue) ? ((t).@value) : (nf.decimalDigitsPercent) ), nf.symbolPermille, culture);
			}
		}
		
		
		public static string printf(global::thx.bigint.DecimalImpl @decimal, string pattern, global::thx.culture.Culture culture) {
			unchecked {
				if ( ! (pattern.StartsWith("%")) ) {
					throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("invalid printf term \"", pattern), "\""));
				}
				
				@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
				string specifier = global::haxe.lang.StringExt.substring(pattern, ( pattern.Length - 1 ), default(global::haxe.lang.Null<int>));
				global::Array<object> p = global::haxe.lang.StringExt.split(global::haxe.lang.StringExt.substring(pattern, 1, new global::haxe.lang.Null<int>(( pattern.Length - 1 ), true)), ".");
				global::haxe.lang.Null<int> precision = ( (( string.Equals(null, global::haxe.lang.Runtime.toString(p[1])) || string.Equals("", global::haxe.lang.Runtime.toString(p[1])) )) ? (default(global::haxe.lang.Null<int>)) : (global::Std.parseInt(global::haxe.lang.Runtime.toString(p[1]))) );
				bool justifyRight = true;
				bool negativeSignOnly = true;
				bool emptySpaceForSign = false;
				bool prefix = false;
				string padding = " ";
				int width = 0;
				string flags = global::haxe.lang.Runtime.toString(p[0]);
				while (( flags.Length > 0 )) {
					{
						string _g = global::haxe.lang.StringExt.substring(flags, 0, new global::haxe.lang.Null<int>(1, true));
						switch (_g) {
							case " ":
							{
								emptySpaceForSign = true;
								break;
							}
							
							
							case "#":
							{
								prefix = true;
								break;
							}
							
							
							case "+":
							{
								negativeSignOnly = false;
								break;
							}
							
							
							case "-":
							{
								justifyRight = false;
								break;
							}
							
							
							case "0":
							{
								padding = "0";
								break;
							}
							
							
							default:
							{
								if (global::thx.Ints.canParse(_g)) {
									width = (global::thx.Ints.parse(flags, default(global::haxe.lang.Null<int>))).@value;
									flags = "";
									continue;
								}
								else {
									throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat("invalid flags ", flags));
								}
								
							}
							
						}
						
					}
					
					flags = global::haxe.lang.StringExt.substring(flags, 1, default(global::haxe.lang.Null<int>));
				}
				
				global::haxe.lang.Function decorate = new global::thx.format.DecimalFormat_printf_302__Fun(width, prefix, padding, negativeSignOnly, justifyRight, emptySpaceForSign);
				global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
				switch (specifier) {
					case "%":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), "%", default(double), global::thx._Decimal.Decimal_Impl_.fromInt(1), default(double), "", default(double), "", default(double), ""));
					}
					
					
					case "B":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), ((global::thx.bigint.BigIntImpl) (global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal)) ).toStringWithBase(2), default(double), global::thx._Decimal.Decimal_Impl_.fromInt(1), default(double), "B", default(double), "", default(double), ""));
					}
					
					
					case "E":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), global::thx.format.DecimalFormat.exponential(((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).abs()) ), precision, new global::haxe.lang.Null<int>(0, true), "E", culture), default(double), @decimal, default(double), "", default(double), nf.signNegative, default(double), nf.signPositive));
					}
					
					
					case "G":
					{
						string e = global::thx.format.DecimalFormat.printf(@decimal, "E", culture);
						string f = global::thx.format.DecimalFormat.printf(@decimal, "f", culture);
						if (( e.Length < f.Length )) {
							return e;
						}
						else {
							return f;
						}
						
					}
					
					
					case "X":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), global::thx.format.BigIntFormat.hex(((global::thx.bigint.BigIntImpl) (global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal)) ).abs(), precision, culture), default(double), @decimal, default(double), "0X", default(double), nf.signNegative, default(double), nf.signPositive));
					}
					
					
					case "b":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), ((global::thx.bigint.BigIntImpl) (global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal)) ).toStringWithBase(2), default(double), global::thx._Decimal.Decimal_Impl_.fromInt(1), default(double), "b", default(double), "", default(double), ""));
					}
					
					
					case "c":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), new string(((char) (((global::thx.bigint.DecimalImpl) (@decimal) ).toInt()) ), 1), default(double), global::thx._Decimal.Decimal_Impl_.fromInt(1), default(double), "", default(double), "", default(double), ""));
					}
					
					
					case "d":
					case "i":
					{
						string tmp = ((global::thx.bigint.BigIntImpl) (global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal)) ).toString();
						global::haxe.lang.Null<int> _0 = precision;
						global::haxe.lang.Null<int> t = ( ( ! (_0.hasValue) ) ? (default(global::haxe.lang.Null<int>)) : (_0) );
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), global::StringTools.lpad(tmp, "0", ( (t.hasValue) ? ((t).@value) : (0) )), default(double), @decimal, default(double), "", default(double), nf.signNegative, default(double), nf.signPositive));
					}
					
					
					case "e":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), global::thx.format.DecimalFormat.exponential(((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).abs()) ), precision, new global::haxe.lang.Null<int>(0, true), "e", culture), default(double), @decimal, default(double), "", default(double), nf.signNegative, default(double), nf.signPositive));
					}
					
					
					case "f":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), global::thx.format.DecimalFormat.@fixed(((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).abs()) ), precision, culture), default(double), @decimal, default(double), "", default(double), nf.signNegative, default(double), nf.signPositive));
					}
					
					
					case "g":
					{
						string e1 = global::thx.format.DecimalFormat.printf(@decimal, "e", culture);
						string f1 = global::thx.format.DecimalFormat.printf(@decimal, "f", culture);
						if (( e1.Length < f1.Length )) {
							return e1;
						}
						else {
							return f1;
						}
						
					}
					
					
					case "o":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), global::thx.format.BigIntFormat.octal(((global::thx.bigint.BigIntImpl) (global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal)) ).abs(), precision, culture), default(double), @decimal, default(double), "0", default(double), nf.signNegative, default(double), nf.signPositive));
					}
					
					
					case "u":
					{
						return global::thx.format.DecimalFormat.printf(((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).abs()) ), "d", culture);
					}
					
					
					case "x":
					{
						return global::haxe.lang.Runtime.toString(decorate.__hx_invoke5_o(default(double), global::thx.format.BigIntFormat.hex(((global::thx.bigint.BigIntImpl) (global::thx._Decimal.Decimal_Impl_.toBigInt(@decimal)) ).abs(), precision, culture), default(double), @decimal, default(double), "0x", default(double), nf.signNegative, default(double), nf.signPositive));
					}
					
					
					default:
					{
						throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("invalid pattern \"", pattern), "\""));
					}
					
				}
				
			}
		}
		
		
		public static string toBase(global::thx.bigint.DecimalImpl @value, int @base, global::thx.culture.Culture culture) {
			return global::thx.format.BigIntFormat.toBase(global::thx._Decimal.Decimal_Impl_.toBigInt(@value), @base, culture);
		}
		
		
		public static string unit(global::thx.bigint.DecimalImpl @decimal, int decimals, string unitSymbol, global::thx.culture.Culture culture) {
			@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).trim(default(global::haxe.lang.Null<int>))) );
			global::thx.culture.NumberFormatInfo nf = global::thx.format.DecimalFormat.numberFormat(culture);
			return global::StringTools.replace(global::StringTools.replace(( (((global::thx.bigint.DecimalImpl) (@decimal) ).isNegative()) ? (global::haxe.lang.Runtime.toString(global::thx.culture.Pattern.percentNegatives[nf.patternNegativePercent])) : (global::haxe.lang.Runtime.toString(global::thx.culture.Pattern.percentPositives[nf.patternPositivePercent])) ), "n", global::thx.format.DecimalFormat.@value(@decimal, decimals, nf.groupSizesPercent, nf.separatorGroupPercent, nf.separatorDecimalPercent)), "%", unitSymbol);
		}
		
		
		public static object exponentialInfo(global::thx.bigint.DecimalImpl @decimal) {
			unchecked {
				global::Array<object> p = global::haxe.lang.StringExt.split(((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).abs()) ).toString(), ".").concat(new global::Array<object>(new object[]{""}));
				int e = 0;
				if (( global::haxe.lang.Runtime.toString(p[0]).Length > 1 )) {
					e = ( global::haxe.lang.Runtime.toString(p[0]).Length - 1 );
					p[1] = global::haxe.lang.Runtime.concat(global::haxe.lang.StringExt.substring(global::haxe.lang.Runtime.toString(p[0]), 1, default(global::haxe.lang.Null<int>)), global::haxe.lang.Runtime.toString(p[1]));
					p[0] = global::haxe.lang.StringExt.substring(global::haxe.lang.Runtime.toString(p[0]), 0, new global::haxe.lang.Null<int>(1, true));
				}
				else if (string.Equals(global::haxe.lang.Runtime.toString(p[0]), "0")) {
					e =  - ((( ( 1 + global::haxe.lang.Runtime.toString(p[1]).Length ) - global::thx.Strings.trimCharsLeft(global::haxe.lang.Runtime.toString(p[1]), "0").Length ))) ;
					p[1] = global::haxe.lang.StringExt.substring(global::haxe.lang.Runtime.toString(p[1]), (  - (e)  - 1 ), default(global::haxe.lang.Null<int>));
					p[0] = global::haxe.lang.StringExt.substring(global::haxe.lang.Runtime.toString(p[1]), 0, new global::haxe.lang.Null<int>(1, true));
					p[1] = global::haxe.lang.StringExt.substring(global::haxe.lang.Runtime.toString(p[1]), 1, default(global::haxe.lang.Null<int>));
				}
				
				{
					global::thx.bigint.DecimalImpl __temp_odecl1 = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (global::thx.bigint.Decimals.parse(p.slice(0, new global::haxe.lang.Null<int>(2, true)).@join("."))) ).multiply(global::thx._Decimal.Decimal_Impl_.fromInt(( (((global::thx.bigint.DecimalImpl) (@decimal) ).isNegative()) ? (-1) : (1) )))) ).trim(default(global::haxe.lang.Null<int>));
					return new global::haxe.lang.DynamicObject(new int[]{102}, new object[]{__temp_odecl1}, new int[]{101}, new double[]{((double) (e) )});
				}
				
			}
		}
		
		
		public static string customFormatDecimalFraction(string d, string pattern, global::thx.culture.NumberFormatInfo nf) {
			unchecked {
				string buf = "";
				int i = 0;
				int quote = 0;
				global::Array<object> p = global::haxe.lang.StringExt.split(d, "");
				while (( i < pattern.Length )) {
					{
						string _g = global::haxe.lang.StringExt.substring(pattern, i, new global::haxe.lang.Null<int>(( i + 1 ), true));
						switch (_g) {
							case "\"":
							{
								switch (quote) {
									case 0:
									{
										quote = 2;
										break;
									}
									
									
									case 1:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
									
									case 2:
									{
										quote = 0;
										break;
									}
									
									
									default:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
								}
								
								break;
							}
							
							
							case "#":
							{
								switch (quote) {
									case 0:
									{
										buf = global::haxe.lang.Runtime.concat(buf, ( (( p.length == 0 )) ? ("") : (global::haxe.lang.Runtime.toString((p.shift()).toDynamic())) ));
										break;
									}
									
									
									case 1:
									case 2:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
									
									default:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
								}
								
								break;
							}
							
							
							case "$":
							{
								switch (quote) {
									case 0:
									{
										buf = global::haxe.lang.Runtime.concat(buf, nf.symbolCurrency);
										break;
									}
									
									
									case 1:
									case 2:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
									
									default:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
								}
								
								break;
							}
							
							
							case "%":
							{
								switch (quote) {
									case 0:
									{
										buf = global::haxe.lang.Runtime.concat(buf, nf.symbolPercent);
										break;
									}
									
									
									case 1:
									case 2:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
									
									default:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\'":
							{
								switch (quote) {
									case 0:
									{
										quote = 1;
										break;
									}
									
									
									case 1:
									{
										quote = 0;
										break;
									}
									
									
									case 2:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
									
									default:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
								}
								
								break;
							}
							
							
							case "0":
							{
								switch (quote) {
									case 0:
									{
										buf = global::haxe.lang.Runtime.concat(buf, ( (( p.length == 0 )) ? ("0") : (global::haxe.lang.Runtime.toString((p.shift()).toDynamic())) ));
										break;
									}
									
									
									case 1:
									case 2:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
									
									default:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\\":
							{
								 ++ i;
								buf = global::haxe.lang.Runtime.concat(buf, global::haxe.lang.StringExt.substring(pattern, i, new global::haxe.lang.Null<int>(( i + 1 ), true)));
								break;
							}
							
							
							case "\u2030":
							{
								switch (quote) {
									case 0:
									{
										buf = global::haxe.lang.Runtime.concat(buf, nf.symbolPermille);
										break;
									}
									
									
									case 1:
									case 2:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
									
									default:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
								}
								
								break;
							}
							
							
							default:
							{
								switch (quote) {
									case 1:
									case 2:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
									
									default:
									{
										buf = global::haxe.lang.Runtime.concat(buf, _g);
										break;
									}
									
								}
								
								break;
							}
							
						}
						
					}
					
					 ++ i;
				}
				
				return buf;
			}
		}
		
		
		public static string customFormatDecimal(global::thx.bigint.DecimalImpl @decimal, string pattern, global::thx.culture.NumberFormatInfo nf, bool isCurrency, bool isPercent) {
			unchecked {
				if (isPercent) {
					@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).multiply(global::thx._Decimal.Decimal_Impl_.fromInt(( (global::thx.format.DecimalFormat.hasSymbols(pattern, "\u2030")) ? (1000) : (100) )))) ).trim(default(global::haxe.lang.Null<int>));
				}
				
				global::Array<object> exp = global::thx.format.DecimalFormat.splitPattern(pattern, "eE");
				if (( exp.length > 1 )) {
					object info = global::thx.format.DecimalFormat.exponentialInfo(@decimal);
					string symbol = global::haxe.lang.StringExt.substring(pattern, global::haxe.lang.Runtime.toString(exp[0]).Length, new global::haxe.lang.Null<int>(( global::haxe.lang.Runtime.toString(exp[0]).Length + 1 ), true));
					bool forceSign = global::haxe.lang.Runtime.toString(exp[1]).StartsWith("+");
					if (( forceSign || global::haxe.lang.Runtime.toString(exp[1]).StartsWith("-") )) {
						exp[1] = global::haxe.lang.StringExt.substring(global::haxe.lang.Runtime.toString(exp[1]), 1, default(global::haxe.lang.Null<int>));
					}
					
					return global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::thx.format.DecimalFormat.customIntegerAndFraction(((global::thx.bigint.DecimalImpl) (global::haxe.lang.Runtime.getField(info, "f", 102, true)) ), global::haxe.lang.Runtime.toString(exp[0]), nf, isCurrency, isPercent), symbol), (( (( global::haxe.lang.Runtime.compare(((int) (global::haxe.lang.Runtime.getField_f(info, "e", 101, true)) ), 0) < 0 )) ? (nf.signNegative) : (( (forceSign) ? (nf.signPositive) : ("") )) ))), global::thx.format.DecimalFormat.customFormatInteger(global::haxe.lang.Runtime.concat("", global::haxe.lang.Runtime.toString(global::System.Math.Abs(((double) (((int) (global::haxe.lang.Runtime.getField_f(info, "e", 101, true)) )) )))), global::haxe.lang.Runtime.toString(exp[1]), nf, isCurrency, isPercent));
				}
				else {
					return global::thx.format.DecimalFormat.customIntegerAndFraction(@decimal, pattern, nf, isCurrency, isPercent);
				}
				
			}
		}
		
		
		public static string customFormatInteger(string v, string pattern, global::thx.culture.NumberFormatInfo nf, bool isCurrency, bool isPercent) {
			unchecked {
				global::Array<object> buf = new global::Array<object>(new object[]{});
				int i = 0;
				int quote = 0;
				global::Array<object> p = global::haxe.lang.StringExt.split(v, "");
				string lbuf = "";
				bool first = true;
				bool useGroups = false;
				int zeroes = 0;
				while (( i < pattern.Length )) {
					{
						string _g = global::haxe.lang.StringExt.substring(pattern, i, new global::haxe.lang.Null<int>(( i + 1 ), true));
						switch (_g) {
							case "\"":
							{
								switch (quote) {
									case 0:
									{
										quote = 2;
										break;
									}
									
									
									case 1:
									{
										lbuf = global::haxe.lang.Runtime.concat(lbuf, _g);
										break;
									}
									
									
									case 2:
									{
										quote = 0;
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(lbuf));
										lbuf = "";
										break;
									}
									
									
									default:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(_g));
										break;
									}
									
								}
								
								break;
							}
							
							
							case "#":
							{
								switch (quote) {
									case 0:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Hash(first));
										first = false;
										break;
									}
									
									
									case 1:
									case 2:
									{
										lbuf = global::haxe.lang.Runtime.concat(lbuf, _g);
										break;
									}
									
									
									default:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(_g));
										break;
									}
									
								}
								
								break;
							}
							
							
							case "$":
							{
								switch (quote) {
									case 0:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(nf.symbolCurrency));
										break;
									}
									
									
									case 1:
									case 2:
									{
										lbuf = global::haxe.lang.Runtime.concat(lbuf, _g);
										break;
									}
									
									
									default:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(_g));
										break;
									}
									
								}
								
								break;
							}
							
							
							case "%":
							{
								switch (quote) {
									case 0:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(nf.symbolPercent));
										break;
									}
									
									
									case 1:
									case 2:
									{
										lbuf = global::haxe.lang.Runtime.concat(lbuf, _g);
										break;
									}
									
									
									default:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(_g));
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\'":
							{
								switch (quote) {
									case 0:
									{
										quote = 1;
										break;
									}
									
									
									case 1:
									{
										quote = 0;
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(lbuf));
										lbuf = "";
										break;
									}
									
									
									case 2:
									{
										lbuf = global::haxe.lang.Runtime.concat(lbuf, _g);
										break;
									}
									
									
									default:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(_g));
										break;
									}
									
								}
								
								break;
							}
							
							
							case ",":
							{
								switch (quote) {
									case 0:
									{
										useGroups = true;
										break;
									}
									
									
									case 1:
									case 2:
									{
										lbuf = global::haxe.lang.Runtime.concat(lbuf, _g);
										break;
									}
									
									
									default:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(_g));
										break;
									}
									
								}
								
								break;
							}
							
							
							case "0":
							{
								switch (quote) {
									case 0:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Zero(first));
										first = false;
										 ++ zeroes;
										break;
									}
									
									
									case 1:
									case 2:
									{
										lbuf = global::haxe.lang.Runtime.concat(lbuf, _g);
										break;
									}
									
									
									default:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(_g));
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\\":
							{
								 ++ i;
								buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(global::haxe.lang.StringExt.substring(pattern, i, new global::haxe.lang.Null<int>(( i + 1 ), true))));
								break;
							}
							
							
							case "\u2030":
							{
								switch (quote) {
									case 0:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(nf.symbolPermille));
										break;
									}
									
									
									case 1:
									case 2:
									{
										lbuf = global::haxe.lang.Runtime.concat(lbuf, _g);
										break;
									}
									
									
									default:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(_g));
										break;
									}
									
								}
								
								break;
							}
							
							
							default:
							{
								switch (quote) {
									case 1:
									case 2:
									{
										lbuf = global::haxe.lang.Runtime.concat(lbuf, _g);
										break;
									}
									
									
									default:
									{
										buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(_g));
										break;
									}
									
								}
								
								break;
							}
							
						}
						
					}
					
					 ++ i;
				}
				
				if (( lbuf.Length > 0 )) {
					buf.push(global::thx.format._DecimalFormat.CustomFormat.Literal(lbuf));
				}
				
				{
					int _g1 = p.length;
					int _g2 = zeroes;
					while (( _g1 < _g2 )) {
						 ++ _g1;
						p.unshift("0");
					}
					
				}
				
				if (useGroups) {
					i = ( p.length - 1 );
					global::Array<int> groups = ( (isCurrency) ? (nf.groupSizesCurrency.copy()) : (( (isPercent) ? (nf.groupSizesPercent.copy()) : (nf.groupSizesNumber.copy()) )) );
					global::haxe.lang.Null<int> @group = groups.shift();
					int pos = 0;
					while (( i >= 0 )) {
						if (global::haxe.lang.Runtime.eq((@group).toDynamic(), 0)) {
							break;
						}
						
						if (global::haxe.lang.Runtime.eq(pos, (@group).toDynamic())) {
							p[i] = global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.toString(p[i]), (( (isCurrency) ? (nf.separatorGroupCurrency) : (( (isPercent) ? (nf.separatorGroupPercent) : (nf.separatorGroupNumber) )) )));
							pos = 0;
							if (( groups.length > 0 )) {
								@group = groups.shift();
							}
							
						}
						else {
							 ++ pos;
							 -- i;
						}
						
					}
					
				}
				
				buf.reverse();
				global::Array<object> r = buf.map<object>(((global::haxe.lang.Function) (new global::thx.format.DecimalFormat_customFormatInteger_526__Fun(p)) ));
				r.reverse();
				return r.@join("");
			}
		}
		
		
		public static string customIntegerAndFraction(global::thx.bigint.DecimalImpl @decimal, string pattern, global::thx.culture.NumberFormatInfo nf, bool isCurrency, bool isPercent) {
			unchecked {
				global::Array<object> p = global::thx.format.DecimalFormat.splitPattern(pattern, ".");
				@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).divide(global::thx.bigint.Decimals.fromFloat(global::System.Math.Pow(((double) (1000) ), ((double) (( global::haxe.lang.Runtime.toString(p[0]).Length - (global::haxe.lang.Runtime.toString(p[0] = global::thx.Strings.trimCharsRight(global::haxe.lang.Runtime.toString(p[0]), ","))).Length )) ))))) ).trim(default(global::haxe.lang.Null<int>));
				if (( p.length == 1 )) {
					return global::thx.format.DecimalFormat.customFormatInteger(((global::thx.bigint.BigIntImpl) (global::thx._Decimal.Decimal_Impl_.toBigInt(((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).roundTo(0)) ))) ).toString(), global::haxe.lang.Runtime.toString(p[0]), nf, isCurrency, isPercent);
				}
				else {
					@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).roundTo(global::thx.format.DecimalFormat.countSymbols(global::haxe.lang.Runtime.toString(p[1]), "#0"))) ).trim(default(global::haxe.lang.Null<int>));
					global::Array<object> np = global::thx.format.DecimalFormat.splitOnDecimalSeparator(@decimal);
					string tmp = global::haxe.lang.Runtime.concat(global::thx.format.DecimalFormat.customFormatInteger(global::haxe.lang.Runtime.toString(np[0]), global::haxe.lang.Runtime.toString(p[0]), nf, isCurrency, isPercent), (( (isCurrency) ? (nf.separatorDecimalCurrency) : (( (isPercent) ? (nf.separatorDecimalPercent) : (nf.separatorDecimalNumber) )) )));
					string tmp1 = null;
					if (( null == np )) {
						tmp1 = null;
					}
					else {
						string _1 = global::haxe.lang.Runtime.toString(np[1]);
						if (string.Equals(null, _1)) {
							tmp1 = null;
						}
						else {
							tmp1 = _1;
						}
						
					}
					
					string t = ((string) (tmp1) );
					return global::haxe.lang.Runtime.concat(tmp, global::thx.format.DecimalFormat.customFormatDecimalFraction(( ( ! (string.Equals(t, null)) ) ? (t) : ("0") ), global::haxe.lang.Runtime.toString(p[1]), nf));
				}
				
			}
		}
		
		
		public static bool hasSymbols(string pattern, string symbols) {
			unchecked {
				int i = 0;
				int quote = 0;
				while (( i < pattern.Length )) {
					{
						string _g = global::haxe.lang.StringExt.substring(pattern, i, new global::haxe.lang.Null<int>(( i + 1 ), true));
						switch (_g) {
							case "\"":
							{
								switch (quote) {
									case 0:
									{
										quote = 2;
										break;
									}
									
									
									case 2:
									{
										quote = 0;
										break;
									}
									
									
									default:
									{
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\'":
							{
								switch (quote) {
									case 0:
									{
										quote = 1;
										break;
									}
									
									
									case 1:
									{
										quote = 0;
										break;
									}
									
									
									default:
									{
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\\":
							{
								 ++ i;
								break;
							}
							
							
							default:
							{
								if (( quote == 0 )) {
									if (( global::haxe.lang.StringExt.indexOf(symbols, _g, default(global::haxe.lang.Null<int>)) >= 0 )) {
										return true;
									}
									
								}
								
								break;
							}
							
						}
						
					}
					
					 ++ i;
				}
				
				return false;
			}
		}
		
		
		public static string intPart(string s, global::Array<int> groupSizes, string groupSeparator) {
			global::Array<object> buf = new global::Array<object>(new object[]{});
			global::Array<int> sizes = groupSizes.copy();
			global::haxe.lang.Null<int> size = sizes.shift();
			while (( s.Length > 0 )) {
				if (global::haxe.lang.Runtime.eq((size).toDynamic(), 0)) {
					buf.unshift(s);
					s = "";
				}
				else if (( s.Length > (size).@value )) {
					buf.unshift(global::haxe.lang.StringExt.substring(s, ( s.Length - (size).@value ), default(global::haxe.lang.Null<int>)));
					s = global::haxe.lang.StringExt.substring(s, 0, new global::haxe.lang.Null<int>(( s.Length - (size).@value ), true));
					if (( sizes.length > 0 )) {
						size = sizes.shift();
					}
					
				}
				else {
					buf.unshift(s);
					s = "";
				}
				
			}
			
			return buf.@join(groupSeparator);
		}
		
		
		public static global::thx.culture.NumberFormatInfo numberFormat(global::thx.culture.Culture culture) {
			if (( ( null != culture ) && ( null != culture.number ) )) {
				return culture.number;
			}
			else {
				return global::thx.format.Format.get_defaultCulture().number;
			}
			
		}
		
		
		public static string pad(string s, int len, bool round) {
			unchecked {
				string _0 = s;
				string t = ((string) (( (string.Equals(null, _0)) ? (null) : (_0) )) );
				if ( ! (string.Equals(t, null)) ) {
					s = t;
				}
				else {
					s = "";
				}
				
				if (( ( len > 0 ) && ( s.Length > len ) )) {
					if (round) {
						return global::haxe.lang.Runtime.concat(global::haxe.lang.StringExt.substring(s, 0, new global::haxe.lang.Null<int>(( len - 1 ), true)), global::haxe.lang.Runtime.toString((( (global::Std.parseInt(global::haxe.lang.StringExt.substring(s, ( len - 1 ), new global::haxe.lang.Null<int>(len, true)))).@value + (( (( (global::Std.parseInt(global::haxe.lang.StringExt.substring(s, len, new global::haxe.lang.Null<int>(( len + 1 ), true)))).@value >= 5 )) ? (1) : (0) )) ))));
					}
					else {
						return global::haxe.lang.StringExt.substring(s, 0, new global::haxe.lang.Null<int>(len, true));
					}
					
				}
				else {
					return global::StringTools.rpad(s, "0", len);
				}
				
			}
		}
		
		
		public static global::haxe.lang.Null<int> paramOrNull(string param) {
			if (( param.Length == 0 )) {
				return default(global::haxe.lang.Null<int>);
			}
			else {
				return global::Std.parseInt(param);
			}
			
		}
		
		
		public static global::Array<object> splitOnDecimalSeparator(global::thx.bigint.DecimalImpl @decimal) {
			return global::haxe.lang.StringExt.split(((global::thx.bigint.DecimalImpl) (@decimal) ).toString(), ".");
		}
		
		
		public static global::Array<object> splitPattern(string pattern, string separator) {
			unchecked {
				global::Array<int> pos = new global::Array<int>(new int[]{});
				int i = 0;
				int quote = 0;
				while (( i < pattern.Length )) {
					{
						string _g = global::haxe.lang.StringExt.substring(pattern, i, new global::haxe.lang.Null<int>(( i + 1 ), true));
						switch (_g) {
							case "\"":
							{
								switch (quote) {
									case 0:
									{
										quote = 2;
										break;
									}
									
									
									case 2:
									{
										quote = 0;
										break;
									}
									
									
									default:
									{
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\'":
							{
								switch (quote) {
									case 0:
									{
										quote = 1;
										break;
									}
									
									
									case 1:
									{
										quote = 0;
										break;
									}
									
									
									default:
									{
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\\":
							{
								 ++ i;
								break;
							}
							
							
							default:
							{
								if (( quote == 0 )) {
									if (( global::haxe.lang.StringExt.indexOf(separator, _g, default(global::haxe.lang.Null<int>)) >= 0 )) {
										pos.push(i);
									}
									
								}
								
								break;
							}
							
						}
						
					}
					
					 ++ i;
				}
				
				global::Array<object> buf = new global::Array<object>(new object[]{});
				int prev = 0;
				{
					int _g1 = 0;
					while (( _g1 < pos.length )) {
						int p = pos[_g1];
						 ++ _g1;
						buf.push(global::haxe.lang.StringExt.substring(pattern, prev, new global::haxe.lang.Null<int>(p, true)));
						prev = ( p + 1 );
					}
					
				}
				
				buf.push(global::haxe.lang.StringExt.substring(pattern, prev, default(global::haxe.lang.Null<int>)));
				return buf;
			}
		}
		
		
		public static string @value(global::thx.bigint.DecimalImpl @decimal, int precision, global::Array<int> groupSizes, string groupSeparator, string decimalSeparator) {
			unchecked {
				@decimal = ((global::thx.bigint.DecimalImpl) (((global::thx.bigint.DecimalImpl) (@decimal) ).abs()) );
				global::Array<object> p = global::thx.format.DecimalFormat.splitOnDecimalSeparator(@decimal);
				if (( ( precision <= 0 ) &&  ! (string.Equals(null, global::haxe.lang.Runtime.toString(p[1])))  )) {
					if (( global::Std.parseFloat(global::haxe.lang.Runtime.concat("0.", global::haxe.lang.Runtime.toString(p[1]))) >= 0.5 )) {
						p[0] = global::haxe.lang.Runtime.concat(global::haxe.lang.StringExt.substring(global::haxe.lang.Runtime.toString(p[0]), 0, new global::haxe.lang.Null<int>(( global::haxe.lang.Runtime.toString(p[0]).Length - 1 ), true)), global::haxe.lang.Runtime.toString((( global::Std.parseFloat(global::haxe.lang.StringExt.substring(global::haxe.lang.Runtime.toString(p[0]), ( global::haxe.lang.Runtime.toString(p[0]).Length - 1 ), default(global::haxe.lang.Null<int>))) + 1 ))));
					}
					
				}
				
				global::Array<object> buf = new global::Array<object>(new object[]{});
				buf.push(global::thx.format.DecimalFormat.intPart(global::haxe.lang.Runtime.toString(p[0]), groupSizes, groupSeparator));
				if (( precision > 0 )) {
					buf.push(global::thx.format.DecimalFormat.pad(global::haxe.lang.Runtime.toString(p[1]), precision, true));
				}
				
				return buf.@join(decimalSeparator);
			}
		}
		
		
		public static int countSymbols(string pattern, string symbols) {
			unchecked {
				int i = 0;
				int quote = 0;
				int count = 0;
				while (( i < pattern.Length )) {
					{
						string _g = global::haxe.lang.StringExt.substring(pattern, i, new global::haxe.lang.Null<int>(( i + 1 ), true));
						switch (_g) {
							case "\"":
							{
								switch (quote) {
									case 0:
									{
										quote = 2;
										break;
									}
									
									
									case 2:
									{
										quote = 0;
										break;
									}
									
									
									default:
									{
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\'":
							{
								switch (quote) {
									case 0:
									{
										quote = 1;
										break;
									}
									
									
									case 1:
									{
										quote = 0;
										break;
									}
									
									
									default:
									{
										break;
									}
									
								}
								
								break;
							}
							
							
							case "\\":
							{
								 ++ i;
								break;
							}
							
							
							default:
							{
								if (( quote == 0 )) {
									if (( global::haxe.lang.StringExt.indexOf(symbols, _g, default(global::haxe.lang.Null<int>)) >= 0 )) {
										 ++ count;
									}
									
								}
								
								break;
							}
							
						}
						
					}
					
					 ++ i;
				}
				
				return count;
			}
		}
		
		
		public static new object __hx_createEmpty() {
			return new global::thx.format.DecimalFormat(global::haxe.lang.EmptyObject.EMPTY);
		}
		
		
		public static new object __hx_create(global::Array arr) {
			return new global::thx.format.DecimalFormat();
		}
		
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx.format {
	public class DecimalFormat_printf_302__Fun : global::haxe.lang.Function {
		
		public DecimalFormat_printf_302__Fun(int width, bool prefix, string padding, bool negativeSignOnly, bool justifyRight, bool emptySpaceForSign) : base(5, 0) {
			this.width = width;
			this.prefix = prefix;
			this.padding = padding;
			this.negativeSignOnly = negativeSignOnly;
			this.justifyRight = justifyRight;
			this.emptySpaceForSign = emptySpaceForSign;
		}
		
		
		public override object __hx_invoke5_o(double __fn_float1, object __fn_dyn1, double __fn_float2, object __fn_dyn2, double __fn_float3, object __fn_dyn3, double __fn_float4, object __fn_dyn4, double __fn_float5, object __fn_dyn5) {
			string ps = ( (( __fn_dyn5 == global::haxe.lang.Runtime.undefined )) ? (global::haxe.lang.Runtime.toString(__fn_float5)) : (global::haxe.lang.Runtime.toString(__fn_dyn5)) );
			string ns = ( (( __fn_dyn4 == global::haxe.lang.Runtime.undefined )) ? (global::haxe.lang.Runtime.toString(__fn_float4)) : (global::haxe.lang.Runtime.toString(__fn_dyn4)) );
			string p1 = ( (( __fn_dyn3 == global::haxe.lang.Runtime.undefined )) ? (global::haxe.lang.Runtime.toString(__fn_float3)) : (global::haxe.lang.Runtime.toString(__fn_dyn3)) );
			global::thx.bigint.DecimalImpl decimal1 = ( (( __fn_dyn2 == global::haxe.lang.Runtime.undefined )) ? (((global::thx.bigint.DecimalImpl) (((object) (__fn_float2) )) )) : (((global::thx.bigint.DecimalImpl) (__fn_dyn2) )) );
			string s = ( (( __fn_dyn1 == global::haxe.lang.Runtime.undefined )) ? (global::haxe.lang.Runtime.toString(__fn_float1)) : (global::haxe.lang.Runtime.toString(__fn_dyn1)) );
			if (this.prefix) {
				s = global::haxe.lang.Runtime.concat(p1, s);
			}
			
			if (((global::thx.bigint.DecimalImpl) (decimal1) ).isNegative()) {
				s = global::haxe.lang.Runtime.concat(ns, s);
			}
			else if ( ! (this.negativeSignOnly) ) {
				s = global::haxe.lang.Runtime.concat(ps, s);
			}
			else if (this.emptySpaceForSign) {
				s = global::haxe.lang.Runtime.concat(" ", s);
			}
			
			if (this.justifyRight) {
				return global::StringTools.lpad(s, this.padding, this.width);
			}
			else {
				return global::StringTools.rpad(s, this.padding, this.width);
			}
			
		}
		
		
		public int width;
		
		public bool prefix;
		
		public string padding;
		
		public bool negativeSignOnly;
		
		public bool justifyRight;
		
		public bool emptySpaceForSign;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx.format {
	public class DecimalFormat_customFormatInteger_526__Fun : global::haxe.lang.Function {
		
		public DecimalFormat_customFormatInteger_526__Fun(global::Array<object> p) : base(1, 0) {
			this.p = p;
		}
		
		
		public override object __hx_invoke1_o(double __fn_float1, object __fn_dyn1) {
			unchecked {
				global::thx.format._DecimalFormat.CustomFormat _ = ( (( __fn_dyn1 == global::haxe.lang.Runtime.undefined )) ? (((global::thx.format._DecimalFormat.CustomFormat) (((object) (__fn_float1) )) )) : (( (( __fn_dyn1 == null )) ? (null) : (((global::thx.format._DecimalFormat.CustomFormat) (__fn_dyn1) )) )) );
				switch (_.index) {
					case 0:
					{
						return global::haxe.lang.Runtime.toString(_.@params[0]);
					}
					
					
					case 1:
					{
						bool first1 = global::haxe.lang.Runtime.toBool(_.@params[0]);
						if (( this.p.length == 0 )) {
							return "";
						}
						else if (first1) {
							return this.p.@join("");
						}
						else {
							return global::haxe.lang.Runtime.toString((this.p.pop()).toDynamic());
						}
						
					}
					
					
					case 2:
					{
						if (global::haxe.lang.Runtime.toBool(_.@params[0])) {
							return this.p.@join("");
						}
						else {
							return global::haxe.lang.Runtime.toString((this.p.pop()).toDynamic());
						}
						
					}
					
					
				}
				
				return null;
			}
		}
		
		
		public global::Array<object> p;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace thx.format._DecimalFormat {
	public class CustomFormat : global::haxe.lang.ParamEnum {
		
		public CustomFormat(int index, object[] @params) : base(index, @params) {
		}
		
		
		public static readonly string[] __hx_constructs = new string[]{"Literal", "Hash", "Zero"};
		
		public static global::thx.format._DecimalFormat.CustomFormat Literal(string s) {
			return new global::thx.format._DecimalFormat.CustomFormat(0, new object[]{s});
		}
		
		
		public static global::thx.format._DecimalFormat.CustomFormat Hash(bool first) {
			unchecked {
				return new global::thx.format._DecimalFormat.CustomFormat(1, new object[]{first});
			}
		}
		
		
		public static global::thx.format._DecimalFormat.CustomFormat Zero(bool first) {
			unchecked {
				return new global::thx.format._DecimalFormat.CustomFormat(2, new object[]{first});
			}
		}
		
		
		public override string getTag() {
			return global::thx.format._DecimalFormat.CustomFormat.__hx_constructs[this.index];
		}
		
		
	}
}


