// Generated by Haxe 3.3.0

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::haxe.lang.FieldLookup.length = ( global::haxe.lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{98, 101, 102, 104, 105, 107, 109, 113, 114, 116, 120, 21233, 21234, 21235, 21236, 21237, 21238, 24867, 1821933, 4745537, 4845682, 4846113, 4848343, 4849249, 4896960, 4947370, 4949376, 5144726, 5193562, 5343647, 5393365, 5442204, 5495059, 5594513, 5594516, 5594520, 5695307, 5741474, 5745035, 5992347, 10917646, 24046298, 26061316, 39622016, 41050500, 42398688, 42740551, 45312342, 52644165, 57219237, 63559312, 67859554, 67859999, 69718249, 72452854, 74822897, 76061764, 78447857, 87367608, 96903864, 99632527, 100663795, 103479213, 106319913, 109574339, 114759225, 116192081, 142301684, 142895325, 143441458, 143865495, 156956385, 159136996, 160217260, 177600534, 193568515, 200302604, 212244564, 214711673, 219115881, 222029606, 227901364, 227901366, 227901371, 227901394, 227901409, 227901415, 238607874, 239873475, 240155668, 243941259, 244830897, 253833312, 265544154, 270118404, 282949586, 286437776, 288025444, 288368849, 302437830, 302979532, 307312293, 311921353, 314003042, 328878574, 334695532, 336707124, 354602035, 359333139, 399964207, 407283053, 409871691, 414504008, 418482770, 431030292, 437335495, 440996547, 445440548, 451001976, 452737314, 453240570, 468751485, 469217019, 469217028, 469217030, 469217033, 469217035, 469217036, 469217066, 469217072, 478746067, 480756972, 482248426, 484018937, 489915600, 493691202, 501039929, 506461556, 509857466, 519817503, 520590566, 528448451, 529765024, 530261339, 547728936, 554059097, 561678025, 563316893, 584411450, 593501699, 596483356, 596496232, 597467743, 602680035, 614073432, 623100778, 625308696, 631673605, 635699692, 641357653, 641535602, 647756354, 652148892, 653824046, 665670594, 667371489, 673902972, 674203586, 691754853, 694450483, 696720919, 699988920, 724060212, 726839840, 726843185, 735026061, 735461151, 742587063, 767112783, 783564643, 786627854, 815911746, 816375999, 817595090, 817646368, 822857114, 834174833, 843587180, 845179051, 845339077, 872071561, 872279826, 883188921, 887574448, 891567758, 897845290, 899913875, 908638873, 910198946, 922671056, 927738905, 931922363, 932127235, 934297389, 936862869, 944645571, 946786476, 959399230, 961866285, 971992536, 980339899, 980455379, 985129348, 985194240, 989248790, 990364012, 992442663, 993950564, 995006396, 999967216, 1002257126, 1002304485, 1014900378, 1035841961, 1036085211, 1037234130, 1037433933, 1037683693, 1046660463, 1050338953, 1050456214, 1055554178, 1056766449, 1058156409, 1065374039, 1067353468, 1071652316, 1072885311, 1079146715, 1084792286, 1087583414, 1090307191, 1090307193, 1091627025, 1095941093, 1099121107, 1102421591, 1103409453, 1103412149, 1111933837, 1112096333, 1113806382, 1114501250, 1126920507, 1135983070, 1152408707, 1154932936, 1155848147, 1158359328, 1169453134, 1170141094, 1170148173, 1170148174, 1170195731, 1171632074, 1172057283, 1181037546, 1191633396, 1202619922, 1202718727, 1202920542, 1204816148, 1213952397, 1223769091, 1224901875, 1225397154, 1229579091, 1232990044, 1245800482, 1246877401, 1246881189, 1247723251, 1247875320, 1247875546, 1266251794, 1269755426, 1271070480, 1273207865, 1273872862, 1274099839, 1275922997, 1280544829, 1280549057, 1280845662, 1281091404, 1281093634, 1282943179, 1283523890, 1285332817, 1291299698, 1292082402, 1293712380, 1313416818, 1324507718, 1324904599, 1324905541, 1327174177, 1329111435, 1352786672, 1356615670, 1357975336, 1365803947, 1386842537, 1395555037, 1401610182, 1407495052, 1413779326, 1428431209, 1428901784, 1429408506, 1429880786, 1429881906, 1429887058, 1429887281, 1429887945, 1429889060, 1429890418, 1429890642, 1429891762, 1437940672, 1447008734, 1457436259, 1484698101, 1492254877, 1492589217, 1503837296, 1504438184, 1510669659, 1516540973, 1522460754, 1528104702, 1531583505, 1531979784, 1532710347, 1537812987, 1543554379, 1543873646, 1543876321, 1547539107, 1548166113, 1553877950, 1556187364, 1556190932, 1556191155, 1563286311, 1567370554, 1568593144, 1572469162, 1594730607, 1604324540, 1610611779, 1619211300, 1620824029, 1621420777, 1622659719, 1623148745, 1631282614, 1639293562, 1640272491, 1648581351, 1660995221, 1669413332, 1675742188, 1677577253, 1692511090, 1694977701, 1700034528, 1705629508, 1723805383, 1729708482, 1747840398, 1756390674, 1768164316, 1768548618, 1771130534, 1781145963, 1796247438, 1798631236, 1800886518, 1801622666, 1802291657, 1804873517, 1812362308, 1813879407, 1825405726, 1830310359, 1844460293, 1851249714, 1861441745, 1864494649, 1864919677, 1867552145, 1870897157, 1880264788, 1891834246, 1894671199, 1914813385, 1915412854, 1916009602, 1926178603, 1932118984, 1934108263, 1950686233, 1981972957, 2011513979, 2013154798, 2014410004, 2022294396, 2025055113, 2025584634, 2026378982, 2026819210, 2037785099, 2048392659, 2049945213, 2058605085, 2062500402, 2082663554, 2082702159, 2083500811, 2084789794, 2087824363, 2101478163, 2113364337, 2116486270, 2123232567, 2127021138, 2133490940, 2137714887, 2140014923, 2143813817};
		
		protected static string[] fields = new string[]{"b", "e", "f", "h", "i", "k", "m", "q", "r", "t", "x", "_0", "_1", "_2", "_3", "_4", "_5", "or", "isGlobal", "__a", "abs", "add", "and", "arr", "big", "cls", "cur", "get", "has", "key", "len", "map", "not", "pop", "pos", "pow", "run", "set", "sum", "xor", "moduloWithScale", "split", "teardown", "compareTo", "symbolPermille", "ceilTo", "flags", "patternNegativeCurrency", "match", "compare", "addSuccesses", "start", "stats", "failures", "executeMethod", "successes", "remove", "packageName", "filter", "merge", "startTime", "testBinary", "progress", "nameCalendar", "hasSetup", "symbolPositiveInfinity", "target", "resize", "result", "testSectionSeparator", "warnings", "method", "matched", "addErrors", "signPositive", "separatorGroupNumber", "subtractBig", "newline", "separatorDecimalPercent", "roundTo", "setLoop", "testF", "testH", "testM", "testd", "tests", "testy", "get_nameDisplayEnglish", "testCurrency", "stackToString", "testFormatFixed", "compareArg", "patternNegativePercent", "append", "onPrecheck", "signNegative", "getPackage", "assertations", "string", "_trace", "methodName", "hasErrors", "symbolCurrency", "packageNames", "iterator", "indent", "toInt", "patternUniversalSortable", "lastIndexOf", "totals", "hasNext", "onAddFailures", "setHandler", "innerError", "testCustomEscapedDecimalSeparator", "message", "onStart", "multiply", "keysLoop", "reverse", "patternDateTimeFull", "isSmall", "testFormatD", "testFormatM", "testFormatO", "testFormatR", "testFormatT", "testFormatU", "testFormats", "testFormaty", "expireson", "nOccupied", "onTestComplete", "onAddWarnings", "testCustomDecimalFranction", "testCustomE", "insert", "dumpStack", "dispatch", "addBig", "length", "getTime", "nameCalendarNative", "addAsync", "testCustomFormatHash", "calendarWeekRuleName", "number", "allOk", "patternDateLong", "toStringWithBase", "balance", "setupName", "testDecimal", "patternDateTimeSortable", "matchedRight", "hasTeardownError", "nextRun", "get_nameDisplayNative", "nameDaysShortest", "displaySuccessResults", "methods", "nameNative", "patternPositivePercent", "nameDisplayNative", "firstDayOfWeekName", "nameMonthGenitives", "testCustomPercentSpecifier", "getClass", "addPackage", "separatorDate", "testCustomRounding", "nameMonthGenitivesAbbreviated", "replace", "designatorAm", "designatorPm", "onAddErrors", "setTimeout", "nameDaysAbbreviated", "onAddSuccesses", "separatorList", "compareToAbsBig", "onTimeout", "patternTimeShort", "compareToAbs", "compareToBig", "patternPositiveCurrency", "value", "asyncStack", "quotient", "precheck", "aggregator", "separatorTime", "nameDisplayEnglish", "onTested", "addHeader", "addFailures", "testPercent", "patternTimeLong", "compareArgs", "cachedIndex", "checkTested", "firstDayOfWeekIndex", "random", "globalPattern", "compareToAbsSmall", "success", "toString", "identity", "packages", "addWarnings", "testNumber", "patternYearMonth", "testCustomEscape", "getResults", "divModSmall", "patternMonthDay", "methodNames", "priority", "hashes", "runner", "hasAsyncError", "remainder", "toObject", "testHex", "testMMM", "testddd", "testhh_", "testmm_", "displayHeader", "testTimeSeprator", "nameRegionNative", "nameDays", "divMod", "divide", "testCustomDecimalSeparator", "splice", "exists", "equals", "nameMonthsAbbreviated", "addResult", "modulo", "testPrintfb", "testPrintfd", "base", "isOdd", "getFixture", "addClass", "code", "copy", "bindHandler", "symbolPercent", "date", "done", "matchSub", "fail", "upperMatch", "removeLoop", "minBinding", "head", "ietf", "isOk", "iso2", "iso3", "item", "handler", "getOrCreateClass", "join", "keys", "lcid", "left", "list", "concat", "clear", "multiplySmall", "next", "noop", "testExponential", "hasTestError", "flattenPackage", "pack", "path", "prev", "pure", "push", "testMMMM", "root", "matchedPos", "current", "nameMonths", "isNegative", "execute", "sign", "size", "sort", "step", "stop", "quicksort", "testFormatHex", "nameRegionEnglish", "recursive", "trim", "groupSizesNumber", "vals", "warn", "win3", "wire", "toFloat", "completed", "spliceVoid", "testUnit", "zero", "errors", "shiftLeft", "cachedKey", "testRounding", "testInteger", "hasTeardown", "handlers", "stackItems", "equality", "testHH", "testMM", "testdd", "tested", "testh_", "testm_", "testss", "testtt", "testyy", "decimalDigitsNumber", "runNext", "hasFailures", "symbolNegativeInfinity", "square", "timeout", "classNames", "addFixture", "dateTime", "createFixture", "testdddd", "patternDateShort", "hasWarnings", "decimalDigitsCurrency", "concatNative", "nBuckets", "separatorGroupPercent", "testCurrencyIT", "testCurrencyUS", "className", "hasTimeoutError", "runFixture", "testFormatd_", "testFormatt_", "testFormatu_", "compareToSmall", "testCustomFormat", "onComplete", "testDateSeprator", "testCustomPermilleSpecifier", "existsClass", "symbolNaN", "isEven", "__unsafe_get", "__unsafe_set", "indents", "indexOf", "testCustomFormat0", "lookup", "isMethod", "fileName", "separatorDecimalNumber", "unbindHandler", "onProgress", "nameEnglish", "iteratorLoop", "scaleTo", "patternRfc1123", "toDynamic", "regex", "negate", "patternNegativeNumber", "testyyyy", "right", "existsPackage", "classes", "__hx_constructs", "isUnit", "groupSizesCurrency", "results", "fixtures", "checkMethod", "getClassName", "calendarWeekRuleIndex", "teardownName", "unwire", "customParams", "matchScale", "isZero", "getOrCreatePackage", "addEvent", "isNeutral", "onTestStart", "hasSetupError", "isRightToLeft", "_height", "getPosition", "fixture", "__get", "__set", "testComplete", "error", "floorTo", "testOctal", "lineNumber", "testDifferentGroups", "decimalDigitsPercent", "subtract", "upperBound", "unshift", "shiftRight", "addSmall", "scale", "separatorGroupCurrency", "_keys", "setup", "separatorDecimalCurrency", "groupSizesPercent", "shift", "divModBig", "matchedLeft", "__hx_createEmpty", "divideWithScale", "subtractSmall", "addCase", "testPermille", "removeMinBinding", "slice", "multiplyBig", "small", "_handler", "complete"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::haxe.lang.FieldLookup.fieldIds;
				string[] cfields = global::haxe.lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::haxe.lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Different fields length: ", global::haxe.lang.Runtime.toString(nlen)), " and "), global::haxe.lang.Runtime.toString(( nfields as global::System.Array ).Length)));
				}
				
				bool needsChange = false;
				{
					int[] _g_arr = nids;
					uint _g_idx = ((uint) (0) );
					while (((bool) (( _g_idx < ( _g_arr as global::System.Array ).Length )) )) {
						if (( global::haxe.lang.FieldLookup.findHash(((int) (_g_arr[((int) (_g_idx++) )]) ), cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::haxe.lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( ( ci < clen ) && ( ni < nlen ) ))) ) {
								break;
							}
							
							if (( cids[ci] < nids[ni] )) {
								ansIds[ansi] = cids[ci];
								ansFields[ansi] = cfields[ci];
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = nids[ni];
								ansFields[ansi] = nfields[ni];
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::haxe.lang.FieldLookup.fieldIds = ansIds;
						global::haxe.lang.FieldLookup.fields = ansFields;
						global::haxe.lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ((int) (( (( max - min )) / 2 )) ) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return global::haxe.lang.FieldLookup.fields[mid];
					}
					
				}
				
				throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat("Field not found for hash ", global::haxe.lang.Runtime.toString(key)));
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (string.Equals(s, null)) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g1 = 0;
					int _g = s.Length;
					while (( _g1 < _g )) {
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[_g1++]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				string[] fld = global::haxe.lang.FieldLookup.fields;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				int len = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ids[mid];
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						if ( ! (string.Equals(fld[mid], s)) ) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::haxe.lang.FieldLookup)){
					if (( len != global::haxe.lang.FieldLookup.length )) {
						return global::haxe.lang.FieldLookup.hash(s);
					}
					
					global::haxe.lang.FieldLookup.insert<int>(ref global::haxe.lang.FieldLookup.fieldIds, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((int) (key) ));
					global::haxe.lang.FieldLookup.insert<string>(ref global::haxe.lang.FieldLookup.fields, ((int) (global::haxe.lang.FieldLookup.length) ), ((int) (min) ), ((string) (s) ));
					 ++ global::haxe.lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ((int) (( (( max + min )) / 2 )) );
					int imid = hashs[mid];
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void @remove<T>(T[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = default(T);
			}
		}
		
		
		public static void insert<T>(ref T[] a, int length, int pos, T x) {
			unchecked {
				int capacity = ( a as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						T[] newarr = new T[( (( length << 1 )) + 1 )];
						( a as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a = ((T[]) (newarr) );
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						T[] newarr1 = new T[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a = ((T[]) (newarr1) );
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					T[] newarr2 = new T[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a = ((T[]) (newarr2) );
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (pos) ), ((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a) ), ((int) (0) ), ((global::System.Array) (a) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a[pos] = x;
			}
		}
		
		
	}
}


