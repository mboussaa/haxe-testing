<?php

// Generated by Haxe 3.3.0
class thx_promise_Future {
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$this->handlers = (new _hx_array(array()));
		$this->state = haxe_ds_Option::$None;
	}}
	public $handlers;
	public $state;
	public function hasValue() {
		return thx_Options::toBool($this->state);
	}
	public function map($handler) {
		$_gthis = $this;
		return thx_promise_Future::create(array(new _hx_lambda(array(&$_gthis, &$handler), "thx_promise_Future_0"), 'execute'));
	}
	public function mapAsync($handler) {
		$_gthis = $this;
		return thx_promise_Future::create(array(new _hx_lambda(array(&$_gthis, &$handler), "thx_promise_Future_1"), 'execute'));
	}
	public function mapPromise($handler) {
		$_gthis = $this;
		return thx_promise__Promise_Promise_Impl_::create(array(new _hx_lambda(array(&$_gthis, &$handler), "thx_promise_Future_2"), 'execute'));
	}
	public function nil() {
		return $this->map(array(new _hx_lambda(array(), "thx_promise_Future_3"), 'execute'));
	}
	public function mapFuture($handler) {
		return $this->flatMap($handler);
	}
	public function flatMap($handler) {
		$_gthis = $this;
		return thx_promise_Future::create(array(new _hx_lambda(array(&$_gthis, &$handler), "thx_promise_Future_4"), 'execute'));
	}
	public function then($handler) {
		$this->handlers->push($handler);
		$this->update();
		return $this;
	}
	public function toString() {
		return "Future";
	}
	public function setState($newstate) {
		{
			$_g = $this->state;
			$tmp = $_g->index;
			switch($tmp) {
			case 0:{
				$tmp1 = Std::string(_hx_deref($_g)->params[0]);
				$tmp2 = "future was already \"" . _hx_string_or_null($tmp1) . "\", can't apply the new state \"";
				$tmp3 = Std::string($newstate);
				throw new HException(new thx_Error(_hx_string_or_null($tmp2) . _hx_string_or_null($tmp3) . "\"", null, _hx_anonymous(array("fileName" => "Future.hx", "lineNumber" => 121, "className" => "thx.promise.Future", "methodName" => "setState"))));
			}break;
			case 1:{
				$this->state = haxe_ds_Option::Some($newstate);
			}break;
			}
		}
		$this->update();
		return $this;
	}
	public function update() {
		$_g = $this->state;
		$tmp = $_g->index;
		switch($tmp) {
		case 0:{
			$result = _hx_deref($_g)->params[0];
			{
				$index = -1;
				while(true) {
					$tmp1 = ++$index;
					if(!($tmp1 < $this->handlers->length)) {
						break;
					}
					call_user_func_array($this->handlers[$index], array($result));
					unset($tmp1);
				}
				$this->handlers = (new _hx_array(array()));
			}
		}break;
		case 1:{}break;
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static function sequence($arr) {
		return thx_promise_Future::create(array(new _hx_lambda(array(&$arr), "thx_promise_Future_5"), 'execute'));
	}
	static function afterAll($arr) {
		return thx_promise_Future::sequence($arr)->nil();
	}
	static function all($arr) {
		return thx_promise_Future::sequence($arr);
	}
	static function create($handler) {
		$future = new thx_promise_Future();
		call_user_func_array($handler, array((isset($future->setState) ? $future->setState: array($future, "setState"))));
		return $future;
	}
	static function flatten($future) {
		return thx_promise_Future::create(array(new _hx_lambda(array(&$future), "thx_promise_Future_6"), 'execute'));
	}
	static function value($v) {
		return thx_promise_Future::create(array(new _hx_lambda(array(&$v), "thx_promise_Future_7"), 'execute'));
	}
	function __toString() { return $this->toString(); }
}
function thx_promise_Future_0(&$_gthis, &$handler, $callback) {
	{
		$_gthis->then(array(new _hx_lambda(array(&$callback, &$handler), "thx_promise_Future_8"), 'execute'));
	}
}
function thx_promise_Future_1(&$_gthis, &$handler, $callback) {
	{
		$_gthis->then(array(new _hx_lambda(array(&$callback, &$handler), "thx_promise_Future_9"), 'execute'));
	}
}
function thx_promise_Future_2(&$_gthis, &$handler, $resolve, $reject) {
	{
		$_gthis->then(array(new _hx_lambda(array(&$handler, &$reject, &$resolve), "thx_promise_Future_10"), 'execute'));
	}
}
function thx_promise_Future_3($_) {
	{
		return thx_Nil::$nil;
	}
}
function thx_promise_Future_4(&$_gthis, &$handler, $callback) {
	{
		$_gthis->then(array(new _hx_lambda(array(&$callback, &$handler), "thx_promise_Future_11"), 'execute'));
	}
}
function thx_promise_Future_5(&$arr, $callback) {
	{
		$acc = (new _hx_array(array()));
		$poll = null;
		$poll = array(new _hx_lambda(array(&$acc, &$arr, &$callback, &$poll), "thx_promise_Future_12"), 'execute');
		call_user_func_array($poll, array(0));
	}
}
function thx_promise_Future_6(&$future, $callback) {
	{
		$future->then(array(new _hx_lambda(array(&$callback), "thx_promise_Future_13"), 'execute'));
	}
}
function thx_promise_Future_7(&$v, $callback) {
	{
		call_user_func_array($callback, array($v));
	}
}
function thx_promise_Future_8(&$callback, &$handler, $v) {
	{
		$tmp = call_user_func_array($handler, array($v));
		call_user_func_array($callback, array($tmp));
	}
}
function thx_promise_Future_9(&$callback, &$handler, $result) {
	{
		call_user_func_array($handler, array($result, $callback));
	}
}
function thx_promise_Future_10(&$handler, &$reject, &$resolve, $result) {
	{
		$tmp = call_user_func_array($handler, array($result));
		$tmp1 = thx_promise__Promise_Promise_Impl_::success($tmp, $resolve);
		thx_promise__Promise_Promise_Impl_::failure($tmp1, $reject);
	}
}
function thx_promise_Future_11(&$callback, &$handler, $v) {
	{
		call_user_func_array($handler, array($v))->then($callback);
	}
}
function thx_promise_Future_12(&$acc, &$arr, &$callback, &$poll, $index) {
	{
		$tmp = $index === $arr->length;
		if($tmp) {
			call_user_func_array($callback, array($acc));
			return;
		}
		_hx_array_get($arr, $index)->then(array(new _hx_lambda(array(&$acc, &$index, &$poll), "thx_promise_Future_14"), 'execute'));
	}
}
function thx_promise_Future_13(&$callback, $future1) {
	{
		$future1->then($callback);
	}
}
function thx_promise_Future_14(&$acc, &$index, &$poll, $v) {
	{
		$acc[$index] = $v;
		call_user_func_array($poll, array($index + 1));
	}
}
