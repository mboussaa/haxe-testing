<?php

// Generated by Haxe 3.3.0
class thx_csv_core_Parser {
	public function __construct($delimiter, $quote, $escapedQuote) {
		if(!php_Boot::$skip_constructor) {
		$this->delimiter = $delimiter;
		$this->quote = $quote;
		$this->escapedQuote = $escapedQuote;
	}}
	public $delimiter;
	public $quote;
	public $escapedQuote;
	public $result;
	public $pos;
	public $len;
	public $delimiterLength;
	public $quoteLength;
	public $escapedQuoteLength;
	public $buffer;
	public $row;
	public $s;
	public function parse($s) {
		$this->s = $s;
		$this->result = (new _hx_array(array()));
		$this->pos = 0;
		$this->len = strlen($s);
		$this->delimiterLength = strlen($this->delimiter);
		$this->quoteLength = strlen($this->quote);
		$this->escapedQuoteLength = strlen($this->escapedQuote);
		$this->buffer = new StringBuf();
		$this->row = (new _hx_array(array()));
		try {
			$t = null;
			while($this->pos < $this->len) {
				$tmp = null;
				$tmp1 = $this->pos;
				$tmp2 = $this->pos + $this->quoteLength;
				$tmp3 = _hx_substring($this->s, $tmp1, $tmp2);
				if($tmp3 === $this->quote) {
					$tmp = strlen($this->buffer->b) === 0;
				} else {
					$tmp = false;
				}
				if($tmp) {
					$this->pos += $this->quoteLength;
					while($this->pos < $this->len) {
						$tmp4 = $this->pos;
						$tmp5 = $this->pos + $this->escapedQuoteLength;
						$tmp6 = _hx_substring($this->s, $tmp4, $tmp5);
						if($tmp6 === $this->escapedQuote) {
							$this->pushBuffer($this->quote);
							$this->pos += $this->escapedQuoteLength;
						} else {
							$tmp7 = $this->pos;
							$tmp8 = $this->pos + $this->quoteLength;
							$tmp9 = _hx_substring($this->s, $tmp7, $tmp8);
							if($tmp9 === $this->quote) {
								$this->pos += $this->quoteLength;
								$tmp10 = $this->pos;
								$tmp11 = $this->pos + 1;
								$next = _hx_substring($this->s, $tmp10, $tmp11);
								while(true) {
									$tmp12 = null;
									if($next !== " ") {
										if($this->delimiter !== "\x09") {
											$tmp12 = $next === "\x09";
										} else {
											$tmp12 = false;
										}
									} else {
										$tmp12 = true;
									}
									if(!$tmp12) {
										break;
									}
									++$this->pos;
									$tmp13 = $this->pos;
									$tmp14 = $this->pos + 1;
									$next = _hx_substring($this->s, $tmp13, $tmp14);
									unset($tmp14,$tmp13,$tmp12);
								}
								break;
								unset($tmp11,$tmp10,$next);
							} else {
								$tmp15 = $this->pos;
								$tmp16 = $this->pos + 1;
								$tmp17 = _hx_substring($this->s, $tmp15, $tmp16);
								$this->pushBuffer($tmp17);
								++$this->pos;
								unset($tmp17,$tmp16,$tmp15);
							}
							unset($tmp9,$tmp8,$tmp7);
						}
						unset($tmp6,$tmp5,$tmp4);
					}
				} else {
					$tmp18 = $this->pos;
					$tmp19 = $this->pos + $this->delimiterLength;
					$tmp20 = _hx_substring($this->s, $tmp18, $tmp19);
					if($tmp20 === $this->delimiter) {
						$this->pushCell();
						$this->pos += $this->delimiterLength;
					} else {
						$tmp21 = $this->pos;
						$tmp22 = $this->pos + 2;
						$t = _hx_substring($this->s, $tmp21, $tmp22);
						$tmp23 = null;
						if($t !== "\x0A\x0D") {
							$tmp23 = $t === "\x0D\x0A";
						} else {
							$tmp23 = true;
						}
						if($tmp23) {
							$this->pos += 2;
							$this->pushCell();
							$this->pushRow();
							continue;
						}
						$tmp24 = $this->pos;
						$tmp25 = $this->pos + 1;
						$t = _hx_substring($this->s, $tmp24, $tmp25);
						$tmp26 = null;
						if($t !== "\x0A") {
							$tmp26 = $t === "\x0D";
						} else {
							$tmp26 = true;
						}
						if($tmp26) {
							++$this->pos;
							$this->pushCell();
							$this->pushRow();
							continue;
						}
						$tmp27 = $this->pos;
						$tmp28 = $this->pos + 1;
						$tmp29 = _hx_substring($this->s, $tmp27, $tmp28);
						$this->pushBuffer($tmp29);
						++$this->pos;
						unset($tmp29,$tmp28,$tmp27,$tmp26,$tmp25,$tmp24,$tmp23,$tmp22,$tmp21);
					}
					unset($tmp20,$tmp19,$tmp18);
				}
				unset($tmp3,$tmp2,$tmp1,$tmp);
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{
				haxe_Log::trace($e, _hx_anonymous(array("fileName" => "Parser.hx", "lineNumber" => 39, "className" => "thx.csv.core.Parser", "methodName" => "parse")));
				$tmp30 = "unable to parse at pos " . _hx_string_rec($this->pos, "") . ": ";
				$tmp31 = Std::string($e);
				throw new HException(new thx_Error(_hx_string_or_null($tmp30) . _hx_string_or_null($tmp31), null, _hx_anonymous(array("fileName" => "Parser.hx", "lineNumber" => 40, "className" => "thx.csv.core.Parser", "methodName" => "parse"))));
			}
		}
		$this->pushCell();
		$this->pushRow();
		return $this->result;
	}
	public function pushCell() {
		$this->row->push($this->buffer->b);
		$this->buffer = new StringBuf();
	}
	public function pushBuffer($char) {
		$this->buffer->add($char);
	}
	public function pushRow() {
		$this->result->push($this->row);
		$this->row = (new _hx_array(array()));
	}
	public function loop() {
		$t = null;
		while($this->pos < $this->len) {
			$tmp = null;
			$tmp1 = $this->pos;
			$tmp2 = $this->pos + $this->quoteLength;
			$tmp3 = _hx_substring($this->s, $tmp1, $tmp2);
			if($tmp3 === $this->quote) {
				$tmp = strlen($this->buffer->b) === 0;
			} else {
				$tmp = false;
			}
			if($tmp) {
				$this->pos += $this->quoteLength;
				while($this->pos < $this->len) {
					$tmp4 = $this->pos;
					$tmp5 = $this->pos + $this->escapedQuoteLength;
					$tmp6 = _hx_substring($this->s, $tmp4, $tmp5);
					if($tmp6 === $this->escapedQuote) {
						$this->pushBuffer($this->quote);
						$this->pos += $this->escapedQuoteLength;
					} else {
						$tmp7 = $this->pos;
						$tmp8 = $this->pos + $this->quoteLength;
						$tmp9 = _hx_substring($this->s, $tmp7, $tmp8);
						if($tmp9 === $this->quote) {
							$this->pos += $this->quoteLength;
							$tmp10 = $this->pos;
							$tmp11 = $this->pos + 1;
							$next = _hx_substring($this->s, $tmp10, $tmp11);
							while(true) {
								$tmp12 = null;
								if($next !== " ") {
									if($this->delimiter !== "\x09") {
										$tmp12 = $next === "\x09";
									} else {
										$tmp12 = false;
									}
								} else {
									$tmp12 = true;
								}
								if(!$tmp12) {
									break;
								}
								++$this->pos;
								$tmp13 = $this->pos;
								$tmp14 = $this->pos + 1;
								$next = _hx_substring($this->s, $tmp13, $tmp14);
								unset($tmp14,$tmp13,$tmp12);
							}
							break;
							unset($tmp11,$tmp10,$next);
						} else {
							$tmp15 = $this->pos;
							$tmp16 = $this->pos + 1;
							$tmp17 = _hx_substring($this->s, $tmp15, $tmp16);
							$this->pushBuffer($tmp17);
							++$this->pos;
							unset($tmp17,$tmp16,$tmp15);
						}
						unset($tmp9,$tmp8,$tmp7);
					}
					unset($tmp6,$tmp5,$tmp4);
				}
			} else {
				$tmp18 = $this->pos;
				$tmp19 = $this->pos + $this->delimiterLength;
				$tmp20 = _hx_substring($this->s, $tmp18, $tmp19);
				if($tmp20 === $this->delimiter) {
					$this->pushCell();
					$this->pos += $this->delimiterLength;
				} else {
					$tmp21 = $this->pos;
					$tmp22 = $this->pos + 2;
					$t = _hx_substring($this->s, $tmp21, $tmp22);
					$tmp23 = null;
					if($t !== "\x0A\x0D") {
						$tmp23 = $t === "\x0D\x0A";
					} else {
						$tmp23 = true;
					}
					if($tmp23) {
						$this->pos += 2;
						$this->pushCell();
						$this->pushRow();
						continue;
					}
					$tmp24 = $this->pos;
					$tmp25 = $this->pos + 1;
					$t = _hx_substring($this->s, $tmp24, $tmp25);
					$tmp26 = null;
					if($t !== "\x0A") {
						$tmp26 = $t === "\x0D";
					} else {
						$tmp26 = true;
					}
					if($tmp26) {
						++$this->pos;
						$this->pushCell();
						$this->pushRow();
						continue;
					}
					$tmp27 = $this->pos;
					$tmp28 = $this->pos + 1;
					$tmp29 = _hx_substring($this->s, $tmp27, $tmp28);
					$this->pushBuffer($tmp29);
					++$this->pos;
					unset($tmp29,$tmp28,$tmp27,$tmp26,$tmp25,$tmp24,$tmp23,$tmp22,$tmp21);
				}
				unset($tmp20,$tmp19,$tmp18);
			}
			unset($tmp3,$tmp2,$tmp1,$tmp);
		}
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return 'thx.csv.core.Parser'; }
}
