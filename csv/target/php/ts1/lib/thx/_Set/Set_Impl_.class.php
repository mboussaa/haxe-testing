<?php

// Generated by Haxe 3.3.0
class thx__Set_Set_Impl_ {
	public function __construct(){}
	static function createString($it = null) {
		$map = new haxe_ds_StringMap();
		$set = $map;
		if(null !== $it) {
			thx__Set_Set_Impl_::pushMany($set, $it);
		}
		return $set;
	}
	static function createInt($it = null) {
		$map = new haxe_ds_IntMap();
		$set = $map;
		if(null !== $it) {
			thx__Set_Set_Impl_::pushMany($set, $it);
		}
		return $set;
	}
	static function createObject($it = null) {
		$map = new haxe_ds_ObjectMap();
		$set = $map;
		if(null !== $it) {
			thx__Set_Set_Impl_::pushMany($set, $it);
		}
		return $set;
	}
	static function createEnum($arr = null) {
		$map = new haxe_ds_EnumValueMap();
		$set = $map;
		if(null !== $arr) {
			thx__Set_Set_Impl_::pushMany($set, $arr);
		}
		return $set;
	}
	static function _new($map) {
		return $map;
	}
	static function add($this1, $v) {
		$tmp = $this1->exists($v);
		if($tmp) {
			return false;
		} else {
			$this1->set($v, true);
			return true;
		}
	}
	static function copy($this1) {
		$inst = thx__Set_Set_Impl_::hempty($this1);
		{
			$tmp = $this1->keys();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$k = $tmp->next();
				$inst->set($k, true);
				unset($tmp1,$k);
			}
		}
		return $inst;
	}
	static function hempty($this1) {
		$tmp = Type::getClass($this1);
		$inst = Type::createInstance($tmp, (new _hx_array(array())));
		return $inst;
	}
	static function difference($this1, $set) {
		$result = thx__Set_Set_Impl_::copy($this1);
		{
			$tmp = thx__Set_Set_Impl_::iterator($set);
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$item = $tmp->next();
				$result->remove($item);
				unset($tmp1,$item);
			}
		}
		return $result;
	}
	static function filter($this1, $predicate) {
		$tmp = thx__Set_Set_Impl_::hempty($this1);
		return thx__Set_Set_Impl_::reduce($this1, array(new _hx_lambda(array(&$predicate), "thx__Set_Set_Impl__0"), 'execute'), $tmp);
	}
	static function map($this1, $f) {
		return thx__Set_Set_Impl_::reduce($this1, array(new _hx_lambda(array(&$f), "thx__Set_Set_Impl__1"), 'execute'), (new _hx_array(array())));
	}
	static function exists($this1, $v) {
		return $this1->exists($v);
	}
	static function remove($this1, $v) {
		return $this1->remove($v);
	}
	static function intersection($this1, $set) {
		$result = thx__Set_Set_Impl_::hempty($this1);
		{
			$tmp = thx__Set_Set_Impl_::iterator($this1);
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$item = $tmp->next();
				$tmp2 = $set->exists($item);
				if($tmp2) {
					$result->set($item, true);
				}
				unset($tmp2,$tmp1,$item);
			}
		}
		return $result;
	}
	static function push($this1, $v) {
		$this1->set($v, true);
	}
	static function pushMany($this1, $values) {
		$tmp = $values->iterator();
		while(true) {
			$tmp1 = !$tmp->hasNext();
			if($tmp1) {
				break;
			}
			$value = $tmp->next();
			$this1->set($value, true);
			unset($value,$tmp1);
		}
	}
	static function reduce($this1, $handler, $acc) {
		{
			$tmp = thx__Set_Set_Impl_::iterator($this1);
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$v = $tmp->next();
				$acc = call_user_func_array($handler, array($acc, $v));
				unset($v,$tmp1);
			}
		}
		return $acc;
	}
	static function iterator($this1) {
		return $this1->keys();
	}
	static function union($this1, $set) {
		$newset = thx__Set_Set_Impl_::copy($this1);
		thx__Set_Set_Impl_::pushMany($newset, thx__Set_Set_Impl_::toArray($set));
		return $newset;
	}
	static function toArray($this1) {
		$arr = (new _hx_array(array()));
		{
			$tmp = $this1->keys();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$k = $tmp->next();
				$arr->push($k);
				unset($tmp1,$k);
			}
		}
		return $arr;
	}
	static function toString($this1) {
		$tmp = thx__Set_Set_Impl_::toArray($this1)->join(", ");
		return "{" . _hx_string_or_null($tmp) . "}";
	}
	static function get_length($this1) {
		$l = 0;
		{
			$tmp = $this1->iterator();
			while(true) {
				$tmp1 = !$tmp->hasNext();
				if($tmp1) {
					break;
				}
				$tmp->next();
				++$l;
				unset($tmp1);
			}
		}
		return $l;
	}
	static $__properties__ = array("get_length" => "get_length");
	function __toString() { return 'thx._Set.Set_Impl_'; }
}
function thx__Set_Set_Impl__0(&$predicate, $acc, $v) {
	{
		$tmp1 = call_user_func_array($predicate, array($v));
		if($tmp1) {
			thx__Set_Set_Impl_::add($acc, $v);
		}
		return $acc;
	}
}
function thx__Set_Set_Impl__1(&$f, $acc, $v) {
	{
		$tmp = call_user_func_array($f, array($v));
		$acc->push($tmp);
		return $acc;
	}
}
