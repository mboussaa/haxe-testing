<?php

// Generated by Haxe 3.3.0
class thx_csv_Dsv {
	public function __construct(){}
	static function decode($dsv, $options) {
		if(null === $options->quote) {
			$options->quote = "\"";
		}
		if(null === $options->escapedQuote) {
			$tmp = null;
			if($options->quote === "\"") {
				$tmp = "\"\"";
			} else {
				$tmp = "\\" . _hx_string_or_null($options->quote);
			}
			$options->escapedQuote = $tmp;
		}
		$tmp1 = null === $options->trimValues;
		if($tmp1) {
			$options->trimValues = false;
		}
		$tmp2 = null === $options->trimEmptyLines;
		if($tmp2) {
			$options->trimEmptyLines = true;
		}
		$tmp3 = $options->trimEmptyLines;
		if($tmp3) {
			$dsv = trim($dsv, "\x0A\x0D");
		}
		$result = null;
		if($dsv === "") {
			$result = (new _hx_array(array()));
		} else {
			$result = _hx_deref(new thx_csv_core_Parser($options->delimiter, $options->quote, $options->escapedQuote))->parse($dsv);
		}
		$tmp4 = $options->trimValues;
		if($tmp4) {
			$_g = 0;
			while($_g < $result->length) {
				$row = $result[$_g];
				++$_g;
				{
					$_g2 = 0;
					$_g1 = $row->length;
					while($_g2 < $_g1) {
						$i = $_g2++;
						$tmp5 = trim($row[$i]);
						$row[$i] = $tmp5;
						unset($tmp5,$i);
					}
					unset($_g2,$_g1);
				}
				unset($row);
			}
		}
		return $result;
	}
	static function decodeObjects($dsv, $options) {
		$tmp = thx_csv_Dsv::decode($dsv, $options);
		return thx_csv_Dsv::arrayToObjects($tmp);
	}
	static function arrayToObjects($arr) {
		$columns = $arr[0];
		if(null === $columns) {
			return (new _hx_array(array()));
		}
		$result = (new _hx_array(array()));
		$len = $columns->length;
		$row = null;
		$ob = null;
		{
			$_g1 = 1;
			$_g = $arr->length;
			while($_g1 < $_g) {
				$r = $_g1++;
				$ob = _hx_anonymous(array());
				$row = $arr[$r];
				{
					$_g3 = 0;
					$_g2 = $len;
					while($_g3 < $_g2) {
						$i = $_g3++;
						$ob->{$columns[$i]} = $row[$i];
						unset($i);
					}
					unset($_g3,$_g2);
				}
				$result->push($ob);
				unset($r);
			}
		}
		return $result;
	}
	static function encode($data, $options) {
		if(null === $options->quote) {
			$options->quote = "\"";
		}
		if(null === $options->escapedQuote) {
			$tmp = null;
			if($options->quote === "\"") {
				$tmp = "\"\"";
			} else {
				$tmp = "\\" . _hx_string_or_null($options->quote);
			}
			$options->escapedQuote = $tmp;
		}
		if(null === $options->newline) {
			$options->newline = "\x0A";
		}
		return $data->map(array(new _hx_lambda(array(&$options), "thx_csv_Dsv_0"), 'execute'))->join($options->newline);
	}
	static function encodeObjects($data, $options) {
		$tmp = thx_csv_Dsv::objectsToArray($data, (new _hx_array(array())));
		return thx_csv_Dsv::encode($tmp, $options);
	}
	static function objectsToArray($objects, $columns = null) {
		if(null === $columns) {
			return thx_csv_Dsv::objectsToArray($objects, (new _hx_array(array())));
		}
		$map = new haxe_ds_StringMap();
		$result = (new _hx_array(array($columns)));
		$collector = null;
		$row = null;
		{
			$_g1 = 0;
			$_g = $columns->length;
			while($_g1 < $_g) {
				$i = $_g1++;
				$map->set($columns[$i], $i);
				unset($i);
			}
		}
		{
			$_g2 = 0;
			while($_g2 < $objects->length) {
				$object = $objects[$_g2];
				++$_g2;
				$collector = (new _hx_array(array()));
				$row = (new _hx_array(array()));
				{
					$_g11 = 0;
					$_g21 = Reflect::fields($object);
					while($_g11 < $_g21->length) {
						$field = $_g21[$_g11];
						++$_g11;
						$index = $map->get($field);
						if(null === $index) {
							$collector->push($field);
						} else {
							$tmp = Reflect::field($object, $field);
							$row[$index] = $tmp;
							unset($tmp);
						}
						unset($index,$field);
					}
					unset($_g21,$_g11);
				}
				$tmp1 = $collector->length > 0;
				if($tmp1) {
					$tmp2 = $columns->concat($collector);
					return thx_csv_Dsv::objectsToArray($objects, $tmp2);
					unset($tmp2);
				} else {
					$result->push($row);
				}
				unset($tmp1,$object);
			}
		}
		return $result;
	}
	static function requiresQuotes($value, $delimiter, $quote) {
		$tmp = null;
		$tmp1 = null;
		$tmp2 = null;
		if($delimiter !== "") {
			$tmp3 = _hx_index_of($value, $delimiter, null);
			$tmp2 = $tmp3 >= 0;
		} else {
			$tmp2 = true;
		}
		if(!$tmp2) {
			if($quote !== "") {
				$tmp4 = _hx_index_of($value, $quote, null);
				$tmp1 = $tmp4 >= 0;
			} else {
				$tmp1 = true;
			}
		} else {
			$tmp1 = true;
		}
		if(!$tmp1) {
			$tmp5 = _hx_index_of($value, "\x0A", null);
			$tmp = $tmp5 >= 0;
		} else {
			$tmp = true;
		}
		if(!$tmp) {
			$tmp6 = _hx_index_of($value, "\x0D", null);
			return $tmp6 >= 0;
		} else {
			return true;
		}
	}
	static function applyQuotes($value, $quote, $escapedQuote) {
		if($quote === "") {
			$value = implode(str_split ($value), $escapedQuote);
		} else {
			$value = str_replace($quote, $escapedQuote, $value);
		}
		return "" . _hx_string_or_null($quote) . _hx_string_or_null($value) . _hx_string_or_null($quote);
	}
	function __toString() { return 'thx.csv.Dsv'; }
}
function thx_csv_Dsv_0(&$options, $row) {
	{
		return $row->map(array(new _hx_lambda(array(&$options), "thx_csv_Dsv_1"), 'execute'))->join($options->delimiter);
	}
}
function thx_csv_Dsv_1(&$options, $cell) {
	{
		$tmp1 = thx_csv_Dsv::requiresQuotes($cell, $options->delimiter, $options->quote);
		if($tmp1) {
			return thx_csv_Dsv::applyQuotes($cell, $options->quote, $options->escapedQuote);
		} else {
			return $cell;
		}
	}
}
