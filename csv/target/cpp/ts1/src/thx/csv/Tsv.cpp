// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_thx_csv_Dsv
#include <thx/csv/Dsv.h>
#endif
#ifndef INCLUDED_thx_csv_Tsv
#include <thx/csv/Tsv.h>
#endif

namespace thx{
namespace csv{

void Tsv_obj::__construct() { }

Dynamic Tsv_obj::__CreateEmpty() { return new Tsv_obj; }

hx::ObjectPtr< Tsv_obj > Tsv_obj::__new()
{
	hx::ObjectPtr< Tsv_obj > _hx_result = new Tsv_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Tsv_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Tsv_obj > _hx_result = new Tsv_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::Dynamic Tsv_obj::encodeOptions;

 ::Dynamic Tsv_obj::decodeOptions;

::Array< ::Dynamic> Tsv_obj::decode(::String csv){
            	HX_STACK_FRAME("thx.csv.Tsv","decode",0xd6bdc317,"thx.csv.Tsv.decode","thx/csv/Tsv.hx",18,0x416f3a7b)
            	HX_STACK_ARG(csv,"csv")
HXLINE(  18)		return ::thx::csv::Dsv_obj::decode(csv,::thx::csv::Tsv_obj::decodeOptions);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Tsv_obj,decode,return )

::Array< ::Dynamic> Tsv_obj::decodeObjects(::String tsv){
            	HX_STACK_FRAME("thx.csv.Tsv","decodeObjects",0x0af96e7d,"thx.csv.Tsv.decodeObjects","thx/csv/Tsv.hx",21,0x416f3a7b)
            	HX_STACK_ARG(tsv,"tsv")
HXLINE(  21)		::Array< ::Dynamic> _hx_tmp = ::thx::csv::Dsv_obj::decode(tsv,::thx::csv::Tsv_obj::decodeOptions);
HXDLIN(  21)		return ::thx::csv::Dsv_obj::arrayToObjects(_hx_tmp);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Tsv_obj,decodeObjects,return )

::String Tsv_obj::encode(::Array< ::Dynamic> data){
            	HX_STACK_FRAME("thx.csv.Tsv","encode",0x6bb457ff,"thx.csv.Tsv.encode","thx/csv/Tsv.hx",24,0x416f3a7b)
            	HX_STACK_ARG(data,"data")
HXLINE(  24)		return ::thx::csv::Dsv_obj::encode(data,::thx::csv::Tsv_obj::encodeOptions);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Tsv_obj,encode,return )

::String Tsv_obj::encodeObjects(::Array< ::Dynamic> data){
            	HX_STACK_FRAME("thx.csv.Tsv","encodeObjects",0xa074c695,"thx.csv.Tsv.encodeObjects","thx/csv/Tsv.hx",27,0x416f3a7b)
            	HX_STACK_ARG(data,"data")
HXLINE(  27)		return ::thx::csv::Dsv_obj::encodeObjects(data,::thx::csv::Tsv_obj::encodeOptions);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Tsv_obj,encodeObjects,return )


Tsv_obj::Tsv_obj()
{
}

bool Tsv_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"decode") ) { outValue = decode_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"encode") ) { outValue = encode_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"encodeOptions") ) { outValue = encodeOptions; return true; }
		if (HX_FIELD_EQ(inName,"decodeOptions") ) { outValue = decodeOptions; return true; }
		if (HX_FIELD_EQ(inName,"decodeObjects") ) { outValue = decodeObjects_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"encodeObjects") ) { outValue = encodeObjects_dyn(); return true; }
	}
	return false;
}

bool Tsv_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"encodeOptions") ) { encodeOptions=ioValue.Cast<  ::Dynamic >(); return true; }
		if (HX_FIELD_EQ(inName,"decodeOptions") ) { decodeOptions=ioValue.Cast<  ::Dynamic >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Tsv_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Tsv_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*Dynamic*/ ,(void *) &Tsv_obj::encodeOptions,HX_HCSTRING("encodeOptions","\xe8","\x77","\x03","\xa0")},
	{hx::fsObject /*Dynamic*/ ,(void *) &Tsv_obj::decodeOptions,HX_HCSTRING("decodeOptions","\xd0","\x1f","\x88","\x0a")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Tsv_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Tsv_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Tsv_obj::encodeOptions,"encodeOptions");
	HX_MARK_MEMBER_NAME(Tsv_obj::decodeOptions,"decodeOptions");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Tsv_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Tsv_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Tsv_obj::encodeOptions,"encodeOptions");
	HX_VISIT_MEMBER_NAME(Tsv_obj::decodeOptions,"decodeOptions");
};

#endif

hx::Class Tsv_obj::__mClass;

static ::String Tsv_obj_sStaticFields[] = {
	HX_HCSTRING("encodeOptions","\xe8","\x77","\x03","\xa0"),
	HX_HCSTRING("decodeOptions","\xd0","\x1f","\x88","\x0a"),
	HX_HCSTRING("decode","\x2e","\x5d","\xed","\x64"),
	HX_HCSTRING("decodeObjects","\x46","\x55","\xd9","\xac"),
	HX_HCSTRING("encode","\x16","\xf2","\xe3","\xf9"),
	HX_HCSTRING("encodeObjects","\x5e","\xad","\x54","\x42"),
	::String(null())
};

void Tsv_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("thx.csv.Tsv","\x65","\xd7","\x0a","\xcb");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Tsv_obj::__GetStatic;
	__mClass->mSetStaticField = &Tsv_obj::__SetStatic;
	__mClass->mMarkFunc = Tsv_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Tsv_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Tsv_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Tsv_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Tsv_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Tsv_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Tsv_obj::__boot()
{
{
            	HX_STACK_FRAME("thx.csv.Tsv","boot",0xcadf6ddb,"thx.csv.Tsv.boot","thx/csv/Tsv.hx",4,0x416f3a7b)
HXLINE(   4)		encodeOptions =  ::Dynamic(hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("delimiter",07,07,28,86),HX_("\t",09,00,00,00))
            			->setFixed(1,HX_("newline",54,98,a6,0c),HX_("\n",0a,00,00,00))
            			->setFixed(2,HX_("quote",3c,23,f2,5d),HX_("\"",22,00,00,00))
            			->setFixed(3,HX_("escapedQuote",79,02,8f,79),HX_("\"\"",c0,1d,00,00)));
            	}
{
            	HX_STACK_FRAME("thx.csv.Tsv","boot",0xcadf6ddb,"thx.csv.Tsv.boot","thx/csv/Tsv.hx",10,0x416f3a7b)
HXLINE(  10)		decodeOptions =  ::Dynamic(hx::Anon_obj::Create(5)
            			->setFixed(0,HX_("delimiter",07,07,28,86),HX_("\t",09,00,00,00))
            			->setFixed(1,HX_("trimValues",64,ea,de,bf),false)
            			->setFixed(2,HX_("trimEmptyLines",b4,03,7f,08),true)
            			->setFixed(3,HX_("quote",3c,23,f2,5d),HX_("\"",22,00,00,00))
            			->setFixed(4,HX_("escapedQuote",79,02,8f,79),HX_("\"\"",c0,1d,00,00)));
            	}
}

} // end namespace thx
} // end namespace csv
