// Generated by Haxe 3.3.0
#include <hxcpp.h>

#ifndef INCLUDED_thx_csv_Csv
#include <thx/csv/Csv.h>
#endif
#ifndef INCLUDED_thx_csv_Dsv
#include <thx/csv/Dsv.h>
#endif

namespace thx{
namespace csv{

void Csv_obj::__construct() { }

Dynamic Csv_obj::__CreateEmpty() { return new Csv_obj; }

hx::ObjectPtr< Csv_obj > Csv_obj::__new()
{
	hx::ObjectPtr< Csv_obj > _hx_result = new Csv_obj();
	_hx_result->__construct();
	return _hx_result;
}

Dynamic Csv_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< Csv_obj > _hx_result = new Csv_obj();
	_hx_result->__construct();
	return _hx_result;
}

 ::Dynamic Csv_obj::encodeOptions;

 ::Dynamic Csv_obj::decodeOptions;

::Array< ::Dynamic> Csv_obj::decode(::String csv){
            	HX_STACK_FRAME("thx.csv.Csv","decode",0x11cbcd48,"thx.csv.Csv.decode","thx/csv/Csv.hx",18,0x755e182c)
            	HX_STACK_ARG(csv,"csv")
HXLINE(  18)		return ::thx::csv::Dsv_obj::decode(csv,::thx::csv::Csv_obj::decodeOptions);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Csv_obj,decode,return )

::Array< ::Dynamic> Csv_obj::decodeObjects(::String csv){
            	HX_STACK_FRAME("thx.csv.Csv","decodeObjects",0x58c87c6c,"thx.csv.Csv.decodeObjects","thx/csv/Csv.hx",21,0x755e182c)
            	HX_STACK_ARG(csv,"csv")
HXLINE(  21)		::Array< ::Dynamic> _hx_tmp = ::thx::csv::Dsv_obj::decode(csv,::thx::csv::Csv_obj::decodeOptions);
HXDLIN(  21)		return ::thx::csv::Dsv_obj::arrayToObjects(_hx_tmp);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Csv_obj,decodeObjects,return )

::String Csv_obj::encode(::Array< ::Dynamic> data){
            	HX_STACK_FRAME("thx.csv.Csv","encode",0xa6c26230,"thx.csv.Csv.encode","thx/csv/Csv.hx",24,0x755e182c)
            	HX_STACK_ARG(data,"data")
HXLINE(  24)		return ::thx::csv::Dsv_obj::encode(data,::thx::csv::Csv_obj::encodeOptions);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Csv_obj,encode,return )

::String Csv_obj::encodeObjects(::Array< ::Dynamic> data){
            	HX_STACK_FRAME("thx.csv.Csv","encodeObjects",0xee43d484,"thx.csv.Csv.encodeObjects","thx/csv/Csv.hx",27,0x755e182c)
            	HX_STACK_ARG(data,"data")
HXLINE(  27)		return ::thx::csv::Dsv_obj::encodeObjects(data,::thx::csv::Csv_obj::encodeOptions);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC1(Csv_obj,encodeObjects,return )


Csv_obj::Csv_obj()
{
}

bool Csv_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"decode") ) { outValue = decode_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"encode") ) { outValue = encode_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"encodeOptions") ) { outValue = encodeOptions; return true; }
		if (HX_FIELD_EQ(inName,"decodeOptions") ) { outValue = decodeOptions; return true; }
		if (HX_FIELD_EQ(inName,"decodeObjects") ) { outValue = decodeObjects_dyn(); return true; }
		if (HX_FIELD_EQ(inName,"encodeObjects") ) { outValue = encodeObjects_dyn(); return true; }
	}
	return false;
}

bool Csv_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 13:
		if (HX_FIELD_EQ(inName,"encodeOptions") ) { encodeOptions=ioValue.Cast<  ::Dynamic >(); return true; }
		if (HX_FIELD_EQ(inName,"decodeOptions") ) { decodeOptions=ioValue.Cast<  ::Dynamic >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *Csv_obj_sMemberStorageInfo = 0;
static hx::StaticInfo Csv_obj_sStaticStorageInfo[] = {
	{hx::fsObject /*Dynamic*/ ,(void *) &Csv_obj::encodeOptions,HX_HCSTRING("encodeOptions","\xe8","\x77","\x03","\xa0")},
	{hx::fsObject /*Dynamic*/ ,(void *) &Csv_obj::decodeOptions,HX_HCSTRING("decodeOptions","\xd0","\x1f","\x88","\x0a")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void Csv_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(Csv_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(Csv_obj::encodeOptions,"encodeOptions");
	HX_MARK_MEMBER_NAME(Csv_obj::decodeOptions,"decodeOptions");
};

#ifdef HXCPP_VISIT_ALLOCS
static void Csv_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(Csv_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(Csv_obj::encodeOptions,"encodeOptions");
	HX_VISIT_MEMBER_NAME(Csv_obj::decodeOptions,"decodeOptions");
};

#endif

hx::Class Csv_obj::__mClass;

static ::String Csv_obj_sStaticFields[] = {
	HX_HCSTRING("encodeOptions","\xe8","\x77","\x03","\xa0"),
	HX_HCSTRING("decodeOptions","\xd0","\x1f","\x88","\x0a"),
	HX_HCSTRING("decode","\x2e","\x5d","\xed","\x64"),
	HX_HCSTRING("decodeObjects","\x46","\x55","\xd9","\xac"),
	HX_HCSTRING("encode","\x16","\xf2","\xe3","\xf9"),
	HX_HCSTRING("encodeObjects","\x5e","\xad","\x54","\x42"),
	::String(null())
};

void Csv_obj::__register()
{
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("thx.csv.Csv","\x14","\xf1","\xfd","\xca");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &Csv_obj::__GetStatic;
	__mClass->mSetStaticField = &Csv_obj::__SetStatic;
	__mClass->mMarkFunc = Csv_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(Csv_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< Csv_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = Csv_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = Csv_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = Csv_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void Csv_obj::__boot()
{
{
            	HX_STACK_FRAME("thx.csv.Csv","boot",0xfe85d9cc,"thx.csv.Csv.boot","thx/csv/Csv.hx",4,0x755e182c)
HXLINE(   4)		encodeOptions =  ::Dynamic(hx::Anon_obj::Create(4)
            			->setFixed(0,HX_("delimiter",07,07,28,86),HX_(",",2c,00,00,00))
            			->setFixed(1,HX_("newline",54,98,a6,0c),HX_("\n",0a,00,00,00))
            			->setFixed(2,HX_("quote",3c,23,f2,5d),HX_("\"",22,00,00,00))
            			->setFixed(3,HX_("escapedQuote",79,02,8f,79),HX_("\"\"",c0,1d,00,00)));
            	}
{
            	HX_STACK_FRAME("thx.csv.Csv","boot",0xfe85d9cc,"thx.csv.Csv.boot","thx/csv/Csv.hx",10,0x755e182c)
HXLINE(  10)		decodeOptions =  ::Dynamic(hx::Anon_obj::Create(5)
            			->setFixed(0,HX_("delimiter",07,07,28,86),HX_(",",2c,00,00,00))
            			->setFixed(1,HX_("trimValues",64,ea,de,bf),false)
            			->setFixed(2,HX_("trimEmptyLines",b4,03,7f,08),true)
            			->setFixed(3,HX_("quote",3c,23,f2,5d),HX_("\"",22,00,00,00))
            			->setFixed(4,HX_("escapedQuote",79,02,8f,79),HX_("\"\"",c0,1d,00,00)));
            	}
}

} // end namespace thx
} // end namespace csv
